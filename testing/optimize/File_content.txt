
================================================
File: /patch_gui.py
================================================
# patch_gui.py
import faulthandler
faulthandler.enable()
faulthandler.dump_traceback_later(5)

import sys
from PyQt5.QtWidgets import QApplication
import traceback
from holypipette.exception_handler import set_global_exception_hook

# Set the global exception hook
set_global_exception_hook()


from holypipette.log_utils import setup_logging
from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.interface import AutoPatchInterface
from holypipette.interface.pipettes import PipetteInterface
from holypipette.gui.graph import EPhysGraph, CurrentProtocolGraph, VoltageProtocolGraph, HoldingProtocolGraph
from holypipette.gui.patch import PatchGui


from setup.setup_Moscow_rig import *


setup_logging()  # Log to the standard console as well

def main():
    app = QApplication(sys.argv)

    recording_state_manager = RecordingStateManager()

    pipette_controller = PipetteInterface(stage, microscope, camera, unit, cellSorterManip, cellSorterController)
    patch_controller = AutoPatchInterface(amplifier, daq, pressure, pipette_controller)
    gui = PatchGui(camera, pipette_controller, patch_controller, recording_state_manager)
    graphs = EPhysGraph(daq, pressure, recording_state_manager)
    # graphs.location_on_the_screen()
    graphs.show()

    currentProtocolGraph = CurrentProtocolGraph(daq, recording_state_manager)
    voltageProtocolGraph = VoltageProtocolGraph(daq, recording_state_manager)
    holdingProtocolGraph = HoldingProtocolGraph(daq, recording_state_manager)

    gui.initialize()
    # gui.location_on_the_screen()
    gui.show()
    ret = app.exec_()
    sys.exit(ret)

if __name__ == "__main__":
    main()

================================================
File: /setup/setup.py
================================================
from setuptools import setup, find_packages

setup(
    name='holypipette',
    version='0.1',
    description='Semi-automated patch clamp recordings',
    url='https://github.com/romainbrette/holypipette/',
    author='Romain Brette, Marcel Stimberg, Hoang Nguyen',
    author_email='romain.brette@inserm.fr',
    classifiers=[
        'Development Status :: 3 - Alpha',
        'Programming Language :: Python :: 2',
        'Programming Language :: Python :: 3',
    ],
    packages=find_packages(),
    install_requires=['numpy', 'PyQt5', 'qtawesome', 'pillow', 'pyserial',
                      'param', 'pyyaml']
)

================================================
File: /setup/setup_fake_rig.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
from holypipette.devices.amplifier.amplifier import FakeAmplifier
from holypipette.devices.amplifier.DAQ import FakeDAQ
from holypipette.devices.camera.pcocamera import PcoCamera
from holypipette.devices.pressurecontroller.BasePressureController import FakePressureController
from holypipette.devices.camera.camera import FakeCamera
from holypipette.devices.camera import FakeCalCamera, FakePipetteManipulator
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip

controller = FakeManipulator(min=[-240000, 50000, 280000],
                             max=[-230000, 60000, 290000])
pipetteManip = FakeManipulator(min=[0, 0, 0],
                                      max=[4000, 20000, 20000])
stage = ManipulatorUnit(controller, [1, 2])

cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()

pipetteManip.x = [200, 300, 400] # start with pipette in frame
controller.x = [-235000, 55000, 285000]
camera = FakeCalCamera(stageManip=controller, pipetteManip=pipetteManip, image_z=100, cellSorterManip=cellSorterManip)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0

unit = ManipulatorUnit(pipetteManip, [1, 2, 3])

daq = FakeDAQ()
amplifier = FakeAmplifier()
pressure = FakePressureController()




================================================
File: /setup/setup_Moscow_rig.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
import serial
from holypipette.devices.amplifier.multiclamp import MultiClampChannel
from holypipette.devices.amplifier.DAQ import  DAQ
from holypipette.devices.camera.pcocamera import PcoCamera
from holypipette.devices.pressurecontroller import MoscowPressureController
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip


# set up Camera
camera = PcoCamera()

# set up Pressure Controller
pressureControllerSerial = serial.Serial(port='COM5', baudrate=9600, timeout=0)
pressureReaderSerial = serial.Serial(port='COM9', baudrate=9600, timeout=0)
pressure = MoscowPressureController(channel=1, controllerSerial=pressureControllerSerial, readerSerial=pressureReaderSerial)


# set up Ephys
amplifier = MultiClampChannel(channel=1)
daq = DAQ('cDAQ1Mod1', 'ai0', 'cDaq1Mod4', 'ao0', 'cDaq1Mod1', 'ai3')

# set up movement controllers

controllerSerial = serial.Serial('COM6')
controller = ScientificaSerialNoEncoder(controllerSerial)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0

pipetteSerial = serial.Serial('COM3')
pipetteManip = ScientificaSerialNoEncoder(pipetteSerial)
stage = ManipulatorUnit(controller, [1, 2])
unit = ManipulatorUnit(pipetteManip, [1, 2, 3])

# set up cell sorter
cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()


================================================
File: /holypipette/gui/livefeed.py
================================================
from __future__ import print_function
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt

import traceback
import numpy as np

import logging
import time

from holypipette.utils.FileLogger import FileLogger
from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.devices.camera.camera import Camera


__all__ = ['LiveFeedQt']


class LiveFeedQt(QtWidgets.QLabel):
    def __init__(self, camera: Camera, recording_state_manager: RecordingStateManager, image_edit=None, display_edit=None, mouse_handler=None, parent=None):

        super(LiveFeedQt, self).__init__(parent=parent)
        # The image_edit function (does nothing by default) gets the raw
        # unscaled image (i.e. a numpy array), while the display_edit
        # function gets a QPixmap and is meant to draw GUI elements in
        # "display space" (by default, a red cross in the middle of the
        # screen).
        if image_edit is None:
            image_edit = lambda frame: frame
        self.image_edit = image_edit

        if display_edit is None:
            display_edit = lambda img: img
        self.display_edit = display_edit

        self.mouse_handler = mouse_handler
        self.camera = camera
        self.width, self.height = self.camera.width, self.camera.height

        self.setMinimumSize(640, 480)
        self.setAlignment(Qt.AlignCenter)

        self.recording_state_manager = recording_state_manager
        self.recorder = FileLogger(recording_state_manager, folder_path="experiments/Data/rig_recorder_data/", isVideo=True, filetype="csv", recorder_filename="camera_frames")

        # Remember the last frame that we displayed, to not unnecessarily
        # process/show the same frame for slow input sources
        self._last_frameno = None
        self._last_edited_frame = None
        
        self.last_frame_time = None
        self.fps = 0

        self.update_image()

        timer = QtCore.QTimer(self)
        timer.timeout.connect(self.update_image)
        timer.start(28) # 30 fps -> 31.5fps
        # timer.start(16) # 60 fps --> but actually 64 fps
        # timer.start(33) # 30 fps --> but avctually 21.5 fps

    def mousePressEvent(self, event):
        # Ignore clicks that are not on the image
        xs = event.x() - self.size().width() * 0.5
        ys = event.y() - self.size().height() * 0.5
        pixmap = self.pixmap()
        if abs(xs) > pixmap.width() * 0.5 or abs(ys) > pixmap.height() * 0.5:
            self.setFocus()
            return

        if self.mouse_handler is not None:
            self.mouse_handler(event)

    def log_frame_rate(self):
    # Calculate and log the frame rate at which images are processed
        current_time = time.time()
        if self.last_frame_time is not None:
            time_diff = current_time - self.last_frame_time
            self.fps = 1.0 / time_diff
            logging.info(f"FPS in LIVEFEED: {self.fps:.2f}")
        self.last_frame_time = current_time

    @QtCore.pyqtSlot()
    def update_image(self):
        try:
            # get last frame from camera
            frameno, frame_time, frame = self.camera.last_frame_data()

            if frame is None:
                return  # Frame acquisition thread has stopped
            
            if self._last_frameno is None or self._last_frameno != frameno:
                frame = self.image_edit(frame)
            
                self._last_edited_frame = frame
                self._last_frameno = frameno
            else:
                # No need to preprocess a frame again if it has not changed
                frame = self._last_edited_frame

            # * Where you place tihs function is important, relative to repeated frames and such. Either you check in this file 
            # * or in the FileLogger file
            self.recorder.write_camera_frames(frame_time.timestamp(), frame, frameno)
            # self.log_frame_rate()
            # print(f"FRAME SHAPE: {frame.shape}")

            if len(frame.shape) == 2:
                # Grayscale image via MicroManager
                if frame.dtype == np.dtype('uint32'):
                    bytesPerLine = self.width*4
                    format = QtGui.QImage.Format_RGB32
                else:
                    bytesPerLine = self.width
                    format = QtGui.QImage.Format_Indexed8
            else:
                # Color image via OpenCV
                bytesPerLine = 3 * self.width
                format = QtGui.QImage.Format_RGB888
            
            # ? So why frame.data and not frame? frame.data points to a memory location. I think both work, but check https://doc.qt.io/qt-6/qimage.html#QImage-5
            q_image = QtGui.QImage(frame.data, self.width, self.height,
                                   bytesPerLine, format)
            # q_image = QtGui.QImage(frame, self.width, self.height,
            #                        bytesPerLine, format)
            
            
            if format == QtGui.QImage.Format_RGB888:
                # OpenCV returns images as 24bit BGR (and not RGB), but there is no
                # direct support for this format in QImage
                q_image = q_image.rgbSwapped()

            pixmap = QtGui.QPixmap.fromImage(q_image)
            size = self.size()
            width, height = size.width(), size.height()
            scaled_pixmap = pixmap.scaled(width, height,
                                          Qt.KeepAspectRatio,
                                          Qt.SmoothTransformation)
            if self.display_edit is not None:
                self.display_edit(scaled_pixmap)
            self.setPixmap(scaled_pixmap)

        except Exception:
            print(traceback.format_exc())


================================================
File: /holypipette/gui/camera.py
================================================
# coding=utf-8
from __future__ import absolute_import

import collections
# Support older versions of Python
try:
    from collections.abc import Sequence
except ImportError:
    from collections import Sequence

import functools
import logging
import datetime
import os
import traceback
import time
from types import MethodType

import param
from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (QDialog, QPushButton, QDialogButtonBox, QHBoxLayout, QVBoxLayout,
                             QLabel, QLineEdit, QStyle, QFileDialog, QSpinBox)
import qtawesome as qta

from holypipette.interface.camera import CameraInterface
from holypipette.controller import TaskController
from holypipette.config import NumberWithUnit
from holypipette.interface.base import command
from .livefeed import LiveFeedQt


class Logger(QtCore.QAbstractTableModel, logging.Handler):
    def __init__(self):
        super(Logger, self).__init__()
        # We do not actually use the formatter, but the asctime attribute is
        # available if the formatter requires it
        self.setFormatter(logging.Formatter('%(asctime)s'))
        self.messages = []

    def emit(self, record):
        self.format(record)
        entry = (record.levelno,
                 datetime.datetime.strptime(record.asctime, '%Y-%m-%d %H:%M:%S,%f'),
                 record.name,
                 record.message,
                 record.exc_info,
                 record.thread)  # Not displayed by default
        self.beginInsertRows(QtCore.QModelIndex(),
                             len(self.messages), len(self.messages))
        self.messages.append(entry)
        self.endInsertRows()

    def rowCount(self, parent=None):
        return len(self.messages)

    def columnCount(self, parent=None):
        return 4

    def headerData(self, section, orientation, role):
        if role != Qt.DisplayRole:
            return
        if orientation == Qt.Horizontal:
            return ['', 'time', 'origin', 'message'][section]

    def data(self, index, role):
        if not index.isValid():
            return None
        if index.row() >= len(self.messages) or index.row() < 0:
            return None

        level, asctime, name, message, exc_info, _ = self.messages[index.row()]
        if role == Qt.DisplayRole or role == Qt.ToolTipRole:
            if index.column() == 0:
                if level == logging.DEBUG:
                    return 'D'
                elif level == logging.INFO:
                    return 'I'
                elif level == logging.WARN:
                    return 'W'
                elif level == logging.ERROR:
                    return 'E'
                else:
                    return None
            elif index.column() == 1:
                return asctime.strftime('%H:%M:%S,%f')[:-3]  # ms instead of us
            elif index.column() == 2:
                return name
            elif index.column() == 3:
                if role == Qt.DisplayRole:
                    return message
                else:
                    if exc_info is None:
                        return message
                    else:
                        return message + '\n' + ''.join(traceback.format_exception(*exc_info))
            else:
                return None
        if role == Qt.ForegroundRole:
            if level == logging.WARN:
                return QtGui.QColor('darkorange')
            elif level == logging.ERROR:
                return QtGui.QColor('darkred')

    def save_to_file(self, filename):
        with open(filename, 'w') as f:
            for entry in self.messages:
                level, asctime, name, message, exc_info, thread = entry
                fmt = '{level} {time} {origin} {thread_id}: {message}\n'
                level_name = {logging.DEBUG: 'DEBUG',
                             logging.INFO: 'INFO',
                             logging.WARN: 'WARN',
                             logging.ERROR: 'ERROR'}[level]
                if exc_info is not None:
                    message += '\n' + ''.join(traceback.format_exception(*exc_info))
                f.write(fmt.format(level=level_name,
                                   time=asctime.isoformat(' '),
                                   origin=name,
                                   thread_id=thread,
                                   message=message))


class LogViewerWindow(QtWidgets.QMainWindow):
    close_signal = QtCore.pyqtSignal()
    levels = collections.OrderedDict([('DEBUG',logging.DEBUG),
                                      ('INFO', logging.INFO),
                                      ('WARN', logging.WARN),
                                      ('ERROR', logging.ERROR)])

    def __init__(self, parent):
        super(LogViewerWindow, self).__init__(parent=parent)
        self.setWindowTitle('Log')
        self.setAttribute(Qt.WA_ShowWithoutActivating)
        # self.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.log_view = QtWidgets.QTableView()
        self.logger = Logger()
        self.log_view.setModel(self.logger)
        self.log_view.horizontalHeader().setStretchLastSection(True)
        self.log_view.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        # self.log_view.verticalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        self.log_view.setShowGrid(False)
        self.log_view.setAlternatingRowColors(True)
        self.logger.rowsInserted.connect(self.log_view.scrollToBottom)
        logging.getLogger().addHandler(self.logger)
        logging.getLogger().setLevel(logging.DEBUG)
        self.current_levelno = logging.DEBUG
        central_widget = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout()
        self.level_selection = QtWidgets.QComboBox()
        self.level_selection.insertItems(0, self.levels.keys())
        self.level_selection.currentIndexChanged.connect(self.set_level)
        top_row = QtWidgets.QHBoxLayout()
        top_row.addWidget(self.level_selection)
        self.save_button = QtWidgets.QToolButton(clicked=self.save_log)
        self.save_button.setIcon(qta.icon('fa.download'))
        top_row.addWidget(self.save_button)
        layout.addLayout(top_row)
        layout.addWidget(self.log_view)
        central_widget.setLayout(layout)
        self.setCentralWidget(central_widget)

    def closeEvent(self, event):
        self.close_signal.emit()
        super(LogViewerWindow, self).closeEvent(event)

    def set_level(self, level_idx):
        levelno = list(self.levels.values())[level_idx]
        if self.current_levelno == levelno:
            return
        for row in range(self.logger.rowCount()):
            if self.logger.messages[row][0] >= levelno:
                self.log_view.showRow(row)
            else:
                self.log_view.hideRow(row)
        self.current_levelno = levelno

    def save_log(self):
        filename, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'Save Log File',
                                                            filter='Text files(*.txt)',
                                                            options=QtWidgets.QFileDialog.DontUseNativeDialog)
        if not filename:
            return
        try:
            self.logger.save_to_file(filename)
        except (OSError, IOError):
            logging.getLogger(__name__).exception('Saving log file to "{}" '
                                                  'failed.'.format(filename))


class KeyboardHelpWindow(QtWidgets.QMainWindow):

    close_signal = QtCore.pyqtSignal()

    def __init__(self, parent):
        super(KeyboardHelpWindow, self).__init__(parent=parent)
        self.setWindowTitle('Keyboard/mouse commands')
        self.setAttribute(Qt.WA_ShowWithoutActivating)
        self.setWindowFlags(Qt.Tool | Qt.WindowStaysOnTopHint)
        self.label = QtWidgets.QLabel()
        self.setCentralWidget(self.label)
        self.key_catalog = collections.OrderedDict()
        self.mouse_catalog = collections.OrderedDict()
        self.custom_catalog = collections.OrderedDict()

    def keyPressEvent(self, event):
        # Forward key presses to the parent window
        return self.parent().keyPressEvent(event)

    def register_key_action(self, key, modifier, category, description):
        if category not in self.key_catalog:
            self.key_catalog[category] = []
        self.key_catalog[category].append((key, modifier, description))
        self.update_text()

    def register_mouse_action(self, click_type, modifier, category, description):
        if category not in self.mouse_catalog:
            self.mouse_catalog[category] = []
        self.mouse_catalog[category].append((click_type, modifier, description))
        self.update_text()

    def register_custom_action(self, category, action, description):
        if category not in self.custom_catalog:
            self.custom_catalog[category] = []
        self.custom_catalog[category].append((action, description))

    def update_text(self):
        lines = []
        # Keys
        for category, key_info in self.key_catalog.items():
            # FIXME: The logic below assumes that there is no category that does
            # not have any standard key actions. Instead, we should build a
            # list of all categories first and then go through all catalogs.
            lines.append('<tr><td colspan=2 style="font-size: large; padding-top: 1ex">{}</td></tr>'.format(category))

            mouse_info = self.mouse_catalog.get(category, [])
            for click_type, modifier, description in mouse_info:
                if modifier is not None and modifier != Qt.NoModifier:
                    key_text = QtGui.QKeySequence(int(modifier)).toString()
                else:
                    key_text = ''
                if click_type == Qt.LeftButton:
                    mouse_text = 'Left click'
                elif click_type == Qt.RightButton:
                    mouse_text = 'Right click'
                elif click_type == Qt.MiddleButton:
                    mouse_text = 'Middle click'
                else:
                    mouse_text = '??? click'
                action = key_text + mouse_text
                lines.extend(self._format_action(action, description))

            custom_info = self.custom_catalog.get(category, [])
            for action, description in custom_info:
                lines.extend(self._format_action(action, description))

            for key, modifier, description in key_info:
                if modifier is not None:
                    key_text = QtGui.QKeySequence(int(modifier) + key).toString()
                else:
                    key_text = QtGui.QKeySequence(key).toString()

                lines.extend(self._format_action(key_text, description))
        text = '<table>' +('\n'.join(lines)) + '</table>'

        self.label.setText(text)

    def _format_action(self, action, description):
        lines = ['<tr>',
                 '<td style="font-family: monospace; font-weight: bold; align: center; padding-right: 1ex">{}</td>'
                 '<td>{}</td>'.format(action, description),
                 '</tr>']
        return lines

    def closeEvent(self, event):
        self.close_signal.emit()
        super(KeyboardHelpWindow, self).closeEvent(event)


class LogNotifyHandler(logging.Handler):
    def __init__(self, signal):
        super(LogNotifyHandler, self).__init__()
        self.signal = signal

    def emit(self, record):
        self.format(record)
        if record.exc_info is None:
            message = record.msg
        else:
            _, exc, _ = record.exc_info
            message = '{} ({})'.format(record.msg, str(exc))
        self.signal.emit(message)

class RecordingDialog(QDialog):
    def __init__(self, base_directory, frame_rate, pixels, settings, parent=None):
        super(RecordingDialog, self).__init__(parent=parent)

        self.frame_rate = frame_rate
        self.pixels = pixels

        self.setWindowTitle('Recording')
        self.directory_label = QLabel('Directory:')
        self.directory_edit = QLineEdit()
        dir_name = time.strftime('%Y%m%d_%H-%M-%S', time.localtime())
        self.directory_edit.setText(os.path.join(base_directory, dir_name))
        self.directory_button = QPushButton()
        icon = self.style().standardIcon(QStyle.SP_DirIcon)
        self.directory_button.setIcon(icon)
        self.directory_button.clicked.connect(self.directory_clicked)
        directory_layout = QHBoxLayout()
        directory_layout.addWidget(self.directory_label)
        directory_layout.addWidget(self.directory_edit)
        directory_layout.addWidget(self.directory_button)

        skip_label = QLabel('Skip frames:')
        self.skip_spin = QSpinBox()
        self.skip_spin.setRange(0, 10)
        self.skip_spin.valueChanged.connect(self.skip_edited)
        skip_layout = QHBoxLayout()
        skip_layout.addWidget(skip_label)
        skip_layout.addWidget(self.skip_spin)
        self.frame_rate_label = QLabel('')
        self.skip_spin.setValue(settings.get('skip_frames', 0))
        self.skip_edited(self.skip_spin.value())  # trigger even for default value

        memory_label = QLabel('Memory for file queue (MB):')
        self.file_queue_frames = QLabel('')
        self.memory_spin = QSpinBox()
        self.memory_spin.setRange(10, 16000)
        self.memory_spin.valueChanged.connect(self.memory_edited)
        self.memory_spin.setValue(settings.get('memory', 1000))
        self.memory_edited(self.memory_spin.value())  # trigger even for default value
        memory_layout = QHBoxLayout()
        memory_layout.addWidget(memory_label)
        memory_layout.addWidget(self.memory_spin)
        

        self.prefix_label = QLabel('Prefix:')
        self.prefix_edit = QLineEdit()
        self.prefix_edit.textChanged.connect(self.prefix_edited)
        prefix_layout = QHBoxLayout()
        prefix_layout.addWidget(self.prefix_label)
        prefix_layout.addWidget(self.prefix_edit)
        self.prefix_preview = QLabel()
        self.prefix_edit.setText(settings.get('prefix', 'frame'))

        btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)

        self.layout = QVBoxLayout()
        self.layout.addLayout(directory_layout)
        self.layout.addLayout(prefix_layout)
        self.layout.addWidget(self.prefix_preview)
        self.layout.addLayout(skip_layout)
        self.layout.addWidget(self.frame_rate_label)
        self.layout.addLayout(memory_layout)
        self.layout.addWidget(self.file_queue_frames)
        self.layout.addWidget(btns)
        self.setLayout(self.layout)
    
    def prefix_edited(self):
        self.prefix_preview.setText('<i>{}_00000.tiff</i>'.format(self.prefix_edit.text()))

    def skip_edited(self, value):
        if self.frame_rate > 0:
            rate = '~{:.1f}'.format(self.frame_rate / (value + 1))
        else:
            rate = '?'
        self.frame_rate_label.setText('<i>{} frames per second</i>'.format(rate))

    def memory_edited(self, value):
        self.file_queue_frames.setText('<i>space for ~{} frames in queue'.format(int(value*1e6/self.pixels)))

    def directory_clicked(self):
        folder = self.select_folder()
        if folder is not None:
            print(folder, folder)
            self.directory_edit.setText(folder)

    def select_folder(self):
        dialog = QFileDialog(self)
        dialog.setFileMode(QFileDialog.Directory)
        dialog.setOption(QFileDialog.ShowDirsOnly)
        dialog.setWindowTitle('Select recording directory')
        dialog.setDirectory(self.directory_edit.text())
        if dialog.exec_():
            return dialog.selectedFiles()[0]


class CameraGui(QtWidgets.QMainWindow):
    '''
    The basic GUI for showing a camera image.

    Parameters
    ----------
    camera : `.Camera`
        The `.Camera` object that will be used for displaying an image via
        `.LiveFeedQt`.
    image_edit : function or list of functions, optional
        A function that will be called with the numpy array returned by the
        camera. Can be used to post-process the image, e.g. to change its
        brightness.
    display_edit : function or list of functions, optional
        A function that will be called with the `.QPixmap` that is based on
        the camera image. Can be used to display additional information on top
        of this image, e.g. a scale bar or text.
    with_tracking : bool, optional
        Whether to activate the object tracking interface. Defaults to
        ``False``.
    '''
    log_signal = QtCore.pyqtSignal('QString')
    camera_signal = QtCore.pyqtSignal(MethodType, object)
    camera_reset_signal = QtCore.pyqtSignal(TaskController)

    def __init__(self, camera, recording_state_manager, image_edit = None, display_edit = None,
                 with_tracking=False, base_directory='.'):
        super().__init__()
        self.camera = camera
        self.is_recording = False
        self.camera_interface = CameraInterface(camera,
                                                with_tracking=with_tracking)
        self.base_directory = base_directory
        self.show_overlay = True
        self.with_tracking = with_tracking
        self.status_bar = QtWidgets.QStatusBar()
        self.task_abort_button = QtWidgets.QToolButton(clicked=self.abort_task)
        self.task_abort_button.setIcon(qta.icon('fa.ban'))
        self.task_abort_button.setVisible(False)
        self.status_bar.addWidget(self.task_abort_button)
        self.task_progress = QtWidgets.QProgressBar(parent=self)
        self.task_progress.setMaximum(0)
        self.task_progress.setAlignment(Qt.AlignLeft)
        self.task_progress.setTextVisible(False)
        self.task_progress.setVisible(False)
        layout = QtWidgets.QHBoxLayout(self.task_progress)
        self.task_progress_text = QtWidgets.QLabel()
        self.task_progress_text.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.task_progress_text)
        layout.setContentsMargins(0, 0, 0, 0)
        self.status_bar.addWidget(self.task_progress, 1)
        self.status_label = QtWidgets.QLabel()
        self.status_bar.addPermanentWidget(self.status_label)

        self.help_button = QtWidgets.QToolButton(clicked=self.toggle_help)
        self.help_button.setIcon(qta.icon('fa.question-circle'))
        self.help_button.setCheckable(True)
        self.help_button.setToolTip('Toggle help window display')

        self.log_button = QtWidgets.QToolButton(clicked=self.toggle_log)
        self.log_button.setIcon(qta.icon('fa.file'))
        self.log_button.setCheckable(True)
        self.log_button.setToolTip('Toggle log window display')

        self.record_button = QtWidgets.QToolButton(clicked=self.toggle_recording)
        self.record_button.setIcon(qta.icon('fa.video-camera'))
        self.record_button.setCheckable(True)
        self.record_button.setToolTip('Toggle video recording')
        self.record_button.setStyleSheet('QToolButton:checked {background-color: red;}')

        self.autoexposure_button = QtWidgets.QToolButton(clicked=self.camera_interface.normalize)
        self.autoexposure_button.setIcon(qta.icon('fa.camera'))
        self.autoexposure_button.setToolTip('Normalize the image')

        # create autonormalizatoin checkbox
        self.autonormalize_checkbox = QtWidgets.QCheckBox('Auto-normalize')
        self.autonormalize_checkbox.setChecked(False)
        self.autonormalize_checkbox.stateChanged.connect(lambda: self.camera_interface.autonormalize(self.autonormalize_checkbox.isChecked()))

        self.setexposure_edit = QtWidgets.QLineEdit()
        self.setexposure_edit.setMaximumWidth(200)
        self.setexposure_edit.setPlaceholderText('Exposure time (ms)')
        # convert the text to a float and set the exposure time if the user presses enter and clear the text box
        self.setexposure_edit.returnPressed.connect(lambda: self.camera_interface.set_exposure(float(self.setexposure_edit.text())))
        self.setexposure_edit.returnPressed.connect(lambda: self.setexposure_edit.clear())

        self.status_bar.addPermanentWidget(self.setexposure_edit)
        self.status_bar.addPermanentWidget(self.help_button)
        self.status_bar.addPermanentWidget(self.log_button)
        self.status_bar.addPermanentWidget(self.record_button)
        self.status_bar.addPermanentWidget(self.autoexposure_button)
        self.status_bar.addPermanentWidget(self.autonormalize_checkbox)

        self.status_bar.setSizeGripEnabled(False)
        self.setStatusBar(self.status_bar)
        self.status_bar.messageChanged.connect(self.status_message_updated)
        self.status_messages = collections.OrderedDict()
        self.key_actions = {}
        self.mouse_actions = {}
        self.help_window = KeyboardHelpWindow(self)
        self.help_window.setFocusPolicy(Qt.NoFocus)
        self.help_window.setVisible(False)
        self.help_window.close_signal.connect(
            lambda: self.help_button.setChecked(False))
        self.log_window = LogViewerWindow(self)
        self.log_window.setFocusPolicy(Qt.NoFocus)
        self.log_window.close_signal.connect(
            lambda: self.log_button.setChecked(False))
        self.running_task = None
        self.running_task_interface = None
        self.config_button = None  # see initialize
        self.setWindowTitle("Camera GUI")

        self.display_edit_funcs = []
        if display_edit is None:
            display_edit = [self.draw_cross]
        if isinstance(display_edit, Sequence):
            self.display_edit_funcs.extend(display_edit)
        else:
            self.display_edit_funcs.append(display_edit)

        self.image_edit_funcs = []
        if isinstance(image_edit, Sequence):
            self.image_edit_funcs.extend(image_edit)
        elif image_edit is not None:
            self.image_edit_funcs.append(image_edit)
        self.recording_state_manager = recording_state_manager

        self.video = LiveFeedQt(self.camera,
                                image_edit=self.image_edit,
                                display_edit=self.display_edit,
                                mouse_handler=self.video_mouse_press,
                                recording_state_manager=self.recording_state_manager)
        self.recording_settings = {}
        self.setFocus()  # Need this to handle arrow keys, etc.
        self.interface_signals = {self.camera_interface: (self.camera_signal,
                                                          self.camera_reset_signal)}

        self.splitter = QtWidgets.QSplitter()
        self.splitter.addWidget(self.video)
        self.config_tab = QtWidgets.QTabWidget()
        self.splitter.addWidget(self.config_tab)
        self.setCentralWidget(self.splitter)
        self.splitter.setSizes([1, 0])
        self.splitter.splitterMoved.connect(self.splitter_size_changed)

        # Display error messages directly in the status bar
        handler = LogNotifyHandler(self.log_signal)
        handler.setLevel(logging.ERROR)
        logging.getLogger('holypipette').addHandler(handler)
        self.log_signal.connect(self.error_status)

    # Add a cross to the display
    def draw_cross(self, pixmap):
        '''
        Draws a cross at the center. Meant to be used as a ``display_edit``
        function.

        Parameters
        ----------
        pixmap : `QPixmap`
            The pixmap to draw on.
        '''
        painter = QtGui.QPainter(pixmap)
        pen = QtGui.QPen(QtGui.QColor(0, 0, 0, 125))
        pen.setWidth(4)
        painter.setPen(pen)
        c_x, c_y = pixmap.width() // 2, pixmap.height() // 2
        painter.drawLine(c_x - 15, c_y, c_x + 15, c_y)
        painter.drawLine(c_x, c_y - 15, c_x, c_y + 15)
        painter.end()

    def display_edit(self, pixmap):
        '''
        Applies the functions stored in `~.CameraGui.display_edit_funcs` to the
        video image pixmap.

        Parameters
        ----------
        pixmap : `QPixmap`
            The pixmap to draw on.
        '''
        if self.show_overlay:
            for func in self.display_edit_funcs:
                func(pixmap)

    def image_edit(self, image):
        '''
        Applies the functions stored in `~.CameraGui.image_edit_funcs` to the
        video image. Each function works on the result of the previous function

        Parameters
        ----------
        image : `~numpy.ndarray`
            The original video image  or the image returned by a previously
            called function.

        Returns
        -------
        new_image : `~numpy.ndarray`
            The post-processed image. Should be of the same size and data type
            as the original image.
        '''
        for func in self.image_edit_funcs:
            image = func(image)
        return image

    def closeEvent(self, evt):
       self.close()
       return super(CameraGui, self).closeEvent(evt)

    @command(category='General',
             description='Exit the application')
    def exit(self):
        self.close()

    @command(category='Camera',
             description='Toggle recording image files to disk')
    def toggle_recording(self, *args):
        if self.is_recording:
            self.camera.stop_recording()
            self.is_recording = False
        else:
            dlg = RecordingDialog(self.base_directory, frame_rate=self.camera.get_frame_rate(),
                                  pixels=self.camera.width * self.camera.height,
                                  settings=self.recording_settings, parent=self)
            if dlg.exec_():
                directory = os.path.abspath(dlg.directory_edit.text())
                prefix = dlg.prefix_edit.text()
                self.recording_settings['prefix'] = prefix
                memory = dlg.memory_spin.value()
                self.recording_settings['memory'] = memory
                skip_frames = dlg.skip_spin.value()
                self.recording_settings['skip_frames'] = skip_frames
                queue_size = int(memory*1e6/(self.camera.width * self.camera.height)) + 1
                self.camera.start_recording(directory=directory, file_prefix=prefix,
                                            skip_frames=skip_frames, queue_size=queue_size)
                self.is_recording = True
        self.record_button.setChecked(self.is_recording)

    def register_commands(self):
        '''
        Tie keypresses and mouse clicks to commands. Should call
        `.register_key_action` and `.register_mouse_action`. Overriding methods
        in subclass should call the superclass if they want to keep the
        commands registered by the superclass(es).
        '''
        self.register_key_action(Qt.Key_Question, None, self.help_keypress)
        self.register_key_action(Qt.Key_L, None, self.log_keypress)
        self.register_key_action(Qt.Key_N, None, self.camera_interface.normalize)
        self.register_key_action(Qt.Key_Q, Qt.ControlModifier, self.exit)
        self.register_key_action(Qt.Key_Plus, None,
                                 self.camera_interface.increase_exposure,
                                 default_doc=False)
        self.register_key_action(Qt.Key_Minus, None,
                                 self.camera_interface.decrease_exposure,
                                 default_doc=False)
        self.help_window.register_custom_action('Camera', '+/-',
                                                'Increase/decrease exposure by 2.5ms')
        # self.register_key_action(Qt.Key_I, None,
        #                          self.camera_interface.save_image)
        self.register_key_action(Qt.Key_I, Qt.SHIFT,
                                 self.toggle_recording)

    def close(self):
        '''
        Close the GUI.
        '''
        if self.camera:
            logging.info('closing GUI')
            self.camera.stop_acquisition()
            self.camera.stop_recording()
            self.camera.close()
            self.camera = None
        super(CameraGui, self).close()

    def register_mouse_action(self, click_type, modifier, command,
                              default_doc=True):
        '''
        Link a mouse click on the camera image to an action.

        Parameters
        ----------
        click_type : `.Qt.MouseButton`
            The type of click that should be handled as a ``Qt`` constant, e.g.
            `.Qt.LeftButton` or `.Qt.RightButton`.
        modifier : `.Qt.Modifer` or ``None``
            The modifier that needs to be pressed at the same time to trigger
            the action. The modifier needs to be given as a ``Qt`` constant,
            e.g. `.Qt.ShiftModifier` or `.Qt.ControlModifier`. Alternatively,
            ``None`` can be used to specify that the mouse click should lead to
            the action independent of the modifier.
        command : method
            A method implementing the action that has been annotated with the
            `@command <.command>` or `@blocking_command <.blocking_command>`
            decorator.
        default_doc : bool, optional
            Whether to include the action in the automatically generated help.
            Defaults to ``True``.
        '''
        self.mouse_actions[(click_type, modifier)] = command
        if default_doc:
            self.help_window.register_mouse_action(click_type, modifier,
                                                   command.category,
                                                   command.auto_description())

    def video_mouse_press(self, event):
        # Look for an exact match first (key + modifier)
        event_tuple = (event.button(), int(event.modifiers()))
        command = self.mouse_actions.get(event_tuple, None)
        # If not found, check for keys that ignore the modifier
        if command is None:
            command = self.mouse_actions.get((event.button(), None), None)

        if command is not None:
            if self.running_task:
                # Another task is running, ignore the mouse click
                return
            # Mouse commands do not have custom arguments, they always get
            # the position in the image (rescaled, i.e. independent of the
            # window size)
            x, y = event.x(), event.y()
            xs = x - self.video.size().width() / 2.
            ys = y - self.video.size().height() / 2.
            # displayed image is not necessarily the same size as the original camera image
            scale = 1.0 * self.camera.width / self.video.pixmap().size().width()
            position = (xs * scale, ys * scale)
            if command.is_blocking:
                self.start_task(command.task_description, command.__self__)
            if command.__self__ in self.interface_signals:
                command_signal, _ = self.interface_signals[command.__self__]
                command_signal.emit(command, position)
            else:
                command(position)

    @QtCore.pyqtSlot('QString')
    def status_message_updated(self, message):
        if not message:
            self.status_bar.setStyleSheet('QStatusBar{color: black;}')

    @QtCore.pyqtSlot('QString')
    def error_status(self, message):
        self.status_bar.setStyleSheet('QStatusBar{color: red;}')
        self.status_bar.showMessage(message, 5000)

    def initialize(self):
        for interface, (command_signal, reset_signal) in self.interface_signals.items():
            command_signal.connect(interface.command_received)
            reset_signal.connect(interface.reset_requested)
            interface.task_finished.connect(self.task_finished)
            interface.connect(self)
        self.register_commands()
        # Add a button for the configuration options if necessary
        if self.config_tab.count() > 0:
            self.config_button = QtWidgets.QToolButton(
                clicked=self.toggle_configuration_display)
            self.config_button.setIcon(qta.icon('fa.cogs'))
            self.config_button.setCheckable(True)
            self.status_bar.addPermanentWidget(self.config_button)

    def register_key_action(self, key, modifier, command, argument=None,
                            default_doc=True):
        '''
        Link a keypress to an action.

        Parameters
        ----------
        key : `.Qt.Key`
            The key that should be handled, specified as a ``Qt`` constant, e.g.
            `.Qt.Key_X` or `.Qt.Key_5`.
        modifier : `.Qt.Modifer` or ``None``
            The modifier that needs to be pressed at the same time to trigger
            the action. The modifier needs to be given as a ``Qt`` constant,
            e.g. `.Qt.ShiftModifier` or `.Qt.ControlModifier`. Alternatively,
            ``None`` can be used to specify that the keypress should lead to
            the action independent of the modifier.
        command : method
            A method implementing the action that has been annotated with the
            `@command <.command>` or `@blocking_command <.blocking_command>`
            decorator.
        argument : object, optional
            An additional argument that should be handled to the method defined
            as ``command``. Can be used to re-use the same action in a
            parametrized way (e.g. steps of different size).
        default_doc : bool, optional
            Whether to include the action in the automatically generated help.
            Defaults to ``True``.
        '''
        self.key_actions[(key, modifier)] = (command, argument)
        if default_doc:
            self.help_window.register_key_action(key, modifier,
                                                 command.category,
                                                 command.auto_description(argument))

    def start_task(self, task_name, interface):
        self.status_bar.clearMessage()
        self.task_progress_text.setText(task_name + '…')
        self.task_progress.setVisible(True)
        self.task_abort_button.setEnabled(True)
        self.task_abort_button.setVisible(True)
        self.running_task = task_name
        self.running_task_interface = interface

    def abort_task(self):
        self.task_abort_button.setEnabled(False)
        self.running_task_interface.abort_task()

    @QtCore.pyqtSlot(int, object)
    def task_finished(self, exit_reason, controller_or_message):
        if self.running_task is None:
            # This might be a success message for a non-blocking command
            if isinstance(controller_or_message, str):
                self.status_bar.setStyleSheet('QStatusBar{color: black;}')
                self.status_bar.showMessage(controller_or_message, 1000)
            return  # Nothing else to do

        self.task_progress.setVisible(False)
        self.task_abort_button.setVisible(False)
        # 0: correct execution (no need to show a message)
        if exit_reason == 0:
            text = "Task '{}' finished successfully.".format(self.running_task)
            self.status_bar.setStyleSheet('QStatusBar{color: black;}')
            self.status_bar.showMessage(text, 5000)
        # 1: an error occurred (error will be displayed via `error_status`)
        elif exit_reason == 2:
            text = "Task '{}' aborted.".format(self.running_task)
            self.status_bar.setStyleSheet('QStatusBar{color: black;}')
            self.status_bar.showMessage(text, 5000)

        # If the task was aborted or failed, and the "controller" object has a
        # saved state (e.g. the position of the pipette), ask the user whether
        # they want to reset the state
        if (exit_reason != 0 and
                controller_or_message is not None and
                controller_or_message.has_saved_state()):
            reply = QtWidgets.QMessageBox.question(self, "Reset",
                                                   controller_or_message.saved_state_question,
                                                   QtWidgets.QMessageBox.Yes |
                                                   QtWidgets.QMessageBox.No)
            if reply == QtWidgets.QMessageBox.Yes:
                _, reset_signal = self.interface_signals[self.running_task_interface]
                reset_signal.emit(controller_or_message)

        self.running_task = None
        self.running_task_interface = None

    def keyPressEvent(self, event):
        # We remove the keypad modifier, since we do not want to make a
        # difference between key presses as part of the keypad or on the main
        # keyboard (e.g. for the +/- keys). Most importantly, arrow keys always
        # use the keypad modifier on OS X.
        modifiers = event.modifiers() & ~Qt.KeypadModifier

        # Look for an exact match first (key + modifier)
        event_tuple = (event.key(), int(modifiers))
        description = self.key_actions.get(event_tuple, None)
        # If not found, check for keys that ignore the modifier
        if description is None:
            description = self.key_actions.get((event.key(), None), None)

        if description is not None:
            command, argument = description
            if self.running_task and not command.category == 'General':
                # Another task is running, ignore the key press
                # (we allow the "General" category to still allow to see the
                # help, etc.)
                return
            if command.is_blocking:
                self.start_task(command.task_description, command.__self__)
            if command.__self__ in self.interface_signals:
                command_signal, _ = self.interface_signals[command.__self__]
                command_signal.emit(command, argument)
            else:
                command(argument)

    @command(category='General',
             description='Toggle display of keyboard/mouse commands')
    def help_keypress(self):
        self.help_button.click()

    def toggle_help(self):
        if self.help_button.isChecked():
            self.help_window.show()
            # We need to keep the focus
            self.setFocus()
        else:
            self.help_window.setVisible(False)

    @command(category='General',
             description='Toggle display of log output')
    def log_keypress(self):
        self.log_button.click()

    def toggle_log(self):
        if self.log_button.isChecked():
            self.log_window.setVisible(True)
            # We need to keep the focus
            self.setFocus()
        else:
            self.log_window.setVisible(False)

    @QtCore.pyqtSlot('QString', 'QString')
    def set_status_message(self, category, message):
        if message is None and category in self.status_messages:
            del self.status_messages[category]
        else:
            self.status_messages[category] = message

        messages = ' | '.join(self.status_messages.values())
        self.status_label.setText(messages)

    @QtCore.pyqtSlot(int, int)
    def splitter_size_changed(self, pos, index):
        if not self.config_button:
            return  # nothing to do
        # If the splitter is moved all the way to the right, get back the focus
        if self.splitter.sizes()[1] == 0:
            self.setFocus()
            self.config_button.setChecked(False)
        else:
            self.config_button.setChecked(True)

    def add_config_gui(self, config):
        logging.debug('Adding config GUI for {}'.format(config.name))
        config_gui = ConfigGui(config)
        self.config_tab.addTab(config_gui, config.name)
        logging.debug('Config GUI added')

    def add_tab(self, tab, name, index=None):
        if index is None:
            self.config_tab.addTab(tab, name)
        else:
            self.config_tab.insertTab(index, tab, name)

    @command(category='General',
             description='Show/hide the configuration pane')
    def configuration_keypress(self):
        self.config_button.click()

    @command(category='General',
             description='Show/hide the overlay information on the image')
    def toggle_overlay(self):
        self.show_overlay = not self.show_overlay

    def toggle_configuration_display(self):
        current_sizes = self.splitter.sizes()
        if current_sizes[1] == 0:
            min_size = self.config_tab.sizeHint().width()
            new_sizes = [current_sizes[0]-min_size, min_size]
            self.config_button.setChecked(True)
        else:
            new_sizes = [current_sizes[0]+current_sizes[1], 0]
            self.setFocus()
            self.config_button.setChecked(False)
        self.splitter.setSizes(new_sizes)


class ElidedLabel(QtWidgets.QLabel):
    def __init__(self, text, minimum_width=200, *args, **kwds):
        self.minimum_width = minimum_width
        self.text = text
        super(ElidedLabel, self).__init__(*args, **kwds)

    def minimumSizeHint(self):
        return QtCore.QSize(self.minimum_width,
                            super(ElidedLabel, self).minimumSizeHint().height())

    def resizeEvent(self, event):
        metric = QtGui.QFontMetrics(self.font())
        elidedText = metric.elidedText(self.text, QtCore.Qt.ElideRight,
                                       self.width())
        self.setText(elidedText)


class ConfigGui(QtWidgets.QWidget):
    value_changed_signal = QtCore.pyqtSignal('QString', object)

    def __init__(self, config, show_name=False):
        super(ConfigGui, self).__init__()
        self.config = config
        self.config._value_changed = self.value_changed
        self.value_changed_signal.connect(self.display_changed_value)
        layout = QtWidgets.QVBoxLayout()
        layout.setAlignment(Qt.AlignTop)
        top_row = QtWidgets.QHBoxLayout()
        if show_name:
            self.title = QtWidgets.QLabel(config.name)
            self.title.setStyleSheet('font-weight: bold;')
            top_row.addWidget(self.title)
        else:
            top_row.setAlignment(Qt.AlignRight)
        self.load_button = QtWidgets.QToolButton(clicked=self.load_config)
        self.load_button.setIcon(qta.icon('fa.upload'))
        top_row.addWidget(self.load_button)
        self.save_button = QtWidgets.QToolButton(clicked=self.save_config)
        self.save_button.setIcon(qta.icon('fa.download'))
        top_row.addWidget(self.save_button)
        layout.addLayout(top_row)
        all_params = config.params()
        self.value_widgets = {}
        for category, params in config.categories:
            box = QtWidgets.QGroupBox(category)
            rows = QtWidgets.QVBoxLayout()
            for param_name in params:
                param_obj = all_params[param_name]
                row = QtWidgets.QHBoxLayout()
                label = ElidedLabel(param_obj.doc)
                label.setToolTip(param_obj.doc)
                if isinstance(param_obj, param.Number):
                    value_widget = QtWidgets.QDoubleSpinBox()
                    value_widget.setMinimum(param_obj.bounds[0])
                    value_widget.setMaximum(param_obj.bounds[1])
                    value_widget.setValue(getattr(config, param_name))
                    value_widget.valueChanged.connect(functools.partial(self.set_numerical_value, param_name))
                if isinstance(param_obj, NumberWithUnit):
                    value_widget = QtWidgets.QDoubleSpinBox()
                    magnitude = param_obj.magnitude
                    value_widget.setMinimum(param_obj.bounds[0]/magnitude)
                    value_widget.setMaximum(param_obj.bounds[1]/magnitude)
                    value_widget.setValue(getattr(config, param_name)/magnitude)
                    value_widget.valueChanged.connect(
                        functools.partial(self.set_numerical_value_with_unit, param_name, magnitude))
                elif isinstance(param_obj, param.Boolean):
                    value_widget = QtWidgets.QCheckBox()
                    value_widget.setChecked(getattr(config, param_name))
                    value_widget.stateChanged.connect(functools.partial(self.set_boolean_value, param_name, value_widget))
                value_widget.setToolTip(param_obj.doc)
                self.value_widgets[param_name] = value_widget
                row.addWidget(label, stretch=1)
                row.addWidget(value_widget)
                if isinstance(param_obj, NumberWithUnit):
                    unit_label = QtWidgets.QLabel(param_obj.unit)
                    row.addWidget(unit_label)
                rows.addLayout(row)
            box.setLayout(rows)
            layout.addWidget(box)
        self.setLayout(layout)

    def run(self):
        print('running')

    def value_changed(self, key, value):
        if key not in self.value_widgets:
            return
        magnitude = getattr(self.config.params()[key], 'magnitude', 1)
        # We do not update the GUI directly here (that's done in
        # display_changed_value), because it is possible that this is triggered
        # from code running in a different thread
        self.value_changed_signal.emit(key, value/magnitude)

    @QtCore.pyqtSlot('QString', object)
    def display_changed_value(self, key, value):
        widget = self.findChild(QtWidgets.QCheckBox, key)
        if widget:
            if isinstance(value, bool):
                widget.setChecked(value)
            else:
                logging.error(f"Expected boolean, got {type(value)}: {value}")

    def set_numerical_value(self, name, value):
        setattr(self.config, name, value)

    def set_numerical_value_with_unit(self, name, magnitude, value):
        setattr(self.config, name, value*magnitude)

    def set_boolean_value(self, name, widget):
        new_value = widget.isChecked()
        logging.debug(f"Setting {name} to {new_value}")
        setattr(self.config, name, new_value)

    def save_config(self):
        filename, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save configuration",
                                                            filter='Configuration files (*.yaml)',
                                                            options=QtWidgets.QFileDialog.DontUseNativeDialog)
        if filename:
            try:
                self.config.to_file(filename)
            except Exception as ex:
                error_msg = ('Could not save configuration to ' 
                             'file "{}"').format(filename)
                logging.getLogger(__name__).exception(error_msg)
                QtWidgets.QMessageBox.warning(self, 'Saving failed',
                                              error_msg + '\n' + str(ex),
                                              QtWidgets.QMessageBox.Ok)

    def load_config(self):
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Load configuration",
                                                            filter='Configuration files (*.yaml)',
                                                            options=QtWidgets.QFileDialog.DontUseNativeDialog)
        if filename:
            try:
                self.config.from_file(filename)
            except Exception as ex:
                error_msg = ('Could not load configuration from ' 
                             'file "{}"').format(filename)
                logging.getLogger(__name__).exception(error_msg)
                QtWidgets.QMessageBox.warning(self, 'Loading failed',
                                              error_msg + '\n' + str(ex),
                                              QtWidgets.QMessageBox.Ok)


================================================
File: /holypipette/gui/graph.py
================================================
import logging

from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QSlider, QPushButton, QToolButton, QDesktopWidget, QDesktopWidget, QSlider, QToolButton, QApplication
from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import Qt, pyqtSignal, pyqtSlot
from matplotlib.colors import LinearSegmentedColormap, to_hex


from pyqtgraph import PlotWidget
from pyqtgraph.exporters import ImageExporter
import io
from PIL import Image

import threading

import numpy as np
from collections import deque
from holypipette.devices.amplifier import DAQ
from holypipette.devices.pressurecontroller import PressureController
from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.utils import FileLogger
from holypipette.utils import EPhysLogger
import time

from datetime import datetime

__all__ = ["EPhysGraph", "CurrentProtocolGraph", "VoltageProtocolGraph", "HoldingProtocolGraph"]


class CurrentProtocolGraph(QWidget):
    def __init__(self, daq: DAQ, rescording_state_manager: RecordingStateManager):
        super().__init__()
        self.recording_state_manager = rescording_state_manager
        layout = QVBoxLayout()
        self.setWindowTitle("Current Protocol")
        logging.getLogger("matplotlib.font_manager").disabled = True
        self.daq = daq
        self.cprotocolPlot = PlotWidget()
        self.cprotocolPlot.setBackground("w")
        self.cprotocolPlot.getAxis("left").setPen("k")
        self.cprotocolPlot.getAxis("bottom").setPen("k")
        self.cprotocolPlot.setLabel("left", "Voltage", units = "V")
        self.cprotocolPlot.setLabel("bottom", "Time", units = "s")
        layout.addWidget(self.cprotocolPlot)

        self.latestDisplayedData = None

        self.setLayout(layout)
        self.raise_()
        self.show()

        #hide window
        self.setHidden(True)

        #remap close event to hide window
        self.closeEvent = lambda: self.setHidden(True)

        #start async daq data update
        self.updateTimer = QtCore.QTimer()
        self.updateDt = 10 #ms
        self.updateTimer.timeout.connect(self.update_plot)
        self.updateTimer.start(self.updateDt)
        if  not self.updateTimer.isActive():
            logging.info("Cprot Timer not active")

        self.ephys_logger = EPhysLogger(ephys_filename = "CurrentProtocol", recording_state_manager = self.recording_state_manager)

    def update_plot(self):
        # is what we displayed the exact same?
        if self.latestDisplayedData == self.daq.current_protocol_data or self.daq.current_protocol_data is None:
            return
        
        index = self.recording_state_manager.sample_number
        # logging.info(f" current index: {index}")
        #if the window was closed or hidden, relaunch it
        if self.isHidden():
            self.setHidden(False)
            self.isShown = True
        # curr = self.daq.latest_protocol_data
        # logging.info('length of current protocol data: ' + str(len(curr[0])) + ' ' + str(len(curr[1])))
        # make a color gradient based on a list
        color_range = self.daq.pulseRange
        logging.debug(f"color range: {color_range}")
        #make a gradient of colors based off of color_range, a value that should describe the number of pulses (as letters)
        colors = [format((i / color_range), ".2f") for i in range(color_range)]
        start_color = "#003153" #Prussian Blue
        end_color =  "#ffffff" #White
        cmap = LinearSegmentedColormap.from_list("", [start_color, end_color])
        colors = [to_hex(cmap(float(i) / color_range)) for i in range(color_range)]
        pulses = self.daq.pulses
        # colors = ["k", 'r', 'g', 'b', 'y', 'm', 'c']
        self.cprotocolPlot.clear()

        # timestamp = datetime.now().timestamp()
        for i, graph in enumerate(self.daq.current_protocol_data):
            timeData = graph[0]
            respData = graph[1]
            readData = graph[2]
            self.cprotocolPlot.plot(timeData, respData, pen=colors[i])
            logging.info("writing current ephys data to file")
            pulse = str(pulses[i])
            marker = colors[i] + "_" + pulse
            self.ephys_logger.write_ephys_data(index, timeData, readData, respData, marker)
            
            if i == color_range-1:

                logging.info ("saving current ephys plot")
                # self.ephys_logger.write_ephys_data(timestamp, index, timeData, readData, respData, marker)
                self.ephys_logger.save_ephys_plot(index, self.cprotocolPlot)
                self.daq.current_protocol_data = None


        self.latestDisplayedData = self.daq.current_protocol_data.copy()
        
class VoltageProtocolGraph(QWidget):
    def __init__(self, daq: DAQ, recording_state_manager: RecordingStateManager):
        super().__init__()
        self.recording_state_manager = recording_state_manager
        layout = QVBoxLayout()
        self.setWindowTitle("Voltage Protocol (Membrane Test)")
        logging.getLogger('matplotlib.font_manager').disabled = True
        self.daq = daq
        self.vprotocolPlot = PlotWidget()
        self.vprotocolPlot.setBackground('w')
        self.vprotocolPlot.getAxis('left').setPen("k")
        self.vprotocolPlot.getAxis('bottom').setPen("k")
        self.vprotocolPlot.setLabel('left', "PicoAmps", units='A')
        self.vprotocolPlot.setLabel('bottom', "time", units='s')
        layout.addWidget(self.vprotocolPlot)

        self.latestDisplayedData = None

        self.setLayout(layout)
        self.raise_()
        self.show()

        #hide window
        self.setHidden(True)

        #remap close event to hide window
        self.closeEvent = lambda: self.setHidden(True)

        self.updateTimer = QtCore.QTimer()
        self.updateDt = 10 #ms
        self.updateTimer.timeout.connect(self.update_plot)
        self.updateTimer.start(self.updateDt)
        if  not self.updateTimer.isActive():
            logging.info("Vprot Timer not active")

        self.ephys_logger = EPhysLogger(ephys_filename = "VoltageProtocol", recording_state_manager=self.recording_state_manager)


    def update_plot(self):
        #is what we displayed the exact same?

        # logging.warning("window should be shown")
        if np.array_equal(np.array(self.latestDisplayedData), np.array(self.daq.voltage_protocol_data)) or self.daq.voltage_protocol_data is None:
            return

        index = self.recording_state_manager.sample_number
        # logging.info(f"voltage index: {index}")
        #if the window was closed or hidden, relaunch it
        if self.isHidden():
            self.setHidden(False)
            self.isShown = True

        if self.daq.voltage_protocol_data is not None:
            self.vprotocolPlot.clear()
            # print(self.daq.voltage_protocol_data[0, :])
            # print(self.daq.voltage_protocol_data[1, :])
            
            colors = ["k"]
            self.vprotocolPlot.plot(self.daq.voltage_protocol_data[0, :], self.daq.voltage_protocol_data[1, :], pen=colors[0])


            # timestamp = datetime.now().timestamp()
            timeData = self.daq.voltage_protocol_data[0, :]
            respData = self.daq.voltage_protocol_data[1, :]
            readData = self.daq.voltage_command_data[1,:]
            
            # logging.info("writing Voltage ephys data to file")
            self.ephys_logger.write_ephys_data(index, timeData, readData, respData, colors[0])
            self.ephys_logger.save_ephys_plot( index, self.vprotocolPlot)
            self.latestDisplayedData = self.daq.voltage_protocol_data.copy()
            self.daq.voltage_protocol_data = None # This causes a crash

class HoldingProtocolGraph(QWidget):
    def __init__(self, daq : DAQ, recording_state_manager: RecordingStateManager):
        super().__init__()
        self.recording_state_manager = recording_state_manager
        layout = QVBoxLayout()
        self.setWindowTitle("Holding Protocol (E/I PSC Test")
        logging.getLogger('matplotlib.font_manager').disabled = True
        self.daq = daq
        self.hprotocolPlot = PlotWidget()
        self.hprotocolPlot.setBackground('w')
        self.hprotocolPlot.getAxis('left').setPen("k")
        self.hprotocolPlot.getAxis('bottom').setPen("k")
        self.hprotocolPlot.setLabel('left', "PicoAmps", units='A')
        self.hprotocolPlot.setLabel("bottom", "Time", units="s")
        layout.addWidget(self.hprotocolPlot)

        self.latestDisplayedData = None

        self.setLayout(layout)
        self.raise_()
        self.show()

        #hide window
        self.setHidden(True)

        #remap close event to hide window
        self.closeEvent = lambda: self.setHidden(True)

        self.updateTimer = QtCore.QTimer()
        self.updateDt = 10 # ms
        self.updateTimer.timeout.connect(self.update_plot)
        self.updateTimer.start(self.updateDt)
        if  not self.updateTimer.isActive():
            logging.info("Hprot Timer not active")

        self.ephys_logger = EPhysLogger(ephys_filename = "HoldingProtocol", recording_state_manager = self.recording_state_manager)

    def update_plot(self):
        # logging.warning("window should be shown")
        # is what we displayed the exact same?
        if self.daq.holding_protocol_data is None:
            # logging.warning("no new data, skipping plot update")
            return
        
        index = self.recording_state_manager.sample_number
        # logging.info(f" holding index: {index}")
        # logging.warning("new data, updating plot")
        #if the window was closed or hidden, relaunch it
        if self.isHidden():
            self.setHidden(False)
            self.isShown = True

        self.hprotocolPlot.clear()

        colors = ["k"]
        self.hprotocolPlot.plot(self.daq.holding_protocol_data[0, :], self.daq.holding_protocol_data[1, :], pen=colors[0])
        # timestamp = datetime.now().timestamp()
        self.ephys_logger.write_ephys_data(index, self.daq.holding_protocol_data[0,:],self.daq.holding_protocol_data[1,:],self.daq.holding_protocol_data[2,:], colors[0])
        self.ephys_logger.save_ephys_plot( index, self.hprotocolPlot)
    
        self.latestDisplayedData = self.daq.holding_protocol_data.copy()
        self.daq.holding_protocol_data = None

        # self.latestDisplayedData = self.daq.holding_protocol_data.copy()



class EPhysGraph(QWidget):
    """
    A window that plots electrophysiology data from the DAQ
    """

    # Define a signal that can accept DAQ data
    data_updated = pyqtSignal(object, object, object, object, object, object)

    pressureLowerBound = -450
    pressureUpperBound = 730

    def __init__(self, daq: DAQ, pressureController: PressureController, recording_state_manager: RecordingStateManager):
        super().__init__()

        # Stop matplotlib font warnings
        logging.getLogger("matplotlib.font_manager").disabled = True
        self.atmtoggle = True
        self.daq = daq

        # Initialize mode
        self.cellMode = False  # Initially set to Bath Mode

        self.pressureController = pressureController
        self.recording_state_manager = recording_state_manager  # Include the state manager in the graph
        self.setpoint = 0

        # Constants for Multi Clamp
        self.externalCommandSensitivity = 20  # mV/V
        self.triggerLevel = 0.05  # V

        # Setup window
        self.setWindowTitle("Electrophysiology")

        # Initialize plots
        self.cmdPlot = PlotWidget()
        self.respPlot = PlotWidget()
        self.pressurePlot = PlotWidget()
        self.resistancePlot = PlotWidget()

        # Set background color of plots
        self.cmdPlot.setBackground("w")
        self.respPlot.setBackground("w")
        self.pressurePlot.setBackground("w")
        self.resistancePlot.setBackground("w")

        # Set axis colors to black
        for plot in [self.cmdPlot, self.respPlot, self.resistancePlot, self.pressurePlot]:
            plot.setBackground("w")
            plot.getAxis("left").setPen("k")
            plot.getAxis("bottom").setPen("k")

        # Set labels
        self.cmdPlot.setLabel("left", "Command Voltage", units="V")
        self.cmdPlot.setLabel("bottom", "Time", units="s")
        self.respPlot.setLabel("left", "Current (resp)", units="A")
        self.respPlot.setLabel("bottom", "Time", units="s")
        self.pressurePlot.setLabel("left", "Pressure", units="mbar")
        self.pressurePlot.setLabel("bottom", "Time", units="s")
        self.resistancePlot.setLabel("left", "Resistance", units="Ohms")
        self.resistancePlot.setLabel("bottom", "Samples", units="")

        # Initialize data containers
        self.pressureData = deque(maxlen=100)
        self.resistanceDeque = deque(maxlen=100)

        # Thread-safe storage for the latest pressure value
        self.latest_pressure = 0
        self.pressure_lock = threading.Lock()

        # Create layout and add plots
        layout = QVBoxLayout()
        for plot in [self.cmdPlot, self.respPlot, self.pressurePlot, self.resistancePlot]:
            layout.addWidget(plot)

        # Create bottom bar for controls and labels
        self.bottomBar = QWidget()
        self.bottomBarLayout = QHBoxLayout()
        self.bottomBar.setLayout(self.bottomBarLayout)

        self.resistanceLabel = QLabel("Resistance:")
        self.bottomBarLayout.addWidget(self.resistanceLabel)

        self.modelType = QPushButton(f"{'Cell' if self.cellMode else 'Bath'} Mode")
        self.modelType.setStyleSheet(f"background-color: {'green' if self.cellMode else 'blue'}; color: white; border-radius: 5px; padding: 5px;")
        self.bottomBarLayout.addWidget(self.modelType)

        self.accessResistanceLabel = QLabel("Access Resistance: N/A")
        self.bottomBarLayout.addWidget(self.accessResistanceLabel)
        self.membraneResistanceLabel = QLabel("Membrane Resistance: N/A")
        self.bottomBarLayout.addWidget(self.membraneResistanceLabel)
        self.membraneCapacitanceLabel = QLabel("Membrane Capacitance: N/A")
        self.bottomBarLayout.addWidget(self.membraneCapacitanceLabel)

        # Make bottom bar height 20px
        self.bottomBar.setMaximumHeight(20)
        self.bottomBar.setMinimumHeight(20)
        self.bottomBarLayout.setContentsMargins(0, 0, 0, 0)

        # Add a pressure label
        self.pressureLabel = QLabel("Pressure:")
        self.bottomBarLayout.addWidget(self.pressureLabel)

        # Add pressure command box
        self.pressureCommandBox = QLineEdit()
        self.pressureCommandBox.setMaxLength(5)
        self.pressureCommandBox.setFixedWidth(100)
        self.pressureCommandBox.setPlaceholderText(f"{self.pressureController.measure()} mbar")
        self.pressureCommandBox.setValidator(QtGui.QIntValidator(EPhysGraph.pressureLowerBound, EPhysGraph.pressureUpperBound))
        self.pressureCommandBox.returnPressed.connect(self.pressureCommandBoxReturnPressed)

        # Add pressure command slider
        self.pressureCommandSlider = QSlider(Qt.Horizontal)
        self.pressureCommandSlider.setValue(int(self.pressureController.measure()))
        self.pressureCommandSlider.setMinimum(EPhysGraph.pressureLowerBound)
        self.pressureCommandSlider.setMaximum(EPhysGraph.pressureUpperBound)
        self.pressureCommandSlider.setTickInterval(100)
        self.pressureCommandSlider.setTickPosition(QSlider.TicksBelow)
        self.pressureCommandSlider.valueChanged.connect(self.updatePressureLabel)
        self.pressureCommandSlider.sliderReleased.connect(self.pressureCommandSliderChanged)

        # Add up and down buttons for pressure adjustment
        self.upButton = QToolButton()
        self.upButton.setArrowType(Qt.UpArrow)
        self.downButton = QToolButton()
        self.downButton.setArrowType(Qt.DownArrow)
        self.upButton.setFixedWidth(50)
        self.downButton.setFixedWidth(50)
        self.upButton.clicked.connect(self.incrementPressure)
        self.downButton.clicked.connect(self.decrementPressure)

        self.bottomBarLayout.addWidget(self.pressureCommandSlider)
        self.bottomBarLayout.addWidget(self.pressureCommandBox)
        self.bottomBarLayout.addWidget(self.upButton)
        self.bottomBarLayout.addWidget(self.downButton)

        # Add an Atmospheric Pressure toggle button
        self.atmosphericPressureButton = QPushButton("ATM Pressure OFF")
        self.bottomBarLayout.addWidget(self.atmosphericPressureButton)

        # Add spacer to push everything to the left
        self.bottomBarLayout.addStretch(1)

        # Add bottom bar to the main layout
        layout.addWidget(self.bottomBar)

        # Set the main layout
        self.setLayout(layout)

        # Initialize timers
        self.updateTimer = QtCore.QTimer()
        self.updateDt = 20  # ms (~50 Hz)
        self.updateTimer.timeout.connect(self.update_plot)
        self.updateTimer.start(self.updateDt)

        # Initialize a separate timer for pressure updates
        self.pressureUpdateTimer = QtCore.QTimer()
        self.pressureUpdateTimer.timeout.connect(self.update_pressure)
        self.pressureUpdateTimer.start(20)  # 50 Hz

        # Initialize data variables
        self.latestReadData = None
        self.latestrespData = None
        self.lastrespData = []
        self.lastReadData = []
        self.value_width = 10
        # Initialize recorder
        self.recorder = FileLogger(
            recording_state_manager,
            folder_path="experiments/Data/rig_recorder_data/",
            recorder_filename="graph_recording"
        )

        # Connect buttons
        self.atmosphericPressureButton.clicked.connect(self.togglePressure)
        self.modelType.clicked.connect(self.toggleModelType)

        # Connect the signal to the slot
        self.data_updated.connect(self.handle_data_update)

        # Start the background thread for DAQ data acquisition
        self.daqUpdateThread = threading.Thread(target=self.updateDAQDataAsync, daemon=True)
    
        self.daqUpdateThread.start()

        # Show window and bring to front
        self.raise_()
        self.show()



    def closeEvent(self, event):
        """
        Override the close event to properly close the recorder and hide the window.
        """
        self.recorder.close()
        logging.info("Closing EPhysGraph window")
        event.ignore()
        self.hide()

    def updateDAQDataAsync(self):
        """
        Background thread that continuously fetches data from the DAQ and emits signals for GUI updates.
        """
        while True:
            # sleep for 50 ms
            time.sleep(0.025)
            if self.daq.isRunningProtocol:
                continue  # Don't run membrane test while running a current protocol
            try:
                # Fetch data from DAQ
                data = self.daq.getDataFromSquareWave(
                    wave_freq=40,
                    samplesPerSec=100000,
                    dutyCycle=0.5,
                    amplitude=0.5,
                    recordingTime=0.025
                )
            except Exception as e:
                logging.error(f"Error fetching data from DAQ: {e}")
                continue

            if data:
                latestrespData, latestReadData, totalResistance, MembraneResistance, AccessResistance, MembraneCapacitance = data

                # Emit the signal with the fetched DAQ data
                self.data_updated.emit(
                    totalResistance,
                    AccessResistance,
                    MembraneResistance,
                    MembraneCapacitance,
                    latestrespData,
                    latestReadData
                )

    @pyqtSlot(object, object, object, object, object, object)
    def handle_data_update(self, totalResistance, AccessResistance, MembraneResistance, MembraneCapacitance, latestrespData, latestReadData):
        """
        Slot to handle DAQ data updates emitted from the background thread.
        Updates GUI elements safely in the main thread.
        """


        try:

             if totalResistance is not None:
                self.resistanceDeque.append(totalResistance)
                self.resistanceLabel.setText(self.format_label("Total Resistance", totalResistance, "MΩ"))
             if AccessResistance is not None:
                self.accessResistanceLabel.setText(self.format_label("Access Resistance", AccessResistance, "MΩ"))
             if MembraneResistance is not None:
               self.membraneResistanceLabel.setText(self.format_label("Membrane Resistance", MembraneResistance, "MΩ"))
             if MembraneCapacitance is not None:
                self.membraneCapacitanceLabel.setText(self.format_label("Membrane Capacitance", MembraneCapacitance, "pF"))

                    # Update plotting data for cmdPlot and respPlot
                if latestReadData is not None:
                    self.cmdPlot.clear()
                    self.cmdPlot.plot(latestReadData[0, :], latestReadData[1, :])  # Removed pen color
                    self.lastReadData = latestReadData

                if latestrespData is not None:
                    self.respPlot.clear()
                    self.respPlot.plot(latestrespData[0, :], latestrespData[1, :])  # Removed pen color
                    self.lastrespData = latestrespData

                # Handle recording
                if self.recording_state_manager.is_recording_enabled():
                    with self.pressure_lock:
                        currentPressureReading = self.latest_pressure
                    timestamp = datetime.now().timestamp()
                    try:
                        self.recorder.write_graph_data(
                            timestamp,
                            currentPressureReading,
                            totalResistance,
                            list(self.lastrespData[1, :]) if self.lastrespData is not None else [],
                            list(self.lastReadData[1, :]) if self.lastReadData is not None else []
                        )
                    except Exception as e:
                        logging.error(f"Error in writing graph data to file: {e}, {self.lastrespData}")

        except Exception as e:
                logging.error(f"Error in handle_data_update: {e}", exc_info=True)

    def format_label(self,label, value, unit):
        if value is not None:
            return f"{label}: {value:{self.value_width}.2f} {unit}\t"
        else:
            # Pad "N/A" to match the numerical width
            return f"{label}: {'N/A':>{self.value_width}} {unit}\t"

    def update_plot(self):
        """
        Periodically called by a QTimer to update the GUI plots.
        Updates pressure command box placeholder and resistance plot.
        """
        try:
            # Update pressure label based on slider value
            currentSliderValue = self.pressureCommandSlider.value()
            self.pressureCommandBox.setPlaceholderText(f"Set to: {currentSliderValue} mbar")

            # Update resistance plot
            self.resistancePlot.clear()
            displayDequeY = list(self.resistanceDeque)
            displayDequeX = list(range(len(displayDequeY)))
            self.resistancePlot.plot(displayDequeX, displayDequeY, pen="k")

        except Exception as e:
            logging.error(f"Error in update_plot: {e}", exc_info=True)

    def update_pressure(self):
        """
        Periodically called by a separate QTimer to update the pressure graph.
        """
        try:
            currentPressureReading = int(self.pressureController.measure())

            with self.pressure_lock:
                self.latest_pressure = currentPressureReading

            self.pressureData.append(currentPressureReading)

            self.pressurePlot.clear()
            pressureX = [i * self.updateDt / 1000 for i in range(len(self.pressureData))]
            self.pressurePlot.plot(pressureX, list(self.pressureData))

        except Exception as e:
            logging.error(f"Error in update_pressure: {e}", exc_info=True)

    def incrementPressure(self):
        """
        Increments the pressure setpoint by 5 mbar.
        """
        try:
            current_value = self.pressureCommandSlider.value()
            new_value = current_value + 5
            if new_value <= EPhysGraph.pressureUpperBound:
                self.pressureCommandSlider.setValue(new_value)
                self.pressureCommandSlider.sliderReleased.emit()  # Simulate slider release
        except Exception as e:
            logging.error(f"Error in incrementPressure: {e}", exc_info=True)

    def decrementPressure(self):
        """
        Decrements the pressure setpoint by 5 mbar.
        """
        try:
            current_value = self.pressureCommandSlider.value()
            new_value = current_value - 5
            if new_value >= EPhysGraph.pressureLowerBound:
                self.pressureCommandSlider.setValue(new_value)
                self.pressureCommandSlider.sliderReleased.emit()  # Simulate slider release
        except Exception as e:
            logging.error(f"Error in decrementPressure: {e}", exc_info=True)

    def togglePressure(self):
        """
        Toggles the atmospheric pressure setting.
        """
        try:
            if self.atmtoggle:
                self.atmosphericPressureButton.setStyleSheet("background-color: green; color: white; border-radius: 5px; padding: 5px;")
                self.atmosphericPressureButton.setText("ATM Pressure ON")
                self.pressureController.set_ATM(True)
            else:
                self.atmosphericPressureButton.setStyleSheet("")
                self.atmosphericPressureButton.setText("ATM Pressure OFF")
                self.pressureController.set_ATM(False)
            self.atmtoggle = not self.atmtoggle
        except Exception as e:
            logging.error(f"Error in togglePressure: {e}", exc_info=True)

    def toggleModelType(self):
        """
        Toggles between Cell Mode and Bath Mode.
        """
        try:
            if self.daq.cellMode:
                self.modelType.setStyleSheet("background-color: blue; color: white; border-radius: 5px; padding: 5px;")
                self.modelType.setText("Bath Mode")
                self.daq.setCellMode(False)
            else:
                self.modelType.setStyleSheet("background-color: green; color: white; border-radius: 5px; padding: 5px;")
                self.modelType.setText("Cell Mode")
                self.daq.setCellMode(True)

            logging.info(f"Cell Mode: {self.daq.cellMode}")
            self.cellMode = self.daq.cellMode
        except Exception as e:
            logging.error(f"Error in toggleModelType: {e}", exc_info=True)

    def updatePressureLabel(self, value):
        """
        Updates the pressure command box placeholder text based on the slider value.
        """
        try:
            self.pressureCommandBox.setPlaceholderText(f"Set to: {value} mbar")
        except Exception as e:
            logging.error(f"Error in updatePressureLabel: {e}", exc_info=True)

    def pressureCommandSliderChanged(self):
        """
        Manually change pressure setpoint based on slider position.
        """
        try:
            pressure = self.pressureCommandSlider.value()
            self.pressureController.set_pressure(pressure)
            self.pressureCommandBox.setPlaceholderText(f"{pressure} mbar")
        except Exception as e:
            logging.error(f"Error in pressureCommandSliderChanged: {e}", exc_info=True)

    def pressureCommandBoxReturnPressed(self):
        """
        Manually change pressure setpoint based on user input in the command box.
        """
        try:
            text = self.pressureCommandBox.text()
            self.pressureCommandBox.clear()

            pressure = float(text)
            # Clamp the pressure within bounds
            pressure = max(EPhysGraph.pressureLowerBound, min(EPhysGraph.pressureUpperBound, pressure))

            self.pressureController.set_pressure(pressure)
            self.setpoint = pressure
            self.pressureCommandSlider.setValue(int(pressure))
            self.pressureCommandSlider.sliderReleased.emit()  # Simulate slider release
        except ValueError:
            logging.warning("Invalid pressure input. Please enter a valid number.")
        except Exception as e:
            logging.error(f"Error in pressureCommandBoxReturnPressed: {e}", exc_info=True)


================================================
File: /holypipette/gui/manipulator.py
================================================
# coding=utf-8
from types import MethodType
import time

from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont
import numpy as np


from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.controller import TaskController
from holypipette.gui import CameraGui
from holypipette.interface import command, blocking_command
from holypipette.devices.manipulator.calibratedunit import CalibrationError
import datetime
import cv2


class ManipulatorGui(CameraGui):

    pipette_command_signal = QtCore.pyqtSignal(MethodType, object)
    pipette_reset_signal = QtCore.pyqtSignal(TaskController)

    def __init__(self, camera, pipette_interface, with_tracking=False, recording_state_manager: RecordingStateManager = None):
        super(ManipulatorGui, self).__init__(camera, with_tracking=with_tracking,recording_state_manager=recording_state_manager)
        self.setWindowTitle("Pipette GUI")
        self.interface = pipette_interface
        self.control_thread = QtCore.QThread()
        self.control_thread.setObjectName('PipetteControlThread')
        self.interface.moveToThread(self.control_thread)
        self.control_thread.start()
        self.interface_signals[self.interface] = (self.pipette_command_signal,
                                                  self.pipette_reset_signal)
        self.display_edit_funcs.append(self.draw_scale_bar)
        self.display_edit_funcs.append(self.display_manipulator)
        self.display_edit_funcs.append(self.show_tip)
        self.add_config_gui(self.interface.calibration_config)

        self.show_tip_on = False
        self.tip_x, self.tip_y = None, None
        self.tip_t0 = None

        # Stage position for display
        self._last_stage_measurement = None
        self._stage_position = (None, None, None)

        #number of images we've saved so far.  Allows images to have different names
        self.image_save_number = 0
        self.recording_state_manager = recording_state_manager
        if recording_state_manager is None:
            raise ValueError("RecordingStateManager must be provided")


    def display_manipulator(self, pixmap):
        '''
        Displays the number of the selected manipulator.
        '''
        painter = QtGui.QPainter(pixmap)
        pen = QtGui.QPen(QtGui.QColor(200, 0, 0, 125))
        painter.setPen(pen)
        painter.setFont(QFont("Arial", int(pixmap.height()/20)))
        c_x, c_y = pixmap.width() *19.0 / 20, pixmap.height() * 19.0 / 20

    def draw_scale_bar(self, pixmap, text=True, autoscale=True,
                       position=True):
        if autoscale and not text:
            raise ValueError('Automatic scaling of the bar without showing text '
                             'will not be very helpful...')
        stage = self.interface.calibrated_stage
        camera_pixel_per_um = getattr(self.camera, 'pixel_per_um', None)
        if stage.calibrated or camera_pixel_per_um:
            pen_width = 4
            if camera_pixel_per_um is not None:
                bar_length = camera_pixel_per_um
            else:
                bar_length = stage.pixel_per_um()[0]
            scale = 1.0 * self.camera.width / pixmap.size().width()
            scaled_length = bar_length/scale
            if autoscale:
                lengths = np.array([1, 2, 5, 10, 20, 50, 100])
                if scaled_length*lengths[-1] < pen_width:
                    # even the longest bar is not long enough -- don't show
                    # any scale bar
                    return
                elif scaled_length*lengths[0] > 20*pen_width:
                    # the shortest bar is not short enough (>20x the width)
                    length_in_um = lengths[0]
                else:
                    # Use the length that gives a bar of about 10x its width
                    length_in_um = lengths[np.argmin(np.abs(scaled_length*lengths - 10*pen_width))]
            else:
                length_in_um = 10

            painter = QtGui.QPainter(pixmap)
            pen = QtGui.QPen(QtGui.QColor(0, 0, 0, 255))
            pen.setWidth(pen_width)
            painter.setPen(pen)
            c_x, c_y = pixmap.width() / 20, pixmap.height() * 19.0 / 20
            c_x = int(c_x)
            c_y = int(c_y)
            painter.drawLine(int(c_x), c_y,
                             int(c_x + round(length_in_um*scaled_length)), c_y)
            if text:
                painter.drawText(c_x, c_y - 10, '{}µm'.format(length_in_um))
            painter.end()

    def register_commands(self, manipulator_keys = True):
        super(ManipulatorGui, self).register_commands()

        if manipulator_keys:
            # Commands to move the stage
            # Note that we do not use the automatic documentation mechanism here,
            # as we one entry for every possible keypress
            modifiers = [Qt.NoModifier, Qt.AltModifier, Qt.ShiftModifier]
            distances = [10., 2.5, 50.]
            self.help_window.register_custom_action('Stage',  'Arrows',
                                                    'Move stage')
            self.help_window.register_custom_action('Stage',
                                                    '/'.join(QtGui.QKeySequence(mod).toString()
                                                                 if mod is not Qt.NoModifier else 'No modifier'
                                                             for mod in modifiers),
                                                    'Move stage by ' + '/'.join(str(x) for x in distances) + ' µm')
            self.help_window.register_custom_action('Manipulators', 'A/S/W/D',
                                                    'Move pipette by in x/y direction')
            self.help_window.register_custom_action('Manipulators', 'Q/E',
                                                    'Move pipette by in z direction')
            self.help_window.register_custom_action('Manipulators',
                                                    '/'.join(QtGui.QKeySequence(mod).toString()
                                                                 if mod is not Qt.NoModifier else 'No modifier'
                                                             for mod in modifiers),
                                                    'Move pipette by ' + '/'.join(str(x) for x in distances) + ' µm')

            for modifier, distance in zip(modifiers, distances):
                self.register_key_action(Qt.Key_Up, modifier,
                                         self.interface.move_stage_vertical,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_Down, modifier,
                                         self.interface.move_stage_vertical,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_Left, modifier,
                                         self.interface.move_stage_horizontal,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_Right, modifier,
                                         self.interface.move_stage_horizontal,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_W, modifier,
                                         self.interface.move_pipette_y,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_S, modifier,
                                         self.interface.move_pipette_y,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_A, modifier,
                                         self.interface.move_pipette_x,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_D, modifier,
                                         self.interface.move_pipette_x,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_Q, modifier,
                                         self.interface.move_pipette_z,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_E, modifier,
                                         self.interface.move_pipette_z,
                                         argument=-distance, default_doc=False)

        # #save image command
        # self.register_key_action(Qt.Key_I, Qt.NoModifier,
        #                          self.save_image)

        # Show the tip
        self.register_key_action(Qt.Key_T, Qt.NoModifier,
                                 self.show_tip_switch)

        # Calibration commands
        self.register_key_action(Qt.Key_C, Qt.ControlModifier,
                                 self.interface.calibrate_stage)
        self.register_key_action(Qt.Key_C, Qt.NoModifier,
                                 self.interface.calibrate_manipulator)
        self.register_key_action(Qt.Key_F, Qt.ControlModifier,
                                 self.interface.focus_pipette)

        # Move pipette by clicking
        self.register_mouse_action(Qt.LeftButton, Qt.ShiftModifier,
                                   self.interface.move_pipette)

        # Move stage by clicking
        self.register_mouse_action(Qt.RightButton, Qt.NoModifier,
                                   self.interface.move_stage)

        # Microscope control
        self.register_key_action(Qt.Key_PageUp, None,
                                 self.interface.move_microscope,
                                 argument=10, default_doc=False)
        self.register_key_action(Qt.Key_PageDown, None,
                                 self.interface.move_microscope,
                                 argument=-10, default_doc=False)
        key_string = (QtGui.QKeySequence(Qt.Key_PageUp).toString() + '/' +
                      QtGui.QKeySequence(Qt.Key_PageDown).toString())
        self.help_window.register_custom_action('Microscope', key_string,
                                                'Move microscope up/down by 10µm')
        self.register_key_action(Qt.Key_F, None,
                                 self.interface.set_floor)
        self.register_key_action(Qt.Key_G, None,
                                 self.interface.go_to_floor)

        # Show configuration pane
        self.register_key_action(Qt.Key_P, None,
                                 self.configuration_keypress)

        # Toggle overlays
        self.register_key_action(Qt.Key_O, None,
                                 self.toggle_overlay)

    @command(category='Manipulators',
             description='Show the tip of selected manipulator')
    def show_tip_switch(self):
        try:
            self.tip_x, self.tip_y, _ = self.interface.calibrated_unit.reference_position()
            self.tip_t0 = time.time()
            self.show_tip_on = True
        except CalibrationError:  # not yet calibrated
            return

    def show_tip(self, pixmap):
        # Show the tip of the electrode
        if self.show_tip_on:
            interface = self.interface
            scale = 1.0 * self.camera.width / pixmap.size().width()
            pixel_per_um = getattr(self.camera, 'pixel_per_um', None)
            if pixel_per_um is None:
                pixel_per_um = interface.calibrated_unit.stage.pixel_per_um()[0]
            painter = QtGui.QPainter(pixmap)
            pen = QtGui.QPen(QtGui.QColor(0, 0, 200, 125))
            pen.setWidth(3)
            painter.setPen(pen)

            x, y = self.tip_x, self.tip_y
            painter.translate(x / scale, y / scale)

            if x is not None:
                painter.drawRect(-10, -10, 10, 10)
            painter.end()

            # Display for just one second
            if time.time()>self.tip_t0+1.:
                self.show_tip_on = False
    
    @command(category='Camera',
             description='Save the current image to the outputs folder')
    def save_image(self):
        #get the current image
        currImg = self.camera.get_16bit_image()

        #save the image
        cv2.imwrite(f'outputs/{self.image_save_number}.png', currImg)
        print(f'Saved image as outputs/{self.image_save_number}.png')
        self.image_save_number += 1


    def display_timer(self, pixmap):
        interface = self.interface
        painter = QtGui.QPainter(pixmap)
        pen = QtGui.QPen(QtGui.QColor(200, 0, 0, 125))
        pen.setWidth(1)
        painter.setPen(pen)
        c_x, c_y = pixmap.width() / 20, pixmap.height() / 20
        t = int(time.time() - interface.timer_t0)
        hours = t//3600
        minutes = (t-hours*3600)//60
        seconds = t-hours*3600-minutes*60
        painter.drawText(c_x, c_y, '{}'.format(datetime.time(hours,minutes,seconds)))
        painter.end()


================================================
File: /holypipette/gui/__init__.py
================================================
from __future__ import absolute_import
from .livefeed import *
from .camera import *
from .manipulator import ManipulatorGui
from .patch import *
from .graph import CurrentProtocolGraph, EPhysGraph, VoltageProtocolGraph, HoldingProtocolGraph

================================================
File: /holypipette/gui/movingList.py
================================================
# What is this doing here?
import collections

moveList = []
position_history = collections.deque(maxlen = 50)
tracking = False
paramecium_stop = False
contact = True
black_area = []
paramecium_z = None
template = []

================================================
File: /holypipette/gui/patch.py
================================================
from __future__ import absolute_import

from types import MethodType

from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import Qt
import PyQt5.QtGui as QtGui
import numpy as np
import logging

from PyQt5.QtWidgets import QDesktopWidget

from holypipette.controller import TaskController
from holypipette.gui.manipulator import ManipulatorGui
from holypipette.interface.patch import AutoPatchInterface
from holypipette.interface.pipettes import PipetteInterface
from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.interface.base import command

from holypipette.utils.FileLogger import FileLogger
from datetime import datetime
import json
import os

class PatchGui(ManipulatorGui):

    patch_command_signal = QtCore.pyqtSignal(MethodType, object)
    patch_reset_signal = QtCore.pyqtSignal(TaskController)

    def __init__(self, camera, pipette_interface: PipetteInterface, patch_interface: AutoPatchInterface, recording_state_manager: RecordingStateManager, with_tracking=False):
        super(PatchGui, self).__init__(camera, pipette_interface,with_tracking=with_tracking,recording_state_manager=recording_state_manager)

        self.setWindowTitle("Patch GUI")
        # Note that pipette interface already runs in a thread, we need to use
        # the same for the patch interface

        self.patch_interface = patch_interface
        self.pipette_interface = pipette_interface
        self.recording_state_manager = recording_state_manager

        self.patch_interface.moveToThread(pipette_interface.thread())
        self.interface_signals[self.patch_interface] = (self.patch_command_signal,
                                                        self.patch_reset_signal)
    
        try:
            # Add patching button tab
            # button_tab = PatchButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals, self.recording_state_manager)
            self.add_config_gui(self.patch_interface.config)
            logging.debug("Added config GUI.")
            # self.add_tab(button_tab, 'Auto Patching', index=0)
            logging.debug("Added 'Auto Patching' tab.")
        except Exception as e:
            logging.error("Exception during PatchGui initialization: %s", e, exc_info=True)
            raise
        # #add cell sorter button tab
        # cellsorter_tab = CellSorterButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals)
        # self.add_tab(cellsorter_tab, 'Cell Sorter', index = 0)

        # add manual patching button tab
        # manual_patching_tab = ManualPatchButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals, self.recording_state_manager)
        # self.add_tab(manual_patching_tab, 'Manual Patching', index = 0)
        # add semi-auto patching button tab
        semi_auto_patching_tab = SemiAutoPatchButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals, self.recording_state_manager)
        self.add_tab(semi_auto_patching_tab, 'Semi-Auto Patching', index = 0)

        # Update the pressure and information in the status bar every 16ms
        self.pressure_timer = QtCore.QTimer()
        self.pressure_timer.timeout.connect(self.display_pressure)
        self.pressure_timer.start(16)
        self.patch_interface.set_pressure_near()

    def display_pressure(self):

        current_pressure = self.patch_interface.pressure.getLastVal()
        self.set_status_message('pressure', 'Pressure: {:.0f} mbar'.format(current_pressure))

    def register_commands(self):
        super(PatchGui, self).register_commands()
        # self.register_mouse_action(Qt.LeftButton, Qt.ShiftModifier,
        #                            self.patch_interface.patch_with_move)
        self.register_mouse_action(Qt.LeftButton, Qt.NoModifier,
                                   self.patch_interface.add_cell)
        self.register_key_action(Qt.Key_B, None,
                                 self.patch_interface.break_in)
        self.register_key_action(Qt.Key_F2, None,
                                 self.patch_interface.store_cleaning_position)
        self.register_key_action(Qt.Key_F3, None,
                                 self.patch_interface.store_rinsing_position)
        self.register_key_action(Qt.Key_F4, None,
                                 self.patch_interface.clean_pipette)


class TrackingPatchGui(PatchGui):
    def __init__(self, camera, pipette_interface, patch_interface,
                 with_tracking=False):
        super(TrackingPatchGui, self).__init__(camera, pipette_interface,
                                               patch_interface,
                                               with_tracking=True)
        self.setWindowTitle("Patch GUI with tracking")

    def register_commands(self):
        super(TrackingPatchGui, self).register_commands()
        self.register_key_action(Qt.Key_F5, None,
                                 self.patch_interface.sequential_patching)
        self.register_key_action(Qt.Key_F8, None,
                                 self.patch_interface.contact_detection)

class CollapsibleGroupBox(QtWidgets.QGroupBox):
    def __init__(self, title="", parent=None):
        super(CollapsibleGroupBox, self).__init__(parent)
        self.setTitle("")  # Set the group box title to be blank to allow custom styling

        # Apply styles for rounded corners, grey borders, and consistent font
        self.setStyleSheet("""
            QGroupBox {
                border: 1px solid lightgray;  /* Light grey border */
                border-radius: 8px;           /* Rounded corners with 8px radius */
                margin-top: 10px;             /* Adjust top margin for visual separation */
                font-family: Arial, Helvetica, sans-serif;  /* Consistent font family */
                font-size: 14px;              /* Consistent font size for the group box */
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 3px;
                font-weight: bold;            /* Bold for the group box title */
            }
            QWidget {
                background-color: #f9f9f9;    /* Light grey background for the content area */
                border-radius: 8px;
                font-family: Arial, Helvetica, sans-serif;  /* Consistent font family */
                font-size: 14px;              /* Consistent font size for content area */
            }
            QPushButton {
                background-color: #ffffff;     /* White background for buttons */
                border: 1px solid lightgray;   /* Light grey border for buttons */
                border-radius: 6px;            /* Slightly rounded corners for buttons */
                padding: 6px;                  /* Padding for a better button look */
                font-family: Arial, Helvetica, sans-serif;  /* Consistent font family */
                font-size: 14px;               /* Adjusted font size for buttons */
                outline: none;                 /* Remove default focus outline */
            }
            QPushButton:hover {
                background-color: rgba(173, 216, 230, 0.5);  /* Light blue with 50% transparency on hover */
                border: 1px solid #87CEEB;       /* Soft blue border on hover */
            }
            QPushButton:pressed {
                background-color: #d1e7ff;     /* Light blue when pressed for a subtle effect */
            }
            QPushButton:focus {
                border: 1px solid #87CEEB;      /* Consistent border color on focus (soft blue) */
                outline: none;                  /* Remove blue edge or highlight on focus */
            }
        """)

        # Create a toggle button (arrow) for expanding/collapsing
        self.toggle_button = QtWidgets.QToolButton()
        self.toggle_button.setStyleSheet("QToolButton { border: none; font-family: Arial, Helvetica, sans-serif; font-size: 14px; }")
        self.toggle_button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self.toggle_button.setArrowType(Qt.DownArrow)
        self.toggle_button.setText(title)
        self.toggle_button.setCheckable(True)
        self.toggle_button.setChecked(True)
        self.toggle_button.clicked.connect(self.on_toggle)

        # Layout for the toggle button
        self.header_layout = QtWidgets.QHBoxLayout()
        self.header_layout.addWidget(self.toggle_button, alignment=Qt.AlignLeft)
        self.header_layout.addStretch()

        # Content area
        self.content_area = QtWidgets.QWidget()
        self.content_layout = QtWidgets.QVBoxLayout()
        self.content_area.setLayout(self.content_layout)

        # Main layout of the collapsible group box
        self.main_layout = QtWidgets.QVBoxLayout()
        self.main_layout.addLayout(self.header_layout)
        self.main_layout.addWidget(self.content_area)
        self.main_layout.setContentsMargins(5, 5, 5, 5)  # Add some margin to create spacing inside
        self.setLayout(self.main_layout)

    def on_toggle(self):
        if self.toggle_button.isChecked():
            self.content_area.show()
            self.toggle_button.setArrowType(Qt.DownArrow)
        else:
            self.content_area.hide()
            self.toggle_button.setArrowType(Qt.RightArrow)

    def setContentLayout(self, layout):
        # Remove existing layout if any
        while self.content_layout.count():
            child = self.content_layout.takeAt(0)
            if child.widget():
                child.widget().setParent(None)
        self.content_layout.addLayout(layout)

class ButtonTabWidget(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.pos_update_timers = []
        self.pos_labels = []
        self.interface_signals = {}
        self.start_task = None

    def do_nothing(self):
        pass  # a dummy function for buttons that aren't implemented yet

    def run_command(self, cmds):
        if isinstance(cmds, list):
            for cmd in cmds:
                if isinstance(cmd, list):
                    for sub_cmd in cmd:
                        self.execute_command(sub_cmd)
                else:
                    self.execute_command(cmd)
        else:
            self.execute_command(cmds)

    def execute_command(self, cmd):
        logging.info(f"Executing command: {cmd}")
        if hasattr(cmd, 'task_description'):
            self.start_task(cmd.task_description, cmd.__self__)
            if cmd.__self__ in self.interface_signals:
                command_signal, _ = self.interface_signals[cmd.__self__]
                command_signal.emit(cmd, None)
            else:
                cmd(None)
        else:
            cmd()

    def addPositionBox(self, name: str, layout, update_func, tare_func=None, axes=['x', 'y', 'z']):
        # Use CollapsibleGroupBox instead of QGroupBox
        box = CollapsibleGroupBox(name)
        row = QtWidgets.QHBoxLayout()
        indices = []
        # Create a new row for each position
        for j, axis in enumerate(axes):
            # Create a label for the position
            label = QtWidgets.QLabel(f'{axis}: TODO')
            row.addWidget(label)

            indices.append(len(self.pos_labels))
            self.pos_labels.append(label)
        box.setContentLayout(row)
        layout.addWidget(box)

        if tare_func is not None:
            # Add a button to tare the manipulator
            tare_button = QtWidgets.QPushButton('Tare')
            tare_button.clicked.connect(lambda: tare_func())
            row.addWidget(tare_button)

        # Periodically update the position labels
        pos_timer = QtCore.QTimer()
        pos_timer.timeout.connect(lambda: update_func(indices))
        pos_timer.start(16)
        self.pos_update_timers.append(pos_timer)

    def positionAndTareBox(self, name: str, layout, update_func, tare_funcs, axes=['x', 'y', 'z']):
        # Use CollapsibleGroupBox instead of QGroupBox
        box = CollapsibleGroupBox(name)
        main_layout = QtWidgets.QHBoxLayout()
        indices = []

        for j, axis in enumerate(axes):
            axis_layout = QtWidgets.QVBoxLayout()

            # Create a label for the position
            label = QtWidgets.QLabel(f'{axis}: 0.00')
            axis_layout.addWidget(label)
            indices.append(len(self.pos_labels))
            self.pos_labels.append(label)

            # Add a button to tare the manipulator
            tare_button = QtWidgets.QPushButton(f'Tare {axis}')
            tare_button.clicked.connect(tare_funcs[j])
            axis_layout.addWidget(tare_button)

            main_layout.addLayout(axis_layout)

        box.setContentLayout(main_layout)
        layout.addWidget(box)

        # Periodically update the position labels
        pos_timer = QtCore.QTimer()
        pos_timer.timeout.connect(lambda: update_func(indices))
        pos_timer.start(16)
        self.pos_update_timers.append(pos_timer)

    def addButtonList(self, box_name: str, layout: QtWidgets.QVBoxLayout, buttonNames: list[list[str]], cmds):
        # Use CollapsibleGroupBox instead of QGroupBox
        box = CollapsibleGroupBox(box_name)
        rows = QtWidgets.QVBoxLayout()

        for i, buttons_in_row in enumerate(buttonNames):
            new_row = QtWidgets.QHBoxLayout()
            new_row.setAlignment(Qt.AlignLeft)

            for j, button_name in enumerate(buttons_in_row):
                button = QtWidgets.QPushButton(button_name)
                button.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
                button.setMinimumWidth(50)
                button.setMinimumHeight(50)

                # Use a lambda function with default arguments to correctly capture the command
                if i < len(cmds) and j < len(cmds[i]):
                    button_cmd = cmds[i][j]
                    button.clicked.connect(lambda state, cmd=button_cmd: self.run_command(cmd))
                else:
                    button.clicked.connect(self.do_nothing)

                new_row.addWidget(button)
            rows.addLayout(new_row)

        box.setContentLayout(rows)
        layout.addWidget(box)


class SemiAutoPatchButtons(ButtonTabWidget):
    def __init__(self, patch_interface: AutoPatchInterface, pipette_interface: PipetteInterface, start_task, interface_signals, recording_state_manager: RecordingStateManager):
        super().__init__()
        self.patch_interface = patch_interface
        self.pipette_interface = pipette_interface

        self.start_task = start_task
        self.interface_signals = interface_signals

        self.recording_state_manager = recording_state_manager

        layout = QtWidgets.QVBoxLayout()
        layout.setAlignment(Qt.AlignTop)

        self.stage_xy = [0, 0]
        self.stage_z = 0
        self.pipette_xyz = [0, 0, 0]
        self.tare_pipette_pos = [0, 0, 0]

        self.currx_stage_pos = [0, 0, 0]
        self.curry_stage_pos = [0, 0, 0]
        self.currz_stage_pos = [0, 0, 0]
   

        self.recorder = FileLogger(self.recording_state_manager, folder_path="experiments/Data/rig_recorder_data/", recorder_filename="movement_recording")

        # Add position boxes using the updated methods (which use CollapsibleGroupBox)
        self.positionAndTareBox(
            'stage position (um)',
            layout,
            self.update_stage_pos_labels,
            tare_funcs=[self.tare_stage_x, self.tare_stage_y, self.tare_stage_z]
        )
        self.addPositionBox(
            'pipette position (um)',
            layout,
            self.update_pipette_pos_labels,
            tare_func=self.tare_pipette
        )

        # # Add box to emit patching states
        # buttonList = [['Cell Found', 'Gigaseal Reached', 'Whole Cell Achieved'], ['Patch Attempt Start', 'Patch Attempt Failed']]
        # cmds = [
        #     [self.emit_cell_found, self.emit_gigaseal, self.emit_whole_cell],
        #     [self.emit_patch_attempt_start, self.emit_patch_attempt_fail]
        # ]
        # self.addButtonList('patching states', layout, buttonList, cmds)

        # Add a box for calibration setup
        buttonList = [['Calibrate Stage'],['Save cell plane origin'],['Calibrate Pipette'],['Store Safe Position'],['Store Home Position'],['Store Cleaning Position']]
        cmds = [[self.pipette_interface.calibrate_stage],
                [self.pipette_interface.set_floor],
                [self.pipette_interface.record_cal_point],
                [self.patch_interface.store_safe_position],
                [self.patch_interface.store_home_position],
                [self.patch_interface.store_cleaning_position]
        ]
        self.addButtonList('calibration', layout, buttonList, cmds)
        # Add a box for movement commands
        buttonList = [['move group down','move group up'],['Move to Safe Position','Move to Home Position'],['Clean pipette']]
        cmds = [
            [self.patch_interface.move_group_down, self.patch_interface.move_group_up],
            [self.patch_interface.move_to_safe_space, self.patch_interface.move_to_home_space],
            [self.patch_interface.clean_pipette]
        ]
        self.addButtonList('movement', layout, buttonList, cmds)

        # Add a box for patching commands
        buttonList = [['Select Cell', 'Remove Last Cell'],['Hunt Cell','Break In'],['Run Protocols']]
        cmds = [[self.patch_interface.start_selecting_cells, self.patch_interface.remove_last_cell],
                [self.patch_interface.hunt_cell ,self.patch_interface.break_in],
            [[self.patch_interface.run_protocols, self.recording_state_manager.increment_sample_number]]
            
        ]
        self.addButtonList('patching', layout, buttonList, cmds)

        # Add a box for Rig Recorder
        self.record_button = QtWidgets.QPushButton("Start Recording")
        self.record_button.clicked.connect(self.toggle_recording)
        self.record_button.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.record_button.setMinimumWidth(50)
        self.record_button.setMinimumHeight(50)
        layout.addWidget(self.record_button)

        self.setLayout(layout)
    


    def emit_cell_found(self):
        self.patch_interface.state_emitter("NH Success")

    def emit_gigaseal(self):
        self.patch_interface.state_emitter("GS success")

    def emit_whole_cell(self):
        self.patch_interface.state_emitter("WC success")

    def emit_patch_attempt_start(self):
        self.patch_interface.state_emitter("patching started")

    def emit_patch_attempt_fail(self):
        self.patch_interface.state_emitter("patching failed")

    def toggle_recording(self):
        if self.recording_state_manager.is_recording_enabled():
            self.stop_recording()
        else:
            self.start_recording()

    def start_recording(self):
        self.recording_state_manager.set_recording(True)
        self.record_button.setText("Stop Recording")
        self.record_button.setStyleSheet("background-color: red; color: white;border-radius: 5px; padding: 5px;")
        logging.info("Recording started")

    def stop_recording(self):
        self.recording_state_manager.set_recording(False)
        self.record_button.setText("Start Recording")
        self.record_button.setStyleSheet("")
        logging.info("Recording stopped")

    def close(self):
        self.save_stage_pos()
        self.recorder.close()
        super(SemiAutoPatchButtons, self).close()

    def closeEvent(self, event):
        self.save_stage_pos()
        self.recorder.close()
        super(SemiAutoPatchButtons, self).closeEvent(event)

    def tare_pipette(self):
        currPos = self.pipette_interface.calibrated_unit.unit.position()
        self.init_pipette_pos = currPos

    def update_pipette_pos_labels(self, indices):
        # Update the position labels
        # start_time = time.perf_counter_ns()
        currPos = self.pipette_interface.calibrated_unit.unit.position()
        currPos = currPos - self.tare_pipette_pos
        if self.recording_state_manager.is_recording_enabled():
            self.recorder.setBatchMoves(True)
            self.recorder.write_movement_data_batch(
                datetime.now().timestamp(),
                self.stage_xy[0],
                self.stage_xy[1],
                self.stage_z,
                currPos[0],
                currPos[1],
                currPos[2]
            )

        self.pipette_xyz = currPos

        for i, ind in enumerate(indices):
            label = self.pos_labels[ind]
            label.setText(f'{label.text().split(":")[0]}: {currPos[i]:.2f}')


    def tare_stage_x(self):
        xPos = self.pipette_interface.calibrated_stage.position(0)
        self.currx_stage_pos = [xPos, 0, 0]
        print("Tare stage x: ", self.currx_stage_pos)

    def tare_stage_y(self):
        yPos = self.pipette_interface.calibrated_stage.position(1)
        self.curry_stage_pos = [0, yPos, 0]
        print("Tare stage y: ", self.curry_stage_pos)

    def tare_stage_z(self):
        zPos = self.pipette_interface.microscope.position()
        self.currz_stage_pos = [0, 0, zPos]
        print("Tare stage z: ", self.currz_stage_pos)

    def update_stage_pos_labels(self, indices):
        # Update the position labels
        # start_time = time.perf_counter_ns()
        xyPos = self.pipette_interface.calibrated_stage.position() - self.currx_stage_pos[0:2] - self.curry_stage_pos[0:2]
        zPos = self.pipette_interface.microscope.position() - self.currz_stage_pos[2]

        self.stage_xy = xyPos
        self.stage_z = zPos

        for i, ind in enumerate(indices):
            label = self.pos_labels[ind]
            if i < 2:
                label.setText(f'{label.text().split(":")[0]}: {xyPos[i]:.2f}')
            else:
                # Note: divide by 5 here to account for z-axis gear ratio
                label.setText(f'{label.text().split(":")[0]}: {zPos/5:.2f}')



================================================
File: /holypipette/devices/amplifier/amplifier.py
================================================
from holypipette.controller.base import TaskController

all = ['Amplifier',  'FakeAmplifier']


class Amplifier(TaskController):
    """
    Base class for amplifiers.
    """
    
    def start_patch(self, pulse_amplitude=1e-2,
                    pulse_frequency=1e-2):  # Not clear what the units are for frequency
        '''
        Initialize the patch clamp procedure (in bath)
        '''
        pass

    def resistance(self):
        '''
        Returns resistance
        '''
        pass

    def stop_patch(self):
        '''
        Stops patch clamp procedure
        '''
        pass

    def voltage_clamp(self):
        '''
        Switch to voltage clamp mode
        '''
        pass

    def current_clamp(self):
        '''
        Switch to current clamp mode
        '''
        pass
    def auto_fast_compensation(self):
        '''
        Automatically set the fast compensation value
        '''
        pass
    def auto_slow_compensation(self):
        '''
        Automatically set the slow compensation value
        '''
        pass
    
    def get_fast_compensation_capacitance(self):
        '''
        Get the fast compensation value
        '''
        pass
    def set_neutralization_enable(self, state):
        '''
        switch the pipette capacitanceneutralization state

        Parameters
        ----------
        state : bool
            Neutralization state flag
        '''
        pass

    def set_neutralization_capacitance(self,value):
        '''
        Set the pipette capacitance neutralization value

        Parameters
        ----------
        value : float
            Neutralization value
        '''
        pass

    def set_bridge_balance(self, state):
        '''
        Set the bridge balance value

        Parameters
        ----------
        value : bool
            Bridge balance state flag
        '''
        pass

    def auto_bridge_balance(self):
        '''
        Automatically set bridge balancing to minimize the resistance
        '''
        pass

    def switch_holding(self,enable):
        '''
        enable and disable the holding voltage or current

        Parameters
        ----------
        value : bool
            enable/disable flag
        '''
        pass

    def set_holding(self, value):  # Voltage-clamp or Current-clamp value
        '''
        Set voltage/current clamp value

        Parameters
        ----------
        value : float
            Voltage/Current clamp value
        '''
        pass
    def get_holding(self):
        '''
        Get holding voltage or current

        Parameters
        ----------
        value : float
            Voltage/Current clamp value
            
        '''
        pass
    def zap(self):
        '''
        "Zap" the cell to break the membrane
        '''
        pass

    def set_zap_duration(self, duration):
        '''
        Set the duration for the `zap`.
        Parameters
        ----------
        duration : float
            Duration of the zap in seconds.
        '''
        pass

    def auto_pipette_offset(self):
        '''
        Trigger the feature to automatically zero the membrane current.
        '''
        pass

    def close(self):
        '''
        Shut down the connection to the amplifier.
        '''
        pass

class FakeAmplifier(Amplifier):
    """
    "Fake" amplifier that only notes down changes/commands
    """

    def __init__(self):
        self._mode = 'voltage clamp'
        self._resistance = 10*1e6
        self._holding = -70  # holding potential for voltage clamp, holding current for current clamp
        self._patching = False
        self._zap_duration = 0.1

    def start_patch(self, pulse_amplitude=1e-2,
                    pulse_frequency=1e-2):  # Not clear what the units are for frequency
        '''
        Initialize the patch clamp procedure (in bath)
        '''
        self._patching = True
        self.debug('Starting patch')

    def resistance(self):
        '''
        Returns resistance
        '''
        return self._resistance

    def stop_patch(self):
        '''
        Stops patch clamp procedure
        '''
        self._patching = False
        self.debug('Stopping patch')

    def voltage_clamp(self):
        '''
        Switch to voltage clamp mode
        '''
        self.mode = 'voltage clamp'
        self.debug('Switching to voltage clamp mode')

    def current_clamp(self):
        '''
        Switch to current clamp mode
        '''
        self.mode = 'current clamp'
        self.debug('Switching to current clamp mode')

    def set_holding(self, value):
        '''
        Set holding voltage or current

        Parameters
        ----------
        value : float
            Holding voltage or current
        '''
        self._holding = value
        if self.mode == 'voltage clamp':
            holding_what = 'potential'
            unit = 'mV'
        else:
            holding_what = 'current'
            unit = 'pA'
        self.debug('Setting holding {} to {:.2f}{}'.format(holding_what,
                                                           value,
                                                           unit))
    def get_holding(self):
        '''
        Get holding voltage or current
        '''
        self.debug('Getting holding value')
        return self._holding
    
    def zap(self):
        '''
        "Zap" the cell to break the membrane
        '''
        self.debug('Zapping the cell')

    def set_zap_duration(self, duration):
        '''
        Set the duration for the `zap`.
        Parameters
        ----------
        duration : float
            Duration of the zap in seconds.
        '''
        self._zap_duration = duration
        self.debug('Setting zap duration to {:.0f}ms'.format(self._zap_duration*1000))

    def auto_pipette_offset(self):
        '''
        Trigger the feature to automatically zero the membrane current.
        '''
        self.debug('Triggering automatic pipette offset')

    def close(self):
        '''
        Shut down the connection to th eamplifier.
        '''
        self.debug('Shutting down the amplifier')


#TODO: How to best expose Multiclamp's acquire command?

================================================
File: /holypipette/devices/amplifier/AxMultiClampMsg.h
================================================
//***********************************************************************************************
//
//    Copyright (c) 2004 Axon Instruments.
//    All rights reserved.
//
//***********************************************************************************************
// MODULE:  AXMULTICLAMPMSG.HPP
// PURPOSE: Interface definition for AxMultiClampMsg.DLL
// AUTHOR:  GRB  Mar 2004
//

#ifndef INC_AXMULTICLAMPMSG_HPP
#define INC_AXMULTICLAMPMSG_HPP

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// define the macro for exporting/importing the API entry points.
// N.B. the symbol below should only be defined when building this DLL.
#ifdef AXMULTICLAMPMSG_EXPORTS
   #define AXMCCMSG   __declspec(dllexport)
#else
   #define AXMCCMSG   __declspec(dllimport)
#endif

extern "C" {

// The handle type declaration.
DECLARE_HANDLE(HMCCMSG);

// API version number.
#define MCCMSG_APIVERSION       1,0,0,8
#define MCCMSG_APIVERSION_STR  "1.0.0.8"

// Windows Class name for the MultiClamp Commander msg handler hidden window.
#define MCCMSG_CLASSNAME "MultiClampMessageHandlerClass"

//==============================================================================================
// DLL creation/destruction functions
//==============================================================================================

// Check on the version number of the API interface.
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_CheckAPIVersion(LPCSTR pszQueryVersion);

// Create the MultiClamp Commander message handler object.
AXMCCMSG HMCCMSG WINAPI MCCMSG_CreateObject(int *pnError);

// Destroy the MultiClamp Commander message handler object.
AXMCCMSG void  WINAPI MCCMSG_DestroyObject(HMCCMSG hMCCmsg);

//==============================================================================================
// General functions
//==============================================================================================

// Set timeout in milliseconds for messages to MultiClamp Commander.
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetTimeOut(HMCCMSG hMCCmsg, UINT uTimeOutMS, int *pnError);

//==============================================================================================
// MultiClamp 700x Commander selection functions
//==============================================================================================

// Find the first MultiClamp Commander and return device info
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_FindFirstMultiClamp(HMCCMSG hMCCmsg, UINT *puModel, char *pszSerialNum, UINT uBufSize, UINT *puCOMPortID, UINT *puDeviceID, UINT *puChannelID, int *pnError);

// Find next MultiClamp Commander and return device info, returns FALSE when all MultiClamp Commanders have been found
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_FindNextMultiClamp(HMCCMSG hMCCmsg, UINT *puModel, char *pszSerialNum, UINT uBufSize, UINT *puCOMPortID, UINT *puDeviceID, UINT *puChannelID, int *pnError);

// Select MultiClamp Commander for communication, returns TRUE if communication established
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SelectMultiClamp(HMCCMSG hMCCmsg, UINT uModel, char *pszSerialNum, UINT uCOMPortID, UINT uDeviceID, UINT uChannelID, int *pnError);

//==============================================================================================
// MCC Mode functions
//==============================================================================================

// Set the amplifier mode i.e voltage clamp, current clamp, or current = 0
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetMode(HMCCMSG hMCCmsg, UINT uModeID, int *pnError);

// Get the amplifier mode i.e voltage clamp, current clamp, or current = 0
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetMode(HMCCMSG hMCCmsg, UINT *puModeID, int *pnError);

// Set auto or external mode switching enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetModeSwitchEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get auto or external mode switching enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetModeSwitchEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

//==============================================================================================
// MCC Feedback Resistor functions
//==============================================================================================

// Get Feedback Resistor for Channel 1 Voltage Clamp.
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetFeedbackResistorVC1(HMCCMSG hMCCmsg, UINT *puVal, int *pnError);
// Get Feedback Resistor for Channel 1 Current Clamp.
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetFeedbackResistorIC1(HMCCMSG hMCCmsg, UINT *puVal, int *pnError);
// Get Feedback Resistor for Channel 2 Voltage Clamp.
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetFeedbackResistorVC2(HMCCMSG hMCCmsg, UINT *puVal, int *pnError);
// Get Feedback Resistor for Channel 2 Current Clamp.
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetFeedbackResistorIC2(HMCCMSG hMCCmsg, UINT *puVal, int *pnError);

//==============================================================================================
// MCC Holding functions
//==============================================================================================

// Set holding enable (voltage clamp or current clamp)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetHoldingEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get holding enable (voltage clamp or current clamp)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetHoldingEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set holding level (voltage clamp or current clamp)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetHolding(HMCCMSG hMCCmsg, double dHolding, int *pnError);

// Get holding level (voltage clamp or current clamp)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetHolding(HMCCMSG hMCCmsg, double *pdHolding, int *pnError);

//==============================================================================================
// MCC Seal Test and Tuning functions
//==============================================================================================

// Set test signal enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetTestSignalEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Set test signal enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetTestSignalEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set test signal amplitude (VC = Seal Test amplitude, IC = Tuning amplitude)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetTestSignalAmplitude(HMCCMSG hMCCmsg, double dAmplitude, int *pnError);

// Get test signal amplitude (VC = Seal Test amplitude, IC = Tuning amplitude)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetTestSignalAmplitude(HMCCMSG hMCCmsg, double *pdAmplitude, int *pnError);

// Set test signal frequency (VC = Seal Test frequency, IC = Tuning frequency)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetTestSignalFrequency(HMCCMSG hMCCmsg, double dFrequency, int *pnError);

// Get test signal frequency (VC = Seal Test frequency, IC = Tuning frequency)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetTestSignalFrequency(HMCCMSG hMCCmsg, double *pdFrequency, int *pnError);

//==============================================================================================
// MCC Pipette Offset functions
//==============================================================================================

// Execute auto pipette offset
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_AutoPipetteOffset(HMCCMSG hMCCmsg, int *pnError);

// Set pipette offset
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetPipetteOffset(HMCCMSG hMCCmsg, double dPipetteOffset, int *pnError);

// Get pipette offset
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetPipetteOffset(HMCCMSG hMCCmsg, double *pdPipetteOffset, int *pnError);

//==============================================================================================
// MCC Inject Slow Current functions (IC only)
//==============================================================================================

// Set slow current injection enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSlowCurrentInjEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Set slow current injection enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSlowCurrentInjEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set slow current injection level (volts)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSlowCurrentInjLevel(HMCCMSG hMCCmsg, double dLevel, int *pnError);

// Get slow current injection level(volts)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSlowCurrentInjLevel(HMCCMSG hMCCmsg, double *pdLevel, int *pnError);

// Set slow current injection settling time to 99% of final value (seconds) 
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSlowCurrentInjSettlingTime(HMCCMSG hMCCmsg, double dSettlingTime, int *pnError);

// Get slow current injection settling time to 99% of final value (seconds) 
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSlowCurrentInjSettlingTime(HMCCMSG hMCCmsg, double *pdSettlingTime, int *pnError);

//==============================================================================================
// MCC Compensation functions (VC only)
//==============================================================================================

// Set the fast compensation capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetFastCompCap(HMCCMSG hMCCmsg, double dFastCompCap, int *pnError);

// Get the fast compensation capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetFastCompCap(HMCCMSG hMCCmsg, double *pdFastCompCap, int *pnError);

// Set the slow compensation capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSlowCompCap(HMCCMSG hMCCmsg, double dSlowCompCap, int *pnError);

// Get the slow compensation capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSlowCompCap(HMCCMSG hMCCmsg, double *pdSlowCompCap, int *pnError);

// Set the fast compensation time constant
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetFastCompTau(HMCCMSG hMCCmsg, double dFastCompTau, int *pnError);

// Get the fast compensation time constant
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetFastCompTau(HMCCMSG hMCCmsg, double *pdFastCompTau, int *pnError);

// Set the slow compensation time constant
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSlowCompTau(HMCCMSG hMCCmsg, double dSlowCompTau, int *pnError);

// Get the slow compensation time constant
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSlowCompTau(HMCCMSG hMCCmsg, double *pdSlowCompTau, int *pnError);

// Set x20 slow compensation time constant enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSlowCompTauX20Enable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get x20 slow compensation time constant enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSlowCompTauX20Enable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Execute auto fast compensation
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_AutoFastComp(HMCCMSG hMCCmsg, int *pnError);

// Execute auto slow compensation
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_AutoSlowComp(HMCCMSG hMCCmsg, int *pnError);

//==============================================================================================
// MCC Pipette Capacitance Neutralization functions (IC only)
//==============================================================================================

// Set Pipette Capacitance Neutralization enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetNeutralizationEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get Pipette Capacitance Neutralization enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetNeutralizationEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set Pipette Capacitance Neutralization capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetNeutralizationCap(HMCCMSG hMCCmsg, double dCap, int *pnError);

// Get Pipette Capacitance Neutralization capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetNeutralizationCap(HMCCMSG hMCCmsg, double *pdCap, int *pnError);

//==============================================================================================
// MCC Whole Cell functions (VC only)
//==============================================================================================

// Set whole cell compensation enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetWholeCellCompEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get whole cell compensation enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetWholeCellCompEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set whole cell compensation capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetWholeCellCompCap(HMCCMSG hMCCmsg, double dCap, int *pnError);

// Get whole cell compensation capacitance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetWholeCellCompCap(HMCCMSG hMCCmsg, double *pdCap, int *pnError);

// Set whole cell compensation resistance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetWholeCellCompResist(HMCCMSG hMCCmsg, double dResist, int *pnError);

// Get whole cell compensation resistance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetWholeCellCompResist(HMCCMSG hMCCmsg, double *pdResist, int *pnError);

// Execute auto whole cell compensation
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_AutoWholeCellComp(HMCCMSG hMCCmsg, int *pnError);

//==============================================================================================
// MCC Rs Compensation functions (VC only)
//==============================================================================================

// Set Rs compensation enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetRsCompEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get Rs compensation enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetRsCompEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set Rs compensation bandwidth
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetRsCompBandwidth(HMCCMSG hMCCmsg, double dBandwidth, int *pnError);

// Get Rs compensation bandwidth
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetRsCompBandwidth(HMCCMSG hMCCmsg, double *pdBandwidth, int *pnError);

// Set Rs compensation correction
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetRsCompCorrection(HMCCMSG hMCCmsg, double dCorrection, int *pnError);

// Get Rs compensation correction
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetRsCompCorrection(HMCCMSG hMCCmsg, double *pdCorrection, int *pnError);

// Set Rs compensation prediction
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetRsCompPrediction(HMCCMSG hMCCmsg, double dPrediction, int *pnError);

// Get Rs compensation prediction
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetRsCompPrediction(HMCCMSG hMCCmsg, double *pdPrediction, int *pnError);

//==============================================================================================
// MCC Oscillation Killer functions
//==============================================================================================

// Set oscillation killer enable 
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetOscKillerEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get oscillation killer enable (VC = Rs Comp, IC = Pip Cap Neut)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetOscKillerEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

//==============================================================================================
// MCC Primary (or Scaled) Signal functions
//==============================================================================================

// Set primary signal
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetPrimarySignal(HMCCMSG hMCCmsg, UINT uSignalID, int *pnError);

// Get primary signal
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetPrimarySignal(HMCCMSG hMCCmsg, UINT *puSignalID, int *pnError);

// Set primary signal gain
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetPrimarySignalGain(HMCCMSG hMCCmsg, double dGain, int *pnError);

// Get primary signal gain
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetPrimarySignalGain(HMCCMSG hMCCmsg, double *pdGain, int *pnError);

// Set primary signal lowpass filter cut-off frequency (Bessel or Butterworth)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetPrimarySignalLPF(HMCCMSG hMCCmsg, double dLPF, int *pnError);

// Get primary signal lowpass filter cut-off frequency (Bessel or Butterworth)
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetPrimarySignalLPF(HMCCMSG hMCCmsg, double *pdLPF, int *pnError);

// Set primary signal highpass filter cut-off frequency
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetPrimarySignalHPF(HMCCMSG hMCCmsg, double dHPF, int *pnError);

// Get primary signal highpass filter cut-off frequency
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetPrimarySignalHPF(HMCCMSG hMCCmsg, double *pdHPF, int *pnError);

//==============================================================================================
// MCC Scope Signal functions
//==============================================================================================

// Set scope signal lowpass filter cut-off frequency
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetScopeSignalLPF(HMCCMSG hMCCmsg, double dLPF, int *pnError);

// Get scope signal lowpass filter cut-off frequency
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetScopeSignalLPF(HMCCMSG hMCCmsg, double *pdLPF, int *pnError);

//==============================================================================================
// MCC Secondary (or Raw) Signal functions
//==============================================================================================

// Set secondary signal
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSecondarySignal(HMCCMSG hMCCmsg, UINT uSignalID, int *pnError);

// Get secondary signal
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSecondarySignal(HMCCMSG hMCCmsg, UINT *puSignalID, int *pnError);

// Set secondary signal gain
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSecondarySignalGain(HMCCMSG hMCCmsg, double dGain, int *pnError);

// Get secondary signal gain
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSecondarySignalGain(HMCCMSG hMCCmsg, double *pdGain, int *pnError);

// Set secondary signal lowpass filter cut-off frequency
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetSecondarySignalLPF(HMCCMSG hMCCmsg, double dLPF, int *pnError);

// Get secondary signal lowpass filter cut-off frequency
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetSecondarySignalLPF(HMCCMSG hMCCmsg, double *pdLPF, int *pnError);

//==============================================================================================
// MCC Output Zero functions
//==============================================================================================

// Set output zero enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetOutputZeroEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get output zero enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetOutputZeroEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set output zero amplitude
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetOutputZeroAmplitude(HMCCMSG hMCCmsg, double dAmplitude, int *pnError);

// Get output zero amplitude
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetOutputZeroAmplitude(HMCCMSG hMCCmsg, double *pdAmplitude, int *pnError);

// Execute auto output zero
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_AutoOutputZero(HMCCMSG hMCCmsg, int *pnError);

//==============================================================================================
// MCC Leak Subtraction functions (VC only)
//==============================================================================================

// Set leak subtraction enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetLeakSubEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get leak subtraction enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetLeakSubEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set leak subtraction resistance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetLeakSubResist(HMCCMSG hMCCmsg, double dResistance, int *pnError);

// Get leak subtraction resistance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetLeakSubResist(HMCCMSG hMCCmsg, double *pdResistance, int *pnError);

// Execute auto leak subtraction
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_AutoLeakSub(HMCCMSG hMCCmsg, int *pnError);

//==============================================================================================
// MCC Bridge Balance functions (IC only)
//==============================================================================================

// Set bridge balance enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetBridgeBalEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get bridge balance enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetBridgeBalEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set bridge balance resistance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetBridgeBalResist(HMCCMSG hMCCmsg, double dResistance, int *pnError);

// Get bridge balance resistance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetBridgeBalResist(HMCCMSG hMCCmsg, double *pdResistance, int *pnError);

// Execute auto bridge balance
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_AutoBridgeBal(HMCCMSG hMCCmsg, int *pnError);

//==============================================================================================
// MCC Clear functions (IC only)
//==============================================================================================

// Execute clear +
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_ClearPlus(HMCCMSG hMCCmsg, int *pnError);

// Execute clear -
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_ClearMinus(HMCCMSG hMCCmsg, int *pnError);

//==============================================================================================
// MCC Pulse, Zap and Buzz functions
//==============================================================================================

// Execute pulse
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_Pulse(HMCCMSG hMCCmsg, int *pnError);

// Set pulse amplitude
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetPulseAmplitude(HMCCMSG hMCCmsg, double dAmplitude, int *pnError);

// Get pulse amplitude
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetPulseAmplitude(HMCCMSG hMCCmsg, double *pdAmplitude, int *pnError);

// Set pulse duration
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetPulseDuration(HMCCMSG hMCCmsg, double dDuration, int *pnError);

// Get pulse duration
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetPulseDuration(HMCCMSG hMCCmsg, double *pdDuration, int *pnError);

// Execute zap
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_Zap(HMCCMSG hMCCmsg, int *pnError);

// Set zap duration
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetZapDuration(HMCCMSG hMCCmsg, double dDuration, int *pnError);

// Get zap duration
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetZapDuration(HMCCMSG hMCCmsg, double *pdDuration, int *pnError);

// Execute buzz
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_Buzz(HMCCMSG hMCCmsg, int *pnError);

// Set buzz duration
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetBuzzDuration(HMCCMSG hMCCmsg, double dDuration, int *pnError);

// Get buzz duration
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetBuzzDuration(HMCCMSG hMCCmsg, double *pdDuration, int *pnError);

//==============================================================================================
// MCC Meter functions
//==============================================================================================

// Set resistance meter enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetMeterResistEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get resistance meter enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetMeterResistEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Set Irms meter enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_SetMeterIrmsEnable(HMCCMSG hMCCmsg, BOOL bEnable, int *pnError);

// Get Irms meter enable
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetMeterIrmsEnable(HMCCMSG hMCCmsg, BOOL *pbEnable, int *pnError);

// Get the specified meter value in SI units
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_GetMeterValue(HMCCMSG hMCCmsg, double *pdValue, UINT uMeterID, int *pnError);

//==============================================================================================
// MCC Tool Bar functions
//==============================================================================================

// Execute Reset to Program Defaults
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_Reset(HMCCMSG hMCCmsg, int *pnError);

// Toggle Always OnTop
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_ToggleAlwaysOnTop(HMCCMSG hMCCmsg, int *pnError);

// Toggle Resize
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_ToggleResize(HMCCMSG hMCCmsg, int *pnError);

// Execute Quick Select Buttons
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_QuickSelectButton(HMCCMSG hMCCmsg, UINT uButtonID, int *pnError);

//==============================================================================================
// Error functions
//==============================================================================================

// Errors etc.
AXMCCMSG BOOL WINAPI EXPORT MCCMSG_BuildErrorText(HMCCMSG hMCCmsg, int nErrorNum, LPSTR sTxtBuf, UINT uMaxLen);

//==============================================================================================
// Error codes
//==============================================================================================

// General error codes.
const int MCCMSG_ERROR_NOERROR                         = 6000;
const int MCCMSG_ERROR_OUTOFMEMORY                     = 6001;
const int MCCMSG_ERROR_MCCNOTOPEN                      = 6002;
const int MCCMSG_ERROR_INVALIDDLLHANDLE                = 6003;
const int MCCMSG_ERROR_INVALIDPARAMETER                = 6004;
const int MCCMSG_ERROR_MSGTIMEOUT                      = 6005;
const int MCCMSG_ERROR_MCCCOMMANDFAIL                  = 6006;

//==============================================================================================
// Function parameters
//==============================================================================================

// Parameters for MCCMSG_FindFirstMultiClamp(), MCCMSG_FindNextMultiClamp() and MCCMSG_SelectMultiClamp()
// uModel filled in / or puModel filled out as:
const int MCCMSG_HW_TYPE_MC700A                         = 0;
const int MCCMSG_HW_TYPE_MC700B                         = 1;

// Parameters for MCCMSG_SetMode() and MCCMSG_GetMode()
// uModeID filled in / or puModeID filled out as:
const UINT MCCMSG_MODE_VCLAMP                           = 0;
const UINT MCCMSG_MODE_ICLAMP                           = 1;   
const UINT MCCMSG_MODE_ICLAMPZERO                       = 2;

// Parameters for MCCMSG_QuickSelectButton()
// uButtonID filled in as:
const UINT MCCMSG_QSB_1                                 = 0;
const UINT MCCMSG_QSB_2                                 = 1;
const UINT MCCMSG_QSB_3                                 = 2;

// Parameters for MCCMSG_SetPrimarySignal(), MCCMSG_SetPrimarySignal()
// uSignalID filled in / or puSignalID filled out as:
const UINT MCCMSG_PRI_SIGNAL_VC_MEMBCURRENT             = 0;  // 700B and 700A 
const UINT MCCMSG_PRI_SIGNAL_VC_MEMBPOTENTIAL           = 1;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_PIPPOTENTIAL            = 2;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_100XACMEMBPOTENTIAL     = 3;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_EXTCMDPOTENTIAL         = 4;  // 700B only
const UINT MCCMSG_PRI_SIGNAL_VC_AUXILIARY1              = 5;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_AUXILIARY2              = 6;  // 700B only

const UINT MCCMSG_PRI_SIGNAL_IC_MEMBPOTENTIAL           = 7;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_MEMBCURRENT             = 8;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_CMDCURRENT              = 9;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_100XACMEMBPOTENTIAL     = 10; // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_EXTCMDCURRENT           = 11; // 700B only
const UINT MCCMSG_PRI_SIGNAL_IC_AUXILIARY1              = 12; // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_AUXILIARY2              = 13; // 700B only

// Parameters for MCCMSG_SetSecondarySignal(), MCCMSG_SetSecondarySignal()
// uSignalID filled in / or puSignalID filled out as:
const UINT MCCMSG_SEC_SIGNAL_VC_MEMBCURRENT             = 0;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_MEMBPOTENTIAL           = 1;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_PIPPOTENTIAL            = 2;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_100XACMEMBPOTENTIAL     = 3;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_EXTCMDPOTENTIAL         = 4;  // 700B only
const UINT MCCMSG_SEC_SIGNAL_VC_AUXILIARY1              = 5;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_AUXILIARY2              = 6;  // 700B only

const UINT MCCMSG_SEC_SIGNAL_IC_MEMBPOTENTIAL           = 7;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_MEMBCURRENT             = 8;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_CMDCURRENT              = 9;  //          700A only
const UINT MCCMSG_SEC_SIGNAL_IC_PIPPOTENTIAL            = 10; // 700B only
const UINT MCCMSG_SEC_SIGNAL_IC_100XACMEMBPOTENTIAL     = 11; // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_EXTCMDCURRENT           = 12; // 700B only
const UINT MCCMSG_SEC_SIGNAL_IC_AUXILIARY1              = 13; // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_AUXILIARY2              = 14; // 700B only

// Parameters for MCCMSG_GetMeterValue()
const UINT MCCMSG_METER1                                = 0;  // 700B 
const UINT MCCMSG_METER2                                = 1;  // 700B 
const UINT MCCMSG_METER3                                = 2;  // 700B 
const UINT MCCMSG_METER4                                = 3;  // 700B 

//==============================================================================================
// Constants
//==============================================================================================

const UINT MCCMSG_TIMEOUT_DEFAULT                       = 3000; // default time out (3 sec).
const UINT MCCMSG_SERIALNUM_SIZE                        = 16;

} // end of extern "C"

#endif // INC_AXMULTICLAMPMSG_HPP

================================================
File: /holypipette/devices/amplifier/__init__.py
================================================
from __future__ import absolute_import
from .multiclamp import *

================================================
File: /holypipette/devices/amplifier/multiclamp.py
================================================
"""
### Ported from Clamper
## configure_board and acquire() are unused here

Basic Interface to the MultiClamp 700A and 700B amplifiers.

Note that the MultiClamp Commander has to be running in order to use the device.

For each of the two channels, we have:
* command (I or V)
* primary
* secondary
* scope
There is also a scope trigger (in the rear)

Gains: actually these are additional gains

"""
from __future__ import print_function
import ctypes
import functools
import logging
import os
import traceback
import time

from holypipette.devices.amplifier.amplifier import Amplifier

__all__ = ['MultiClampChannel', 'MultiClamp']

NO_ERROR = 6000

primary_signal_VC_index = {'I' : 0,
                           'V' : 1,
                           'Ve' : 2, # pipette potential
                           '100V' : 3, # Not sure what this is
                           'Vext' : 4,
                           'Aux1' : 5,
                           'Aux2': 6}

primary_signal_IC_index = {'V' : 7,
                           'I' : 8,
                           'Ic' : 9, # command current
                           '100V' : 10,
                           'Iext' : 11,
                           'Aux1' : 12,
                           'Aux2' : 13}

primary_signal_index = {'V' : primary_signal_VC_index,
                        'I' : primary_signal_IC_index}

secondary_signal_VC_index = {'I' : 0,
                             'V' : 1,
                             'Ve' : 2,
                             '100V' : 3, # Not sure what this is
                             'Vext' : 4,
                             'Aux1' : 5,
                             'Aux2': 6}

secondary_signal_IC_index = {'V' : 7,
                             'I' : 8,
                             'Ic' : 9, # command current
                             'Ve' : 10,
                             '100V' : 11,
                             'Iext' : 12,
                             'Aux1' : 13,
                             'Aux2' : 14}

secondary_signal_index = {'V' : secondary_signal_VC_index,
                          'I': secondary_signal_IC_index}

def needs_select(func):
    """
    Decorator for all methods of `MultiClamp` that need to select the device
    first (only calls `Multiclamp.select_amplifier` if the respective device is
    not already the selected device).
    """
    @functools.wraps(func)
    def wrapper(self, *args, **kwds):
        if not MultiClampChannel.selected_device == self:
            self.select_amplifier()
        return func(self, *args, **kwds)
    return wrapper


def _identify_amplifier(model, serial, port, device, channel):
    """
    Return a dictionary with the identifying information for a MultiClamp
    device, based on the values filled in by ``MCCMSG_FindFirstMultiClamp``/
    ``MCCMSG_FindNextMultiClamp``. For a 700A device, returns the port, the
    device number and the channel; for a 700B device, returns the serial number
    and the channel. In all cases, the dictionary contains the `model` key with
    `700A` or `700B` as a value.
    """
    if model.value == 0:  # 700A
        logging.info(('Found a MultiClamp 700A (Port: {}  Device: {}  '
                      'Channel: {})').format(port.value, device.value,
                                             channel.value))
        return {'model': '700A', 'port': port.value, 'device': device.value,
                'channel': channel.value}
    elif model.value == 1:  # 700B
        logging.info(('Found a MultiClamp 700B (Serial number: {}  '
                      'Channel: {})').format(serial.value, channel.value))
        return {'model': '700B', 'serial': serial.value,
                'channel': channel.value}
    else:
        raise AssertionError('Unknown model')


class MultiClamp(object):
    """
    Device representing a MultiClamp amplifier with two channels or more.

    Parameters
    ----------
    channels
        List of MultiClamp channels. If none, a single 2-channel Multiclamp is assumed.
    """
    def __init__(self, *channels):
        self.channel = channels
        if len(channels) == 0: # assumes a 2-channel multiclamp
            for i in range(2):
                self.channel.append(MultiClampChannel(channel = i+1))

    def configure_board(self, theboard, primary = None, secondary = None, command = None):
        '''
        Configure an acquisition board.

        Parameters
        ----------
        primary
            A list of names of connections on the board for the primary signal, for each channel.
        secondary
            A list of names of connections on the board for the secondary signal, for each channel.
        command
            A list of names of connections on the board for the command signal, for each channel.
        '''
        self.board = theboard
        self.primary = primary
        self.secondary = secondary
        self.command = command

    def acquire(self, *inputs, **outputs):
        '''
        Send commands and acquire signals.

        Parameters
        ----------
        inputs
            A list of input variables to acquire. From: V1, I1, Ve1, V2, I2, etc (electrode potential)
        outputs
            A dictionary of commands. From: V1, I1, V2, I2...
        '''
        # Switch the mode
        # Sets the signals
        # Get the gains
        # Adjust the gains on the board
        pass

class MultiClampChannel(Amplifier):
    """
    Device representing a MultiClamp amplifier channel (i.e., one amplifier with
    two channels is represented by two devices).
    
    Parameters
    ----------
    kwds
        Enough information to uniquely identify the device. If there is a single
        device, no information is needed. If there is a single amplifier with
        two channels, only the channel number (e.g. ``channel=1``) is needed.
        If there are multiple amplifiers, they can be identified via their port/
        device number (700A) or using their serial number (700B).
    """
    # The path where ``AxMultiClampMsg.dll`` is located
    dll_path = r'C:\\Program Files\\Molecular Devices\\MultiClamp 700B Commander\\3rd Party Support\AxMultiClampMsg'
    # A list of all present devices
    all_devices = None
    # The currently selected device
    selected_device = None

    def __init__(self, **kwds):
        self.dll = ctypes.WinDLL(os.path.join(MultiClampChannel.dll_path,
                                              'AxMultiClampMsg.dll'))
        self.last_error = ctypes.c_int(NO_ERROR)
        self.error_msg = ctypes.create_string_buffer(256)
        self.msg_handler = self.dll.MCCMSG_CreateObject(ctypes.byref(self.last_error))
        self.check_error(fail=True)
        if MultiClampChannel.all_devices is None:
            MultiClampChannel.all_devices = self.find_amplifiers()
        self.identification = kwds
        self.select_amplifier()

        # Sets the gains: depends on the headstage (feedback resistor)
        volt = 1.
        mV = 1e-3
        nA = 1e-9
        self.gain = {'V': 10*mV/mV,
                      'I': 0.5*volt/nA,
                      'Ic': 2.5*volt/nA,  # command current
                      'Ve': 1*mV/mV,
                      'Vext' : 50*mV/mV,
                      '100V': 500*mV/mV,
                      'Iext': 2.5*volt/nA,
                      'Aux1': None,
                      'Aux2': None}

        # Sets the gains on the amplifier (maybe to be done for each mode)
        self.set_primary_signal_gain(1.)
        self.set_secondary_signal_gain(1.)

    def configure_board(self, theboard, primary = None, secondary = None, command = None):
        '''
        Configure an acquisition board.

        Parameters
        ----------
        primary
            A connection name on the board for the primary signal.
        secondary
            A connection name on the board for the secondary signal.
        command
            A connection name on the board for the command signal.
        '''
        self.board = theboard
        self.primary = primary
        self.secondary = secondary
        self.command = command

    def acquire(self, *inputs, **outputs):
        '''
        Send commands and acquire signals.

        Parameters
        ----------
        inputs
            A list of input variables to acquire. From: V, I, Ve (electrode potential)
            A maximum of two inputs.
        outputs
            A dictionary of commands. From: V, I.
            Only one command!
        '''
        # A few checks
        if len(inputs)>2:
            raise IndexError("Not more than two signals can be measured.")
        if len(outputs)!=1:
            raise IndexError('Only one command signal can be passed.')

        # Switch the mode and set the gain of the command
        outputname = outputs.keys()[0]
        if outputname == 'I':
            self.current_clamp()
        elif outputname == 'V':
            self.voltage_clamp()
        else:
            raise IndexError("Output command must be I or V.")

        # Set the gains on the amplifier
        self.set_primary_signal_gain(1.)
        self.set_secondary_signal_gain(1.)

        # Set the signals and gains
        # TODO: possibly switch primary and secondary depending on the signal name
        self.set_primary_signal(primary_signal_index[outputname][inputs[0]])
        self.board.gain[self.primary] = self.gain[inputs[0]]
        if len(inputs) == 2:
            self.set_secondary_signal(secondary_signal_index[outputname][inputs[1]])
            self.board.gain[self.secondary] = self.gain[inputs[1]]

        # Set the output gain on the board
        if outputname == 'I':
            self.board.gain[self.command] = self.gain['Ic']
        elif outputname == 'V':
            self.board.gain[self.command] = self.gain['Vext']

        board_inputs = ['primary', 'secondary'][:len(inputs)] # could be just secondary too
        return self.board.acquire(*board_inputs, command = outputs[outputname])

    def check_error(self, fail=False):
        """
        Check the error code of the last command.

        Parameters
        ----------
        fail : bool
            If ``False`` (the default), any error will give rise to a warning;
            if ``True``, any error will give rise to an `IOError`.
        """
        if self.last_error.value != NO_ERROR:
            # Get the error text
            self.dll.MCCMSG_BuildErrorText(self.msg_handler,
                                           self.last_error,
                                           self.error_msg,
                                           ctypes.c_uint(256))
            full_error = ('An error occurred while communicating with the '
                          'MultiClamp amplifier: {}'.format(self.error_msg.value))
            if fail:
                raise IOError(full_error)
            else:
                logging.warn(full_error)
                for line in traceback.extract_stack():
                    print(line) # so that we know what happened
            # Reset the error code
            self.last_error.value = NO_ERROR

    def find_amplifiers(self):
        """
        Return a list of all amplifier devices (each described by a dictionary,
        see `_identifiy_amplifier`).
        
        Returns
        -------
        amplifiers : list of dict
            A list of all detected amplifier devices.
        """
        model = ctypes.c_uint()
        port = ctypes.c_uint()
        device = ctypes.c_uint()
        channel = ctypes.c_uint()
        serial = ctypes.create_string_buffer(16)
        devices = []
        if self.dll.MCCMSG_FindFirstMultiClamp(self.msg_handler,
                                               ctypes.byref(model),
                                               serial,
                                               ctypes.c_uint(16),  # buffer size
                                               ctypes.byref(port),
                                               ctypes.byref(device),
                                               ctypes.byref(channel),
                                               ctypes.byref(self.last_error)):
            devices.append(_identify_amplifier(model, serial, port, device,
                                               channel))
        else:
            self.check_error()
        while self.dll.MCCMSG_FindNextMultiClamp(self.msg_handler,
                                                 ctypes.byref(model),
                                                 serial,
                                                 ctypes.c_uint(16),  # buffer size
                                                 ctypes.byref(port),
                                                 ctypes.byref(device),
                                                 ctypes.byref(channel),
                                                 ctypes.byref(self.last_error)):
            devices.append(_identify_amplifier(model, serial, port, device,
                                               channel))
        return devices

    def select_amplifier(self):
        """
        Select the current amplifier (will be called automatically when
        executing command such as `MultiClamp.voltage_clamp`.
        """
        multiclamps = []
        for multiclamp in MultiClampChannel.all_devices:
            if all(multiclamp.get(key, None) == value
                   for key, value in self.identification.items()):
                multiclamps.append(multiclamp)
        if len(multiclamps) == 0:
            raise RuntimeError('No device identified via {} found. Multiclamp commander not running?'.format(self.identification))
        elif len(multiclamps) > 1:
            raise RuntimeError('{} devices identified via {} found'.format(len(multiclamps),
                                                                           self.identification))
        multiclamp = multiclamps[0]
        if multiclamp['model'] == '700A':
            model = ctypes.c_uint(0)
            serial = None
            port = ctypes.c_uint(multiclamp['port'])
            device = ctypes.c_uint(multiclamp['device'])
            channel = ctypes.c_uint(multiclamp['channel'])
        elif multiclamp['model'] == '700B':
            model = ctypes.c_uint(1)
            serial = multiclamp['serial']
            port = None
            device = None
            channel = ctypes.c_uint(multiclamp['channel'])

        if not self.dll.MCCMSG_SelectMultiClamp(self.msg_handler,
                                                model,
                                                serial,
                                                port,
                                                device,
                                                channel,
                                                ctypes.byref(self.last_error)):
            self.check_error(fail=True)
        MultiClampChannel.selected_device = self

    def start_patch(self, pulse_amplitude=1e-2, pulse_frequency=1e-2): # Not clear what the units are for frequency
        '''
        Initialize the patch clamp procedure (in bath)
        '''
        # Set in voltage clamp
        self.voltage_clamp()

        # Disable resistance metering (because of pulses)
        self.switch_resistance_meter(False)

        # Disable pulses
        self.switch_pulses(False)

        # Compensate pipette
        self.auto_slow_compensation()
        self.auto_fast_compensation()

        # Set pulse frequency and amplitude
        self.set_pulses_amplitude(pulse_amplitude)
        self.set_pulses_frequency(pulse_frequency)

        # Set zap duration
        self.set_zap_duration(1)  # ms

        # Automatic offset
        self.auto_pipette_offset()

        # Set holding potential
        self.switch_holding(True)
        self.set_holding(0.)


    def resistance(self):
        '''
        Returns resistance
        '''
        raise RuntimeError('Resistance not implemented for MultiClamp -- Use DAQ resistance instead.')

    def stop_patch(self):
        '''
        Stops patch clamp procedure
        '''
        # Disable resistance metering
        self.switch_resistance_meter(False)
        # Disable holding
        self.switch_holding(False)
        # Disable pulses
        self.switch_pulses(False)

    # **** Signal settings ****

    @needs_select
    def set_primary_signal(self, signal):
        if not self.dll.MCCMSG_SetPrimarySignal(self.msg_handler,
                                                ctypes.c_uint(signal),
                                                ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_primary_signal(self):
        res = ctypes.c_uint(0)
        if not self.dll.MCCMSG_GetPrimarySignal(self.msg_handler,
                                                ctypes.byref(res),
                                                ctypes.byref(self.last_error)):
            self.check_error()
        return res.value

    @needs_select
    def set_primary_signal_gain(self, gain):
        if not self.dll.MCCMSG_SetPrimarySignalGain(self.msg_handler,
                                                    ctypes.c_double(gain),
                                                    ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_primary_signal_gain(self):
        gain = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetPrimarySignalGain(self.msg_handler,
                                                    ctypes.byref(gain),
                                                    ctypes.byref(self.last_error)):
            self.check_error()
        return gain.value

    @needs_select
    def set_primary_signal_lpf(self, lpf):
        if not self.dll.MCCMSG_SetPrimarySignalLPF(self.msg_handler,
                                                   ctypes.c_double(lpf),
                                                   ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def set_primary_signal_hpf(self, hpf):
        if not self.dll.MCCMSG_SetPrimarySignalHPF(self.msg_handler,
                                                   ctypes.c_double(hpf),
                                                   ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def set_secondary_signal(self, signal):
        if not self.dll.MCCMSG_SetSecondarySignal(self.msg_handler,
                                                  ctypes.c_uint(signal),
                                                  ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_secondary_signal(self, signal):
        res = ctypes.c_uint(signal)
        if not self.dll.MCCMSG_GetSecondarySignal(self.msg_handler,
                                                  ctypes.byref(res),
                                                  ctypes.byref(self.last_error)):
            self.check_error()
        return res.value

    @needs_select
    def set_secondary_signal_lpf(self, lpf):
        if not self.dll.MCCMSG_SetSecondarySignalLPF(self.msg_handler,
                                                     ctypes.c_double(lpf),
                                                     ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def set_secondary_signal_gain(self, gain):
        if not self.dll.MCCMSG_SetSecondarySignalGain(self.msg_handler,
                                                      ctypes.c_double(gain),
                                                      ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_secondary_signal_gain(self):
        gain = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetSecondarySignalGain(self.msg_handler,
                                                    ctypes.byref(gain),
                                                    ctypes.byref(self.last_error)):
            self.check_error()
        return gain.value

    # **** Recording modes ****

    @needs_select
    def voltage_clamp(self):
        # MCCMSG_MODE_VCLAMP = 0
        # logging.info('Switching to voltage clamp in multiclamp.py')
        if not self.dll.MCCMSG_SetMode(self.msg_handler, ctypes.c_uint(0),
                                       ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def current_clamp(self):
        # MCCMSG_MODE_ICLAMP = 1
        if not self.dll.MCCMSG_SetMode(self.msg_handler, ctypes.c_uint(1),
                                       ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select # I=0
    def null_current(self):
        if not self.dll.MCCMSG_SetMode(self.msg_handler, ctypes.c_uint(2),
                                       ctypes.byref(self.last_error)):
            self.check_error()

    # **** Voltage clamp ****
    @needs_select
    def switch_holding(self, enable): # True if voltage is clamped
        if not self.dll.MCCMSG_SetHoldingEnable(self.msg_handler,
                                                ctypes.c_bool(enable),
                                                ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def set_holding(self, value): # Voltage-clamp or current-clamp holding  value
        if not self.dll.MCCMSG_SetHolding(self.msg_handler,
                                          ctypes.c_double(value),
                                          ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_holding(self):
        holding = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetHolding(self.msg_handler,
                                          ctypes.byref(holding),
                                          ctypes.byref(self.last_error)):
            self.check_error()
        return holding.value

    # **** Compensation ****

    @needs_select
    def get_fast_compensation_capacitance(self):
        capacitance = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetFastCompCap(self.msg_handler,
                                              ctypes.byref(capacitance),
                                              ctypes.byref(self.last_error)):
            self.check_error()
        return capacitance

    @needs_select
    def set_fast_compensation_capacitance(self, capacitance):
        if not self.dll.MCCMSG_SetFastCompCap(self.msg_handler,
                                              ctypes.c_double(capacitance),
                                              ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def auto_fast_compensation(self):
        if not self.dll.MCCMSG_AutoFastComp(self.msg_handler,
                                            ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_slow_compensation_capacitance(self):
        capacitance = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetSlowCompCap(self.msg_handler,
                                              ctypes.byref(capacitance),
                                              ctypes.byref(self.last_error)):
            self.check_error()
        return capacitance

    @needs_select
    def set_slow_compensation_capacitance(self, capacitance):
        if not self.dll.MCCMSG_SetSlowCompCap(self.msg_handler,
                                              ctypes.c_double(capacitance),
                                              ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def auto_slow_compensation(self):
        if not self.dll.MCCMSG_AutoSlowComp(self.msg_handler,
                                            ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def auto_pipette_offset(self):
        if not self.dll.MCCMSG_AutoPipetteOffset(self.msg_handler,
                                                 ctypes.byref(self.last_error)):
            self.check_error()
    @needs_select
    def set_neutralization_enable(self, state):
        if not self.dll.MCCMSG_SetNeutralizationEnable(self.msg_handler,
                                                      ctypes.c_bool(state),
                                                      ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def set_neutralization_capacitance(self, capacitance):
        if not self.dll.MCCMSG_SetNeutralizationCap(self.msg_handler,
                                                    ctypes.c_double(capacitance),
                                                    ctypes.byref(self.last_error)):
            self.check_error()


    def set_bridge_balance(self, state):
        if not self.dll.MCCMSG_SetBridgeBalEnable(self.msg_handler, ctypes.c_bool(state),
                                                 ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_bridge_resistance(self):
        resistance = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetBridgeBalResist(self.msg_handler,
                                                 ctypes.byref(resistance),
                                                 ctypes.byref(self.last_error)):
            self.check_error()
        return resistance.value

    @needs_select
    def auto_bridge_balance(self):
        if not self.dll.MCCMSG_AutoBridgeBal(self.msg_handler,
                                                 ctypes.byref(self.last_error)):
            self.check_error()
        return self.get_bridge_resistance()

    # **** Zap ****
    @needs_select
    def zap(self):
        if not self.dll.MCCMSG_Zap(self.msg_handler,
                                   ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def set_zap_duration(self, duration):
        if not self.dll.MCCMSG_SetZapDuration(self.msg_handler,
                                              ctypes.c_double(duration),
                                              ctypes.byref(self.last_error)):
            self.check_error()

    # **** Measuring V and R ****
    @needs_select
    def get_meter_value(self):
        value = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetMeterValue(self.msg_handler,
                                             ctypes.byref(value),
                                             ctypes.c_uint(2), # "uMeterID" --> channel id?
                                             ctypes.byref(self.last_error)):
            self.check_error()
        return value.value

    @needs_select
    def switch_resistance_meter(self, enable):
        if not self.dll.MCCMSG_SetMeterResistEnable(self.msg_handler,
                                                    ctypes.c_bool(enable),
                                                    ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def resistance_meter_state(self): # On/off state
        enable = ctypes.c_bool(False)
        if not self.dll.MCCMSG_GetMeterResistEnable(self.msg_handler,
                                                    ctypes.byref(enable),
                                                    ctypes.byref(self.last_error)):
            self.check_error()
        return enable.value

    # **** Repeated pulses ****
    @needs_select
    def switch_pulses(self, enable):
        if not self.dll.MCCMSG_SetTestSignalEnable(self.msg_handler,
                                                   ctypes.c_bool(enable),
                                                   ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def set_pulses_amplitude(self, amplitude):
        if not self.dll.MCCMSG_SetTestSignalAmplitude(self.msg_handler,
                                                      ctypes.c_double(amplitude),
                                                      ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_pulses_amplitude(self):
        amplitude = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetTestSignalAmplitude(self.msg_handler,
                                                      ctypes.byref(amplitude),
                                                      ctypes.byref(self.last_error)):
            self.check_error()
        return amplitude.value

    @needs_select
    def set_pulses_frequency(self, frequency):
        if not self.dll.MCCMSG_SetTestSignalFrequency(self.msg_handler,
                                                      ctypes.c_double(frequency),
                                                      ctypes.byref(self.last_error)):
            self.check_error()

    @needs_select
    def get_pulses_frequency(self):
        frequency = ctypes.c_double(0.)
        if not self.dll.MCCMSG_GetTestSignalFrequency(self.msg_handler,
                                                      ctypes.byref(frequency),
                                                      ctypes.byref(self.last_error)):
            self.check_error()
        return frequency.value

    def close(self):
        self.dll.MCCMSG_DestroyObject(self.msg_handler)
        self.msg_handler = None



'''
//==============================================================================================
// Function parameters
//==============================================================================================

// Parameters for MCCMSG_FindFirstMultiClamp(), MCCMSG_FindNextMultiClamp() and MCCMSG_SelectMultiClamp()
// uModel filled in / or puModel filled out as:
const int MCCMSG_HW_TYPE_MC700A                         = 0;
const int MCCMSG_HW_TYPE_MC700B                         = 1;

// Parameters for MCCMSG_SetMode() and MCCMSG_GetMode()
// uModeID filled in / or puModeID filled out as:
const UINT MCCMSG_MODE_VCLAMP                           = 0;
const UINT MCCMSG_MODE_ICLAMP                           = 1;
const UINT MCCMSG_MODE_ICLAMPZERO                       = 2;

// Parameters for MCCMSG_QuickSelectButton()
// uButtonID filled in as:
const UINT MCCMSG_QSB_1                                 = 0;
const UINT MCCMSG_QSB_2                                 = 1;
const UINT MCCMSG_QSB_3                                 = 2;

// Parameters for MCCMSG_SetPrimarySignal(), MCCMSG_SetPrimarySignal()
// uSignalID filled in / or puSignalID filled out as:
const UINT MCCMSG_PRI_SIGNAL_VC_MEMBCURRENT             = 0;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_MEMBPOTENTIAL           = 1;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_PIPPOTENTIAL            = 2;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_100XACMEMBPOTENTIAL     = 3;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_EXTCMDPOTENTIAL         = 4;  // 700B only
const UINT MCCMSG_PRI_SIGNAL_VC_AUXILIARY1              = 5;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_VC_AUXILIARY2              = 6;  // 700B only

const UINT MCCMSG_PRI_SIGNAL_IC_MEMBPOTENTIAL           = 7;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_MEMBCURRENT             = 8;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_CMDCURRENT              = 9;  // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_100XACMEMBPOTENTIAL     = 10; // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_EXTCMDCURRENT           = 11; // 700B only
const UINT MCCMSG_PRI_SIGNAL_IC_AUXILIARY1              = 12; // 700B and 700A
const UINT MCCMSG_PRI_SIGNAL_IC_AUXILIARY2              = 13; // 700B only

// Parameters for MCCMSG_SetSecondarySignal(), MCCMSG_SetSecondarySignal()
// uSignalID filled in / or puSignalID filled out as:
const UINT MCCMSG_SEC_SIGNAL_VC_MEMBCURRENT             = 0;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_MEMBPOTENTIAL           = 1;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_PIPPOTENTIAL            = 2;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_100XACMEMBPOTENTIAL     = 3;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_EXTCMDPOTENTIAL         = 4;  // 700B only
const UINT MCCMSG_SEC_SIGNAL_VC_AUXILIARY1              = 5;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_VC_AUXILIARY2              = 6;  // 700B only

const UINT MCCMSG_SEC_SIGNAL_IC_MEMBPOTENTIAL           = 7;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_MEMBCURRENT             = 8;  // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_CMDCURRENT              = 9;  //          700A only
const UINT MCCMSG_SEC_SIGNAL_IC_PIPPOTENTIAL            = 10; // 700B only
const UINT MCCMSG_SEC_SIGNAL_IC_100XACMEMBPOTENTIAL     = 11; // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_EXTCMDCURRENT           = 12; // 700B only
const UINT MCCMSG_SEC_SIGNAL_IC_AUXILIARY1              = 13; // 700B and 700A
const UINT MCCMSG_SEC_SIGNAL_IC_AUXILIARY2              = 14; // 700B only

// Parameters for MCCMSG_GetMeterValue()
const UINT MCCMSG_METER1                                = 0;  // 700B
const UINT MCCMSG_METER2                                = 1;  // 700B
const UINT MCCMSG_METER3                                = 2;  // 700B
const UINT MCCMSG_METER4                                = 3;  // 700B
'''


================================================
File: /holypipette/devices/__init__.py
================================================
from __future__ import absolute_import
from .pressurecontroller import *
from .amplifier import *
from .manipulator import *
from .camera import *


================================================
File: /holypipette/devices/cellsorter/__init__.py
================================================
from __future__ import absolute_import
from .CellSorter import CellSorterController, CellSorterManip, FakeCellSorterController, FakeCellSorterManip
from .CalibratedCellSorter import CalibratedCellSorter


================================================
File: /holypipette/devices/cellsorter/CellSorter.py
================================================
import serial
import time

import threading
from threading import Thread

from holypipette.devices.manipulator.manipulator import Manipulator
try:
    from .CellSorterSerial import SerialCommands
except:
    print('NDA\'d CellSorter Serial Commands not available')

__all__ = ['CellSorterController']

class FakeCellSorterController():
    '''A fake cell sorter controller for testing purposes
    '''
    def __init__(self):
        #fake cell sorter state variables
        self.led = False
        self.led_ring = 1
        self.valve1 = False
        self.valve2 = False

    def is_online(self):
        '''Sends a test command to the CellSorter and returns True if the response is correct
        '''
        return True

    def set_led(self, status: bool):
        '''Sets the LED status
        '''
        print('CELLSORTER: set led {}'.format(status))
        self.led = status

    def get_led(self):
        '''Returns the LED status
        '''
        return self.led
    
    def set_led_ring(self, ring: int):
        '''Sets the LED ring to use
        '''
        print('CELLSORTER: set led ring {}'.format(ring))
        self.led_ring = ring
    
    def set_valve(self, valve: int, open: bool):
        '''Sets the given valve to be open or closed
        '''
        print('CELLSORTER: set valve {} {}'.format(valve, open))
        if valve == 1:
            self.valve1 = open
        elif valve == 2:
            self.valve2 = open

    def get_valve(self, valve: int):
        '''Returns the status of the given valve
        '''
        print('get valve {}'.format(valve))
        if valve == 1:
            return self.valve1
        elif valve == 2:
            return self.valve2

    ###  these functions are not implemented in the fake cell sorter ###
    def open_valve_for_time(self, valve: int, timeMs: int):
        print('open valve {} for {} ms'.format(valve, timeMs))

    def open_valve_for_prev_time(self, valve: int):
        print('open valve {} for prev time'.format(valve))
    
    def set_valve_delay(self, delayMs: int):
        print('set valve delay to {}'.format(delayMs))
    
    def open_valve_1_2(self):
        print('open valve 1 2')
    
    def open_valve_2_1(self):
        print('open valve 2 1')

class CellSorterController():
    '''A class to control a physical cell sorter control box over serial.
       The control box allows for LED and valve control
    '''

    def __init__(self, comPort: serial.Serial):
        self.comPort : serial.Serial = comPort

        # turn on ring 1 of the LED
        self.set_led_ring(1)
        self.set_led(True)

    def _sendCmd(self, cmd):
        for a in cmd:
            self.comPort.write(a.encode()) #send test command
        self.comPort.flush()
        time.sleep(0.1) #TODO: replace with something better

        resp = self.comPort.read_all() #read reply to message
        resp = resp.decode()
        resp = resp[:-3] #remove trailing \r\n\x00 at the end of each reply
        return resp
    
    def is_online(self):
        '''Sends a test command to the CellSorter and returns True if the response is correct
        '''
        resp = self._sendCmd(SerialCommands.TEST)
        return resp == 'R'

    def set_led(self, status: bool):
        '''Sets the LED status
        '''
        if status:
            self._sendCmd(SerialCommands.LED_ON)
        else:
            self._sendCmd(SerialCommands.LED_OFF)

    def get_led(self):
        '''Returns the LED status
        '''
        resp = self._sendCmd(SerialCommands.LED_STATUS)
        return resp == '+'
    
    def set_led_ring(self, ring: int):
        '''Sets the LED ring to use
        '''
        if ring == 1:
            self._sendCmd(SerialCommands.LED_SELECT_RING_1)
        elif ring == 2:
            self._sendCmd(SerialCommands.LED_SELECT_RING_2)
        else:
            raise ValueError('Ring must be 1 or 2')
    
    def set_valve(self, valve: int, open: bool):
        '''Sets the given valve to be open or closed
        '''
        if valve == 1:
            if open:
                self._sendCmd(SerialCommands.VALVE_1_OPEN)
            else:
                self._sendCmd(SerialCommands.VALVE_1_CLOSE)
        elif valve == 2:
            if open:
                self._sendCmd(SerialCommands.VALVE_2_OPEN)
            else:
                self._sendCmd(SerialCommands.VALVE_2_CLOSE)
        else:
            raise ValueError('Valve must be 1 or 2')

    def get_valve(self, valve: int):
        '''Returns the status of the given valve
        '''
        if valve == 1:
            resp = self._sendCmd(SerialCommands.VALVE_1_STATUS)
        elif valve == 2:
            resp = self._sendCmd(SerialCommands.VALVE_2_STATUS)
        else:
            raise ValueError('Valve must be 1 or 2')
        
        return resp == '+'

    def open_valve_for_time(self, valve: int, timeMs: int):
        '''Open a valve for the given time in milliseconds
        '''
        if valve == 1:
            self._sendCmd(SerialCommands.VALVE_1_OPEN_TIME.format(timeMs))
            self._sendCmd(SerialCommands.VALVE_1_OPEN_PREV_TIME)
        elif valve == 2:
            self._sendCmd(SerialCommands.VALVE_2_OPEN_TIME.format(timeMs))
            self._sendCmd(SerialCommands.VALVE_2_OPEN_PREV_TIME)
        else:
            raise ValueError('Valve must be 1 or 2')

    def open_valve_for_prev_time(self, valve: int):
        '''Open a valve for the last time specified
        '''
        if valve == 1:
            self._sendCmd(SerialCommands.VALVE_1_OPEN_PREV_TIME)
        elif valve == 2:
            self._sendCmd(SerialCommands.VALVE_2_OPEN_PREV_TIME)
        else:
            raise ValueError('Valve must be 1 or 2')
    
    def set_valve_delay(self, delayMs: int):
        '''Set the delay between valve openings
        '''
        self._sendCmd(SerialCommands.VALVE_DELAY.format(delayMs))
    
    def open_valve_1_2(self):
        '''Open valve 1, wait the specified delay, then open valve 2
        '''
        self._sendCmd(SerialCommands.VALVE_1_2_OPEN)
    
    def open_valve_2_1(self):
        '''Open valve 2, wait the specified delay, then open valve 1
        '''
        self._sendCmd(SerialCommands.VALVE_2_1_OPEN)

    def __del__(self):
        '''Close the serial connection when the object is destroyed
        '''
        self.comPort.close()


class CellSorterManip(Manipulator):
    '''A class to control a physical cell sorter manipulator over serial.
       The manipulator allows for z-axis commands and position feedback
    '''

    def __init__(self, comPort: serial.Serial):
        self.comPort : serial.Serial = comPort

        self.serialLock = threading.Lock()
        self.maxVel = 25
        self.maxAcc = 2

        #set init commands
        self._sendCmd(SerialCommands.SET_PITCH)
        self._sendCmd(SerialCommands.SET_CUR)
        self._sendCmd(SerialCommands.SET_REDUCTION)
        self._sendCmd(SerialCommands.SET_CUR_DELAY)
        self._sendCmd(SerialCommands.SET_SEC_VEL)

        self.zPos = 0
        #spawn z position update thread
        self.posUpdateThread = Thread(target=self._update_position_continuous, daemon=True)
        self.posUpdateThread.start()


    def _sendCmd(self, cmd):
        self.serialLock.acquire()
        self.comPort.write(cmd.encode()) #send test command
        self.comPort.flush()
        time.sleep(0.1) #TODO: replace with something better

        resp = self.comPort.read_all() #read reply to message
        resp = resp.decode()
        self.serialLock.release()
        resp = resp[:-3] #remove trailing \r\n\x00 at the end of each reply
        return resp
    
    def is_online(self):
        '''Sends a test command to the CellSorter and returns True if the response is correct
        '''
        resp = self._sendCmd(SerialCommands.GET_VERSION)
        return resp[:4] == 'Vers' # good responses start with Vers
    
    def relative_move(self, pos: float, velocity=None):
        '''Sets the position relative to the current position
        '''

        if velocity == None:
            velocity = self.maxVel

        self._sendCmd(SerialCommands.SET_VEL.format(velocity, velocity, velocity))
        self._sendCmd(SerialCommands.SET_ACCEL.format(self.maxAcc))
        self._sendCmd(SerialCommands.SET_POS_REL.format(pos))
        self._sendCmd(SerialCommands.JOY_2)
    
    def absolute_move(self, pos: float, velocity=None):
        '''Sets the absolute position
        '''
        if velocity == None:
            velocity = self.maxVel

        self._sendCmd(SerialCommands.SET_VEL.format(velocity, velocity, velocity))
        self._sendCmd(SerialCommands.SET_ACCEL.format(self.maxAcc))
        self._sendCmd(SerialCommands.SET_POS_ABS.format(pos))

    def stop(self, axis=None):
        '''Stops all movement immediately
        '''
        self._sendCmd(SerialCommands.EMERGENCY_STOP)

    def _update_position_continuous(self):
        while True:
            resp = self._sendCmd(SerialCommands.GET_POS)
            resp = resp.split(' ')
            self.zPos = float(resp[2])
            time.sleep(0.2)

    def wait_until_still(self, axes = None):
        """
        Waits until motors have stopped.

        Parameters
        ----------
        axes : list of axis numbers
        """
        previous_position = self.zPos
        new_position = None
        while new_position is None or previous_position != new_position:
            previous_position = new_position
            time.sleep(0.3)
            new_position = self.zPos

    def position(self):
        '''Returns the current position of the z-axis
        '''
        return self.zPos
        
    def set_max_speed(self, vel: float):
        '''Sets the velocity of the z-axis (velocity as a % from 0.1 to 100)
        '''
        if vel < 0.1 or vel > 100:
            raise ValueError('Velocity must be between 0.1 and 100')
        
        nativeVel = vel / 2

        self.maxVel = nativeVel
        self._sendCmd(SerialCommands.SET_VEL.format(self.maxVel, self.maxVel, self.maxVel))
    
    def set_max_accel(self, accel: float):
        '''Sets the acceleration of the z-axis from 1% to 100%
        '''
        if accel < 1 or accel > 100:
            raise ValueError('Acceleration must be between 1 and 100')

        nativeAccel = accel / 50
        self.maxAcc = nativeAccel
        self._sendCmd(SerialCommands.SET_ACCEL.format(self.maxAcc))

    def read_SW(self):
        '''Returns the current state of the switches
        '''
        resp = self._sendCmd(SerialCommands.READ_SW)
        return resp

    def __del__(self):
        '''Close the serial connection when the object is destroyed
        '''
        self.comPort.close()


class FakeCellSorterManip(Manipulator):
    ''' A fake cell sorter manipulator for testing purposes
    '''
    def __init__(self, z_pos: float = 0):
        self.z_pos = z_pos

    def is_online(self):
        return True
    
    def set_max_accel(self, accel: float):
        pass

    def set_max_speed(self, vel: float):
        pass

    def absolute_move(self, pos: float, velocity=None):
        self.z_pos = pos

    def relative_move(self, pos: float, velocity=None):
        self.z_pos += pos
    
    def position(self):
        return self.z_pos
    
    def stop(self):
        pass

    def wait_until_still(self, axes = None):
        """
        Waits until motors have stopped.

        Parameters
        ----------
        axes : list of axis numbers
        """
        return True



if __name__ == '__main__':

    testController = False

    if testController:

        # Create a serial connection to the CellSorter
        # As per documentation: 115200 baud, 8 data bits, no parity, 1 stop bit
        controllerSerial = serial.Serial('COM7', 115200, timeout=2, parity=serial.PARITY_NONE, stopbits=1, 
                                            bytesize=8, write_timeout=1, inter_byte_timeout=2)
        # controllerSerial.dtr = False
        # controllerSerial.rts = False

        cellSorterController = CellSorterController(controllerSerial)

        # Check that the CellSorter is online
        if not cellSorterController.is_online():
            print('CellSorter not online')
            exit(1)
        
        # Set the LED ring to use
        cellSorterController.set_led_ring(1)

        # Flicker the LED on and off 5 times
        for i in range(5):
            cellSorterController.set_led(True)
            time.sleep(0.5)
            cellSorterController.set_led(False)
            time.sleep(0.5)

        #close serial
        del cellSorterController
    
    else:
        manipulatorSerial = serial.Serial('COM14', 57600, timeout=2, parity=serial.PARITY_NONE, stopbits=2, 
                                            bytesize=8, write_timeout=1, inter_byte_timeout=2)
        # manipulatorSerial.dtr = True
        # manipulatorSerial.rts = False

        cellSorterManip = CellSorterManip(manipulatorSerial)

        # Check that the CellSorter is online
        if not cellSorterManip.is_online():
            print('CellSorter not online')
            exit(1)
        
        for i in range(3):
            # move down
            for i in range(3):
                cellSorterManip.set_pos_rel(-1)
                time.sleep(0.5)
            
            #move up
            for i in range(3):
                cellSorterManip.set_pos_rel(1)
                time.sleep(0.5)

        #close serial
        del cellSorterManip



================================================
File: /holypipette/devices/cellsorter/CalibratedCellSorter.py
================================================
import cv2
import numpy as np
import time

from holypipette.devices.camera.camera import Camera
from holypipette.devices.cellsorter import CellSorterManip
from holypipette.devices.cellsorter import CellSorterController
from holypipette.controller import TaskController

__all__ = ['CalibratedCellSorter']

class CalibratedCellSorter(TaskController):
    def __init__(self, cellsorterManip: CellSorterManip, cellSorterController: CellSorterController, stage, microscope, camera: Camera):
        self.cellsorterManip = cellsorterManip
        self.cellsorterController = cellSorterController
        self.stage = stage
        self.camera = camera
        self.microscope = microscope
        self.calibrated = False
        self.pipetteOffsetPix = None
        self.coverslipZPos = None
        self.slowMoveRegion = 0.5 #mm
        self.slowMoveSpeed = 0.2
        self.fastMoveSpeed = 5

    def pulse_suction(self, duration):
        self.cellsorterController.open_valve_for_time(1, duration)

    def pulse_pressure(self, duration):
        self.cellsorterController.open_valve_for_time(2, duration)
    
    def position(self):
        return self.cellsorterManip.position()
    
    def absolute_move(self, position, velocity=None):
        print('velocity', velocity)
        self.cellsorterManip.absolute_move(position, velocity=velocity)
    
    def relative_move(self, position, velocity=None):
        self.cellsorterManip.relative_move(position, velocity=velocity)

    def set_led_status(self, status, ring=None):
        self.cellsorterController.set_led(status)
        if ring != None:
            self.cellsorterController.set_led_ring(ring)

    def get_led_status(self):
        return self.cellsorterController.get_led()


    def calibrate(self):
        #make sure stage is calibrated
        if not self.stage.calibrated:
            raise Exception("Stage is not calibrated")
        
        #grab latest image
        img, _ = self.camera.snap()

        #convert to grayscale if needed
        if len(img.shape) > 2:
            img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        #find the center of the tube via hough transform
        img = cv2.medianBlur(img, 19)
        #add channel dimension to make it 3D
        img = img[:, :, np.newaxis]
        circles = cv2.HoughCircles(img, cv2.HOUGH_GRADIENT, 1, 20,
                                      param1=50, param2=30, minRadius=100, maxRadius=300)
        
        if circles is None or len(circles) == 0:
            raise Exception("No circles found in image")
        
        if len(circles) > 1:
            raise Exception("Multiple circles found in image")
        
        #get the center of the pipette
        x, y, r = circles[0][0]
        self.camera.show_point([int(x), int(y)], radius=int(r), color=(0, 0, 255), show_center=True)

        self.pipetteOffsetPix = np.array([x, y])
        self.coverslipZPos = self.position()

        print("Pipette offset: ", self.pipetteOffsetPix)
        print("Coverslip Z position: ", self.coverslipZPos)

        #draw a circle on the image
        self.calibrated = True

    def raise_pipette(self):
        self.cellsorterManip.set_max_speed(self.fastMoveSpeed)
        self.absolute_move(self.position() + 5)
        self.cellsorterManip.wait_until_still()
    
    def center_cellsorter_on_point(self, point): #x,y in pixels, z in stage units
        x, y, z = point
        if not self.stage.calibrated:
            raise Exception("Stage is not calibrated")
        if not self.calibrated or self.pipetteOffsetPix is None or self.coverslipZPos is None:
            raise Exception("Cell Sorter is not calibrated")
        if self.microscope.floor_Z is None:
            raise Exception("Cell Plane not set")

        self.raise_pipette()     

        #move the stage such that it's centered in x, y, put cells in focus
        self.microscope.absolute_move(self.microscope.floor_Z)
        self.stage.reference_move(np.array([x + self.pipetteOffsetPix[0], y + self.pipetteOffsetPix[1]]))
        self.stage.wait_until_reached(np.array([x + self.pipetteOffsetPix[0], y + self.pipetteOffsetPix[1]]))
        time.sleep(0.5)

        print("moving cellsorter to cell plane")
        #move the cellsorter to the cell plane
        currentPos = self.position()
        if abs(currentPos - self.coverslipZPos) < self.slowMoveRegion:
            #move slowly to setpoint
            self.absolute_move(self.coverslipZPos, self.slowMoveSpeed)
            self.cellsorterManip.wait_until_still()
        else:
            #move quickly to slowMoveRegion away from setpoint
            initSetpoint = self.coverslipZPos + np.sign(self.slowMoveRegion - self.coverslipZPos) * self.slowMoveRegion
            self.absolute_move(initSetpoint, self.fastMoveSpeed)
            self.cellsorterManip.wait_until_still()
            #move slowly to setpoint
            self.absolute_move(self.coverslipZPos, self.slowMoveSpeed)
            self.cellsorterManip.wait_until_still()

        self.absolute_move(self.coverslipZPos)



================================================
File: /holypipette/devices/camera/camera.py
================================================
'''
A generic camera class

TODO:
* A stack() method which takes a series of photos along Z axis
'''
from __future__ import print_function
import collections
import os
import datetime
import time
import threading
import imageio
import logging

import numpy as np
from PIL import Image, ImageDraw, ImageFont
from scipy.ndimage.filters import gaussian_filter
# from scipy.ndimage import fourier_gaussian
import warnings
import traceback
from scipy.optimize import brentq
try:
    import cv2
except:
    warnings.warn('OpenCV not available')

__all__ = ['Camera', 'FakeCamera', 'RecordedVideoCamera']


class FileWriteThread(threading.Thread): # saves frames individually
    def __init__(self, *args, **kwds):
        self.queue = kwds.pop('queue')
        self.debug_write_delay = kwds.pop('debug_write_delay', 0)
        self.directory = kwds.pop('directory')
        self.file_prefix = kwds.pop('file_prefix')
        self.skip_frames = kwds.pop('skip_frames', 0)
        threading.Thread.__init__(self, *args, **kwds)
        self.first_frame = None
        self.start_time = None
        self.last_report = None
        self.written_frames = 0
        self.running = True
        self.skipped = -1

    def write_frame(self):
        frame_number, creation_time, elapsed_time, frame = self.queue.popleft()
        if frame_number is None:
            # Marker for end of recording
            return False
        
        # Make all frame numbers relative to the first frame
        if self.first_frame is None:
            self.first_frame = frame_number
            self.start_time = time.time()
            self.last_report = self.start_time
        frame_number -= self.first_frame
        # If desired, skip frames
        self.skipped += 1
        if self.skipped >= self.skip_frames:
            self.skipped = -1
            fname = os.path.join(self.directory, '{}_{:05d}.tiff'.format(self.file_prefix, frame_number))
            with imageio.get_writer(fname, software='holypipette') as writer:
                writer.append_data(frame, meta={'datetime': creation_time,
                                                'description': 'Time since start of recording: {}'.format(repr(elapsed_time))})
            self.written_frames += 1
            time.sleep(self.debug_write_delay)
            if time.time() - self.last_report > 1:
                frame_rate = self.written_frames / (time.time() - self.last_report)
                print('Writing {:.1f} fps (total frames written: {})'.format(frame_rate, frame_number))
                self.last_report = time.time()
                self.written_frames = 0

        return True

    def run(self):
        self.running = True
        if not os.path.exists(self.directory):
            os.makedirs(self.directory)
        
        while self.running:
            try:
                if len(self.queue) > self.queue.maxlen // 2:
                    print('WARNING: FileWriteThread queue is getting full ({}/{})'.format(len(self.queue),
                                                                                          self.queue.maxlen))
                if not self.write_frame():
                    break
            except IndexError:
                # queue is emtpy, wait
                time.sleep(0.01)
                # TODO: Store image metadata to file as well?

        if len(self.queue):
            print('Still need to write {} images to disk.'.format(len(self.queue)))
            while len(self.queue):
                if not self.write_frame():
                    break


class AcquisitionThread(threading.Thread):
    def __init__(self, camera, queues, raw_queues):
        self.camera = camera
        self.queues = queues
        self.raw_queues = raw_queues
        self.running = True
        
        self.last_frame_time = None
        self.fps = 0

        threading.Thread.__init__(self, name='image_acquire_thread')

    def get_frame_rate(self):
        # * A way to calculate FPS
        current_time = time.time()
        if self.last_frame_time is not None:
            self.fps = 1.0 / (current_time - self.last_frame_time)
        self.last_frame_time = current_time

        return self.fps

    def run(self):
        self.running = True

        start_time = time.time()

        last_report = start_time
        acquired_frames = 0
        last_frame = 0
        while self.running:
            snap_time = time.time()
            try:
                raw, processed = self.camera.snap()
            except Exception as ex:
                print('something went wrong acquiring an image, waiting for 100ms: ')
                traceback.print_exception(type(ex), ex, ex.__traceback__)

                time.sleep(.1)
                continue
            # Put image into queues for disk storage and display
            for queue in self.queues:
                queue.append((last_frame, datetime.datetime.now(), snap_time - start_time, processed))
            for queue in self.raw_queues:
                queue.append((last_frame, datetime.datetime.now(), snap_time - start_time, raw))

            # logging.debug(f"FPS in Acquisition Thread: {self.get_frame_rate():.2f}")

            last_frame += 1
            acquired_frames += 1
            if snap_time - last_report > 1:
                # frame_rate = acquired_frames / (snap_time - last_report)
                # logging.warning('Acquiring {:.1f} fps'.format(frame_rate))
                last_report = snap_time
                acquired_frames = 0
        
        # Put the end marker into the queues
        for queue in self.queues:
            queue.append((None, None, None, None))


class Camera(object):
    """
    Base class for all camera devices. At the end of the initialization, derived classes need to
    call self.start_acquisition() to start the thread that continously acquires images from the
    camera.
    """
    def __init__(self):
        super(Camera, self).__init__()
        self._file_queue = None
        self._last_frame_queue = collections.deque(maxlen=1)
        self.raw_frame_queue = collections.deque(maxlen=1)
        self._acquisition_thread = None
        self._file_thread = None
        self._debug_write_delay = 0
        self.width = 1000
        self.height = 1000
        self.flipped = False # Horizontal flip
        self.auto_normalize = False

        self.stop_show_time = 0
        self.point_to_show = None
        self.cell_list = []
        
        self.last_frame_time = None
        self.fps = 0

    def show_point(self, point, color=(255, 0, 0), radius=10, duration=1.5, show_center=False):
        self.point_to_show = [point, radius, color, show_center]
        self.stop_show_time = time.time() + duration

    def start_acquisition(self):
        self._acquisition_thread = AcquisitionThread(camera=self,
                                                     queues=[self._last_frame_queue],
                                                     raw_queues=[self.raw_frame_queue])
        self._acquisition_thread.start()

    def stop_acquisition(self):
        self._acquisition_thread.running = False

    def start_recording(self, directory='', file_prefix='', skip_frames=0, queue_size=1000):
        if len(self._acquisition_thread.queues) > 1:
            del self._acquisition_thread.queues[1]
        self._file_queue = collections.deque(maxlen=queue_size)
        self._acquisition_thread.queues.append(self._file_queue)
        self._file_thread = FileWriteThread(queue=self._file_queue,
                                            directory=directory,
                                            file_prefix=file_prefix,
                                            skip_frames=skip_frames,
                                            debug_write_delay=self._debug_write_delay)
        self._file_thread.start()

    def stop_recording(self):
        if self._file_thread:
            self._file_thread.running = False

    def flip(self):
        self.flipped = not self.flipped

    def preprocess(self, input_img):
        # isGreyscale = len(input_img.shape) == 2
        # ? why? because our images are grayscale. the line below makes images ~3x larger
        # img = cv2.cvtColor(input_img.copy(), cv2.COLOR_GRAY2RGB) if isGreyscale else input_img.copy()
        img = input_img.copy()

        if self.point_to_show and time.time() - self.stop_show_time < 0:
            img = cv2.circle(img, self.point_to_show[0], self.point_to_show[1], self.point_to_show[2], 3)
            if self.point_to_show[3]:
                img = cv2.circle(img, self.point_to_show[0], 2, self.point_to_show[2], 3)


        # draw cell outlines
        for cell in self.cell_list:
            img = cv2.circle(img, cell, 10, (0, 255, 0), 3)

        if self.flipped:
            img = img[:, ::-1]
            # ? uncomment below for rgb images
            # img = img[:, ::-1] if isGreyscale else img[:, ::-1, :]

        return img

    def new_frame(self):
        '''
        Returns True if a new frame is available
        '''
        return True

    def snap(self):
        '''
        Returns a processed and a raw image
        '''
        raw = self.raw_snap()
        return raw, self.preprocess(raw)

    def raw_snap(self):
        return None

    def get_16bit_image(self):
        '''
        Returns the current image as a 16-bit color image
        '''
        return None

    def last_frame(self) -> None | tuple[int, np.ndarray]:
        '''
        Get the last snapped frame and its number

        Returns
        -------
        (frame_number, frame)
        '''
        try:
            # * the deque has a maxsize of 1, so we can do this
            # maybe we should use a list instead of a deque?
            # ? should we change this to grab the last element instead, as it is more intuitive?
            last_entry = self._last_frame_queue[0]
            # last_entry = self._last_frame_queue[-1]
            return last_entry[0], last_entry[-1]
        except IndexError:  # no frame (yet)
            return None
    
    def last_frame_data(self) -> None | tuple[int, datetime.datetime, np.ndarray]:
        '''
        Get the last snapped frame and its number

        Returns
        -------
        (frame_number, date, frame)
        '''
        try:
            last_entry = self._last_frame_queue[0]
            return last_entry[0], last_entry[1], last_entry[-1]
        except IndexError:  # no frame (yet)
            return None

    def close(self):
        """Shut down the camera device, free resources, etc."""
        pass

    def set_exposure(self, value):
        print('Setting exposure time not supported for this camera')

    def get_exposure(self):
        print('Getting exposure time not supported for this camera')
        return -1

    def change_exposure(self, change):
        if self.get_exposure() > 0:
            self.set_exposure(self.get_exposure() + change)

    def normalize(self):
        print('Normalizing not supported for this camera')
        
    def autonormalize(self, state):
        self.auto_normalize = state
        print('Autonormalizing not supported for this camera')
        return self.auto_normalize

    def auto_exposure(self):
        '''
        Auto exposure assumes frames are 8 bits.
        '''
        mean_luminance = 127

        def f(value):
            self.set_exposure(value)
            time.sleep(.2+.001*value) # wait for new frame with updated value
            while not self.new_frame():
                time.sleep(0.05)
            m = self.snap().mean()
            return m-mean_luminance
        exposure = brentq(f, 0.1,100., rtol=0.1)
        self.set_exposure(exposure)

    def get_frame_rate(self) -> None:
        # return super().get_frame_rate()
        # * A way to calculate FPS
        current_time = time.time()
        if self.last_frame_time:
            self.fps = 1.0 / (current_time - self.last_frame_time)
        self.last_frame_time = current_time

        logging.debug(f"FPS in Camera: {self.fps:.2f}")

    def reset(self):
        pass

    def get_frame_no(self):
        raise NotImplementedError('get_frame_no not implemented for this camera')

class FakeCamera(Camera):
    def __init__(self, manipulator=None, image_z=0, paramecium=False):
        super(FakeCamera, self).__init__()
        self.width = 1024
        self.height = 768
        self.exposure_time = 30
        self.manipulator = manipulator
        self.image_z = image_z
        self.scale_factor = .5  # micrometers in pixels
        self.depth_of_field = 2.
        self.frame = np.array(np.clip(gaussian_filter(np.random.randn(self.width * 2, self.height * 2) * 0.5, 10) * 50 + 128, 0, 255), dtype=np.uint8)
        
        self.start_acquisition()

    def set_exposure(self, value):
        if 0 < value <= 200:
            self.exposure_time = value

    def get_exposure(self):
        return self.exposure_time

    def get_microscope_image(self, x, y, z):
        frame = np.roll(self.frame, int(y), axis=0)
        frame = np.roll(frame, int(x), axis=1)
        frame = frame[self.height // 2:self.height // 2 + self.height,
                      self.width // 2:self.width // 2 + self.width]
        return np.array(frame, copy=True)

    def raw_snap(self):
        '''
        Returns the current image.
        This is a blocking call (wait until next frame is available)
        '''
        if self.manipulator is not None:
            # Use the part of the image under the microscope

            stage_x, stage_y, stage_z = self.manipulator.position_group([4, 5, 6])
            stage_z -= self.image_z
            stage_x *= self.scale_factor
            stage_y *= self.scale_factor
            stage_z *= self.scale_factor
            frame = self.get_microscope_image(stage_x, stage_y, stage_z)
            if self.paramecium is not None:
                self.paramecium.update_position()
                p_x, p_y, p_z = self.paramecium.position
                p_angle = self.paramecium.angle + np.pi / 2
                p_x *= self.scale_factor
                p_y *= self.scale_factor
                p_z *= self.scale_factor
                p_width = 30 * self.scale_factor
                p_height = 100 * self.scale_factor
                xx, yy = np.meshgrid(np.arange(-self.width // 2, self.width // 2), np.arange(-self.height // 2, self.height // 2))
                frame[((xx - (p_x - stage_x)) * np.cos(p_angle) + (yy - (p_y - stage_y)) * np.sin(p_angle)) ** 2 / (p_width / 2) ** 2 +
                      ((xx - (p_x - stage_x)) * np.sin(p_angle) - (yy - (p_y - stage_y)) * np.cos(p_angle)) ** 2 / (p_height / 2) ** 2 < 1] = 50
                frame[((xx - (p_x - stage_x)) * np.cos(p_angle) + (yy - (p_y - stage_y)) * np.sin(p_angle)) ** 2 / (p_width / 2) ** 2 +
                      ((xx - (p_x - stage_x)) * np.sin(p_angle) - (yy - (p_y - stage_y)) * np.cos(p_angle)) ** 2 / (p_height / 2) ** 2 < 0.8] = 100

            for direction, axes in [(-np.pi / 2, [1, 2, 3])]:
                manipulators = np.zeros((self.height, self.width), dtype=np.int16)
                x, y, z = self.manipulator.position_group(axes)
                x = np.cos(self.manipulator.angle) * (x + 50 / self.scale_factor)
                z = np.sin(self.manipulator.angle) * (x + 50 / self.scale_factor) + z
                x *= self.scale_factor
                y *= self.scale_factor
                z *= self.scale_factor
                # cut off a tip
                # Position relative to stage
                x -= stage_x
                y -= stage_y
                z -= stage_z
                X, Y = np.meshgrid(np.arange(self.width) - self.width // 2 + x,
                                   np.arange(self.height) - self.height // 2 + y)
                angle = np.arctan2(X, Y)
                dist = np.sqrt(X ** 2 + Y ** 2)
                border = (0.075 + 0.0025 * abs(z) / self.depth_of_field)
                manipulators[(np.abs(angle - direction) < border) & (dist > 50)] = 5
                edge_width = 0.02 if z > 0 else 0.04  # Make a distinction between below and above
                manipulators[(np.abs(angle - direction) < border) & (np.abs(angle - direction) > border-edge_width) & (dist > 50)] = 75
                frame[manipulators>0] = manipulators[manipulators>0]
        else:
            img = Image.fromarray(self.frame)
            frame = np.array(img.resize((self.width, self.height)))
        exposure_factor = self.exposure_time / 30.
        frame = frame + np.random.randn(self.height, self.width) * 5

        return np.array(np.clip(frame * exposure_factor, 0, 255),
                        dtype=np.uint8)


def text_phantom(text, size):
    # Availability is platform dependent
    font = 'Arial'
    
    # Create font
    pil_font = ImageFont.truetype(font + ".ttf", size=size[0] // len(text),
                                  encoding="unic")
    text_width, text_height = pil_font.getsize(text)

    # create a blank canvas with extra space between lines
    canvas = Image.new('RGB', size, (0, 0, 0))

    # draw the text onto the canvas
    draw = ImageDraw.Draw(canvas)
    offset = ((size[0] - text_width) // 2,
              (size[1] - text_height) // 2)
    white = "#ffffff"
    draw.text(offset, text, font=pil_font, fill=white)

    # Convert the canvas into an array with values in [0, 1]
    frame = np.asarray(canvas)
    return frame


class DebugCamera(Camera):
    '''A fake camera that shows the frame number'''
    def __init__(self, frames_per_s=20, write_delay=0):
        super(DebugCamera, self).__init__()
        self.width = 1024
        self.height = 768
        self.frameno = 0
        self.last_frame_time = None
        self.delay = 1 / frames_per_s
        self._debug_write_delay = write_delay
        self.start_acquisition()

    def get_frame_rate(self):
        return 1 / self.delay

    def raw_snap(self):
        '''
        Returns the current image.
        This is a blocking call (wait until next frame is available)
        '''
        frame = text_phantom('{:05d}'.format(self.frameno), (self.width, self.height))
        self.frameno += 1
        if self.last_frame_time is not None:
            if time.time() - self.last_frame_time < self.delay:
                time.sleep(self.delay - (time.time() - self.last_frame_time))
        self.last_frame_time = time.time()
        return frame


class RecordedVideoCamera(Camera):
    def __init__(self, file_name, pixel_per_um, slowdown=1):
        super(RecordedVideoCamera, self).__init__()
        self.file_name = file_name
        self.video = cv2.VideoCapture(file_name)
        self.video.open(self.file_name)
        self.width = int(self.video.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.height = int(self.video.get(cv2.CAP_PROP_FRAME_HEIGHT))
        self.pixel_per_um = pixel_per_um
        self.frame_rate = self.video.get(cv2.CAP_PROP_FPS)
        self.time_between_frames = 1 / self.frame_rate * slowdown
        self._last_frame_time = None
        self.start_acquisition()

    def get_frame_rate(self):
        return self.frame_rate

    def raw_snap(self):
        if self._last_frame_time is not None:
            if time.time() - self._last_frame_time < self.time_between_frames:
                # We are too fast, sleep a bit before returning the frame
                sleep_time = self.time_between_frames - (time.time() - self._last_frame_time)
                time.sleep(sleep_time)
        success, frame = self.video.read()
        self._last_frame_time = time.time()

        if not success and self._acquisition_thread.running:
            raise ValueError(f'Cannot read from file {self.file_name}.')

        return frame

    def close(self):
        self.video.release()
        super(RecordedVideoCamera, self).close()


================================================
File: /holypipette/devices/camera/__init__.py
================================================
from __future__ import absolute_import
from .camera import *
from .FakeCalCamera import *

# ! WHY??? WHY PYTHON IMPORTS? WHY DOES THIS MAKE EVERYTHING CRASH?
# ? specifially, why will tihs make everything crsh if we have 
# __all__ = ['PcoCamera'] in pcocamera.py?
# from .pcocamera import *


================================================
File: /holypipette/devices/camera/FakeCalCamera.py
================================================
from holypipette.devices.cellsorter.CellSorter import CellSorterManip
from holypipette.devices.manipulator import Manipulator, FakeManipulator
from .camera import Camera
import numpy as np
import cv2
from pathlib import Path
import time

from PIL import Image, ImageDraw, ImageFilter, ImageEnhance

class FakeCalCamera(Camera):
    def __init__(self, stageManip=None, pipetteManip=None, image_z=0, targetFramerate=40, cellSorterManip=None):
        super(FakeCalCamera, self).__init__()
        self.width : int = 1024
        self.height : int = 1024
        self.exposure_time : int = 30
        self.stageManip : Manipulator = stageManip
        self.pipetteManip : Manipulator = pipetteManip
        self.image_z : float = image_z
        self.pixels_per_micron : float = 1.25  # pixels / micrometers
        self.frameno : int = 0
        self.pipette = FakePipette(self.pipetteManip, self.pixels_per_micron)
        self.targetFramerate = targetFramerate
        self.cellSorterManip = cellSorterManip
        self.cellSorterHandler = FakeCellSorterHandler(self.stageManip, self.cellSorterManip, [400, 200, 0], self.pixels_per_micron)

        curFile = str(Path(__file__).parent.absolute())

        #setup frame image (numpy because of easy rolling)
        self.frame = cv2.imread(curFile + "/FakeMicroscopeImgs/background.tif", cv2.IMREAD_GRAYSCALE)
        self.frame = cv2.resize(self.frame, dsize=(self.width * 2, self.height * 2), interpolation=cv2.INTER_NEAREST)

        self.last_img = None
        self.last_stage_pos = None

        #creating large noise arrays slows down fps, create 100 arrays at startup instead
        self.noiseArrs = []
        for _ in range(100):
            self.noiseArrs.append((np.random.random((self.width, self.height)) * 30).astype(np.uint16))

        #start image recording thread
        self.start_acquisition()

    def normalize(self):
        print('normalize not implemented for FakeCalCamera')

    def set_exposure(self, value):
        if 0 < value <= 200:
            self.exposure_time = value

    def get_exposure(self):
        return self.exposure_time

    def get_microscope_image(self, x, y):
        if self.last_img is None or self.last_stage_pos[0] != x or self.last_stage_pos[1] != y:
            #we need to recalculate what the stage sees
            frame = np.roll(self.frame, int(y), axis=0)
            frame = np.roll(frame, int(x), axis=1)
            frame = frame[self.height//2:self.height//2+self.height,
                        self.width//2:self.width//2+self.width]
            
            #update cached frame
            self.last_stage_pos = [x, y]
            self.last_img = frame
        else:
            frame = self.last_img
            
        self.frameno += 1
        return Image.fromarray(frame)

    def get_16bit_image(self):
        #Note: use float 32 rather than int16 for opencv sobel filter compatability (focus score)
        return (self.raw_snap().astype(np.float32) / 255) * 65535 

    def get_frame_no(self):
        return self.frameno

    def raw_snap(self):
        '''
        Returns the current image.
        This is a blocking call (wait until next frame is available)
        '''
        start = time.time()
        # Use the part of the image under the microscope
        stage_x, stage_y, stage_z = self.stageManip.position_group([1, 2, 3])

        startPos = [-235000, 55000, 285000]
        stage_x = stage_x - startPos[0]
        stage_y = stage_y - startPos[1]
        stage_z = stage_z - startPos[2]

        #get background at current stage position
        img_x = -stage_x * self.pixels_per_micron
        img_y = -stage_y * self.pixels_per_micron
        frame = self.get_microscope_image(img_x, img_y)

        #blur cover slip proportionally to how far stage_z is from 0 (being focused in the img plane)
        focusFactor = abs(stage_z - self.image_z) / 10
        if focusFactor == 0:
            focusFactor = 0.1

        frame = cv2.GaussianBlur(np.array(frame), (63,63), focusFactor)
        frame = Image.fromarray(frame)

        #add pipette to image
        frame = self.pipette.add_pipette_to_img(frame, [stage_x, stage_y, stage_z])

        #add cellsorter to image
        frame = self.cellSorterHandler.add_cellsorter_to_img(frame, [stage_x, stage_y, stage_z])

        #add noise, exposure
        exposure_factor = self.exposure_time/30.

        frame = frame + self.noiseArrs[self.frameno % len(self.noiseArrs)] #use pregenerated noise to increase fps
        frame[np.where(frame >= 255)] = 255
        frame[np.where(frame < 0)] = 0
        frame = frame.astype(np.uint8)

        dt = time.time() - start
        if dt < (1/self.targetFramerate):
            time.sleep((1/self.targetFramerate) - dt)
        
        return frame
    
class FakeCellSorterHandler():
    def __init__(self, stage : Manipulator, cellSorterManip : CellSorterManip, cellSorterOffset : np.ndarray, pixels_per_micron : float):
        self.stage = stage
        self.cellSorterManip = cellSorterManip
        self.cellSorterOffset = cellSorterOffset
        self.pixels_per_micron = pixels_per_micron

    def add_cellsorter_to_img(self, img : np.ndarray, stage_pos : np.ndarray):
        stage_x, stage_y, stage_z = stage_pos

        # get cellsorter pos
        cellSorter_z = self.cellSorterManip.position()

        cellSorter_z *= 1000 #convert to um

        #covert to pixels
        cellSorterXY = [self.cellSorterOffset[0] * self.pixels_per_micron, self.cellSorterOffset[1] * self.pixels_per_micron]

        #else cell sorter pipette in frame: add it to image - 2 channel (grayscale, alpha)
        cellSorterImg = np.zeros((img.shape[0], img.shape[1], 2), dtype=np.float32)

        #pipette looks like a black ring while in focus
        cv2.circle(cellSorterImg, (int(cellSorterXY[0]), int(cellSorterXY[1])), thickness=40, radius=100, color=(0, 1))

        #blur proportionally to how far cellsorter_z is from 0 (being focused in the img plane)
        focusFactor = abs(cellSorter_z - stage_z - self.cellSorterOffset[2]) / 10
        if focusFactor == 0:
            focusFactor = 0.1
        
        cellSorterImg = cv2.GaussianBlur(cellSorterImg, (63,63), focusFactor)

        #add to image (with alpha blending)
        img = img.astype(np.float32)
        img = img * (1 - cellSorterImg[:, :, 1]) + cellSorterImg[:, :, 0] * cellSorterImg[:, :, 1]
        
        return img.astype(np.uint8)

            
class FakePipetteManipulator(FakeManipulator):
    def __init__(self, min=None, max=None, armAngle=np.pi/6):
        super(FakePipetteManipulator, self).__init__(min, max)
        self.armAngle = armAngle

        self.raw_to_real_mat  = np.array([[np.cos(self.armAngle), 0, 0], 
                                          [0, 1, 0], 
                                          [-np.sin(self.armAngle), 0, 1]], dtype=np.float32)

        self.real_to_raw_mat = np.linalg.inv(self.raw_to_real_mat)


    def raw_to_real(self, raw_pos : np.ndarray):
        raw_pos = raw_pos.copy()
        # raw_pos[0] = raw_pos[0] * np.cos(self.armAngle)
        real_pos = np.matmul(self.raw_to_real_mat, np.array(raw_pos).T)
        return real_pos

    def real_to_raw(self, real_pos : np.ndarray):
        real_pos = real_pos.copy()
        raw_pos = np.matmul(self.real_to_raw_mat, np.array(real_pos).T)
        return raw_pos

    def position(self, axis=None):
        raw_pos = self.raw_position()
        real_pos = self.raw_to_real(raw_pos)
        
        if axis == None:
            return real_pos
        else:
            return real_pos[axis-1]

    def raw_position(self, axis=None):
        return super().position(axis).copy()

    def absolute_move(self, x, axis):
        print(f"Moving axis {axis} to {x}\t{self.position()}\t{self.raw_position()}")
        new_setpoint_raw = np.empty((3,)) * np.nan
        if axis == 1:
            #we're dealing with the 'virtual' d-axis
            new_setpoint_raw = self.raw_position()
            curr_pos_real = self.position()
            dx = x - curr_pos_real[0]
            dVect = self.real_to_raw(np.array([dx, 0, 0]))
            new_setpoint_raw += dVect
        elif axis == 3:
            #we're dealing with z - needs to be handeled based on offset
            new_setpoint_raw = self.raw_position()
            curr_pos_real = self.position()
            dz = x - curr_pos_real[2]
            dVect = self.real_to_raw(np.array([0, 0, dz]))
            new_setpoint_raw += dVect
        else:
            #we're dealing with a physical axis, it can be commanded directly
            new_setpoint_raw[axis-1] = x

        for pos, axis in zip(new_setpoint_raw, range(3)):
            if not np.isnan(pos):
                super().absolute_move(pos, axis+1)

    def absolute_move_group(self, x, axes):
        new_setpoint_raw = self.raw_position()
        curr_pos_real = self.position()
        x = np.array(x)
        axes = np.array(axes)

        if 1 in axes:
            #we're dealing with the 'virtual' d-axis
            indx = np.where(axes == 1)[0][0]
            dx = x[indx] - curr_pos_real[0]
            dVect = self.real_to_raw(np.array([dx, 0, 0]))
            new_setpoint_raw += dVect
        if 2 in axes:
            indy = np.where(axes == 2)[0][0]
            dy = x[indy] - curr_pos_real[1]
            new_setpoint_raw[1] += dy
        if 3 in axes:
            #we're dealing with z - needs to be handeled based on offset
            indz = np.where(axes == 3)[0][0]
            dz = x[indz] - curr_pos_real[2]
            dVect = self.real_to_raw(np.array([0, 0, dz]))
            new_setpoint_raw += dVect
        
        for x,i in zip(new_setpoint_raw, range(3)):
            print(f"Moving axis {i+1} to {x}\t{self.position()}\t{self.raw_position()}")
            super().absolute_move(x, i+1)

class FakePipette():

    def __init__(self, manipulator:Manipulator, microscope_pixels_per_micron, stage_to_pipette=np.eye(4,4), pipetteAngle=np.pi/6):

        stage_to_pipette = np.array([[0.7,  -0.3,   0,      0], 
                                     [0.3,  1,      0,      0], 
                                     [0,    0,      -(1/2), 600], 
                                     [0,    0,      0,      1]])

        # rotation matrix to make the x-axis to parallel to the pipette, rather than the stage
        # note: this is the rotation matrix about the y-axis, but only rotating the x axis (not z)
        # creates a non-orthogonal coordinate system, but that's the same as the real pipette  
        self.rot_mat  = np.array([[np.cos(pipetteAngle), 0, 0, 0], 
                            [0, 1, 0, 0], 
                            [np.sin(pipetteAngle), 0, 1, 0], 
                            [0, 0, 0, 1]])

        stage_to_pipette = np.matmul(np.linalg.inv(self.rot_mat), stage_to_pipette)

        
        self.manipulator = manipulator
        self.pixels_per_micron = microscope_pixels_per_micron
        self.stage_to_pipette = stage_to_pipette #homoegeneous transform matrix from stage to pipette
        self.pipette_to_stage = np.linalg.inv(self.stage_to_pipette)

        #setup pipette image (PIL b/c of easy pasting)
        curFile = str(Path(__file__).parent.absolute())
        self.pipetteImg = Image.open(curFile + "/FakeMicroscopeImgs/pipette.png").convert("L")
        self.pipetteImg = self.pipetteImg.resize((self.pipetteImg.size[0] * 4, self.pipetteImg.size[1] * 2), Image.Resampling.BILINEAR)
        filter = ImageEnhance.Brightness(self.pipetteImg)
        self.pipetteImg = filter.enhance(1.2)

        #create an alpha mask for the pipette (to make pipette see through)
        filter = ImageEnhance.Brightness(self.pipetteImg)
        self.alphaMask = filter.enhance(1.2)
        
    def add_pipette_to_img(self, frame:Image, stagePos:list):

        # print(self.manipulator.position(), self.manipulator.raw_position())
        #get stage micron coords
        stage_x, stage_y, stage_z = stagePos

        #get stage pixel coords
        stage_img_x = stage_x * self.pixels_per_micron
        stage_img_y = stage_y * self.pixels_per_micron

        #get pipette micron coords
        pipette_x, pipette_y, pipette_z = self.manipulator.position()
        pipette_pos_h = np.array([pipette_x, pipette_y, pipette_z, 1])

        #get pipette position in stage coordinates
        pipette_pos_stage_coords_h = np.matmul(self.pipette_to_stage, pipette_pos_h.T)
        pipette_pos_stage_coords = pipette_pos_stage_coords_h[0:3] / pipette_pos_stage_coords_h[3]

        #get pipette position in image coordinates
        pipette_pos_img_coords = pipette_pos_stage_coords * self.pixels_per_micron

        #get x,y - convert to int, make relative to frame
        pipette_img_x = int(pipette_pos_img_coords[0] - stage_img_x) - self.pipetteImg.size[0] #pipette_pos should correspond to tip of pipette (upper right) 
        pipette_img_y = int(pipette_pos_img_coords[1] - stage_img_y)

        #blur pipette proportionally to distance between stage_z and pipette_z
        focusFactor = abs(stage_z - pipette_pos_stage_coords[2]) / 10
        if focusFactor == 0:
            focusFactor = 0.1 #resolve divide by 0 error

        #blur img
        pipetteImg = cv2.GaussianBlur(np.array(self.pipetteImg), (63,63), focusFactor)
        pipetteImg = Image.fromarray(pipetteImg)

        #blur alpha channel
        alphaMask = cv2.GaussianBlur(np.array(self.alphaMask), (63,63), focusFactor / 2)
        alphaMask = alphaMask / 1.3
        alphaMask = Image.fromarray(alphaMask.astype(np.uint8))

        #add pipette to frame
        frame.paste(pipetteImg, (pipette_img_x, pipette_img_y), alphaMask)
        frame = np.array(frame) #convert back to numpy for opencv support
        return frame

================================================
File: /holypipette/devices/camera/qimagingcam.py
================================================
'''
Camera for a Qimaging Rolera Bolt Camera.
'''
import numpy as np
import time

from . import *
import warnings
from holypipette.deepLearning.pipetteFinder import PipetteFinder
from holypipette.deepLearning.pipetteFocuser import PipetteFocuser, FocusLevels
from collections import deque
import cv2
import pymmcore
import sys
import threading
import copy
import logging
logging.basicConfig(level=logging.INFO)
__all__ = ['QImagingCam']

sys.path.append('C:\\Program Files\\Micro-Manager-2.0\\')
class QImagingCam(Camera):
    '''A camera class for the Qimaging Rolera Bolt camera.
  
    '''

    def __init__(self, width : int = 1280, height : int = 1024):
        super(QImagingCam, self).__init__()

        self.width = width #update superclass img width / height vars
        self.height = height
        self.autonormalize = False
      

        # self.mmc = pymmcore.CMMCore()
        # print('-----setup cam-----')
        # mm_dir = 'C:\\Program Files\\Micro-Manager_2.0\\' # locate your micromanager folder
        # # mm_dir = '/mnt/c/Users/sa-forest/Desktop/' # locate your micromanager folder
        # self.mmc.setDeviceAdapterSearchPaths([mm_dir])
        # print(self.mmc.getVersionInfo())
        # print(self.mmc.getAPIVersionInfo())

        # print('-----load cam-----')
        # # print(os.path.join(mm_dir, 'MMConfig_1.cfg'))
        # self.mmc.loadSystemConfiguration(mm_dir +'MMConfig_QCam.cfg') # load your micromanager camera configuration file
        # self.mmc.setExposure(33)
        # self.mmc.snapImage()
        # self.prev_frame = self.mmc.getImage().copy()
        # self.mmc.startContinuousSequenceAcquisition(1)

        # cv2.imwrite('test.png', self.prev_frame)



        self.mmc = pymmcore.CMMCore()
        logging.info('-----setup cam-----')
        # print('-----setup cam-----')
        mm_dir = 'C:\\Program Files\\Micro-Manager-2.0\\'  # Update this path
        logging.info('-----load cam-----')
        # print('-----load cam-----')
        self.mmc.setDeviceAdapterSearchPaths([mm_dir])

        # print(self.mmc.getVersionInfo())
        # print(self.mmc.getAPIVersionInfo())
        # print('-----start cam-----')
        self.mmc.loadSystemConfiguration(mm_dir + 'MMConfig_QCam.cfg')
        self.mmc.setExposure(33)
        self.mmc.snapImage()
        self.prev_frame = self.mmc.getImage().copy()
        # cv2.imwrite('test.png', self.prev_frame)
        logging.info('-----start cam-----')
        self.mmc.startContinuousSequenceAcquisition(1)
       
        self.frameno = None
        self.currExposure = 0
        self.upperBound = 255
        self.lowerBound = 0

        self.normalize() #normalize image on startup

        self.start_acquisition() #start thread that updates camera gui

    def set_exposure(self, value):
        pass

    def get_exposure(self):
        '''return the exposure time of the camera in ms
        '''
        return 0 #convert to ms

    def get_frame_rate(self):
        return 0

    def reset(self):
        pass 

    def normalize(self, img = None):
        if img is None:
            img = self.get_16bit_image()

        # is there a better way to do this?
        # maybe 2 stdevs instead?
        self.lowerBound = img.min()
        self.upperBound = img.max()


    def autonormalize(self,flag = False):
        self.auto_normalize = flag

        return self.auto_normalize
    def get_frame_no(self):
        return 0 # TODO: is this ok?
        
    def get_16bit_image(self):
        '''get a 16 bit color image from the camera (no normalization)
           this compares to raw_snap which returns a 8 bit image with normalization
        '''
        
        if self.mmc.getRemainingImageCount() > 0:
            self.prev_frame = copy.deepcopy(self.mmc.popNextImage()).astype(np.uint8)
            # self.prev_frame = self.mmc.popNextImage().copy().astype(np.uint16)
        

        return self.prev_frame

    def raw_snap(self):
        '''
        Returns the current image (8 bit color, with normalization).
        This is a blocking call (wait until next frame is available)
        '''
        img = self.get_16bit_image()
        
        if self.auto_normalize:
            self.normalize(img)

        # if img is not None:
        #     focusLvl = self.pipetteFocuser.get_pipette_focus(img)
        #     print(focusLvl)

        #apply upper / lower bounds (normalization)
        span = self.upperBound - self.lowerBound

        if span == 0:
            span = 1 #prevent divide by 0 for blank images

        img = img - self.lowerBound
        img = img / span

        #convert to 8 bit color
        img = img * 255
        img[np.where(img < 0)] = 0
        img[np.where(img > 255)] = 255
        img = img.astype(np.uint8)

        #resize if needed
        if self.width != None and self.height != None:
            img = cv2.resize(img, (self.width, self.height), interpolation= cv2.INTER_LINEAR)

        return img
    
    def close(self):
        logging.info("closing camera in definition")
        self.stop_acquisition()
        # self.mmc.stopSequenceAcquisition()
        # print("stopped sequence acquisition")
        # print("reset mmc")
        self.mmc.unloadAllDevices()
        # print("unloaded all devices")
        return

    def __del__(self):
        self.mmc.stopSequenceAcquisition()
        self.mmc.unloadDevice('Camera')

    def new_frame(self):
        '''
        Returns True if a new frame is available
        '''
        return (self.mmc.getRemainingImageCount() > 0)



================================================
File: /holypipette/devices/camera/moscow_qcam_camera.py
================================================
'''
Camera for the Moscow rig's Qimaging Rolera Bolt camera.
'''
import numpy as np
import time

from . import *
import warnings
from holypipette.deepLearning.pipetteFinder import PipetteFinder
from holypipette.deepLearning.pipetteFocuser import PipetteFocuser, FocusLevels
from collections import deque
import pymmcore
import copy
import threading

try:
    import cv2
except ImportError:
    warnings.warn('OpenCV is not installed.')

__all__ = ['moscow_qcam_camera.py']


class moscowQCamera(Camera):
    '''A camera class for the moscow rig's Qimaging Rolera Bolt camera.
    '''

    def __init__(self, width : int = 2048, height : int = 2048):
        super(moscowQCamera, self).__init__()

        self.width = width #update superclass img width / height vars
        self.height = height
        self.lock = threading.RLock()
        self.lastFrame = None

        #setup the moscow camera for continuous streaming
        self.cam = pymmcore.CMMCore()
        print('-----setup cam-----')
        #mm_dir = 'C:\\Program Files\\Micro-Manager_2.0.1_20230720\\' # locate your micromanager folder
        mm_dir = 'C:\\Program Files\\Micro-Manager-2.0\\'  # Update this path
        print('-----load cam-----')
        self.cam.setDeviceAdapterSearchPaths([mm_dir])
        print(self.cam.getVersionInfo())
        print(self.cam.getAPIVersionInfo())
        self.cam.loadSystemConfiguration(mm_dir + 'MMConfig_QCam.cfg')
        self.cam.setExposure(33)
        self.cam.snapImage()
        self.prev_frame = self.cam.getImage().copy()
        # cv2.imwrite('test.png', self.prev_frame)

        self.cam.startContinuousSequenceAcquisition(1)
        print('-----start cam-----')


        self.frameno = None
        self.normalizeFlag = False  # Add this line to initialize the flag
        self.currExposure = 0
        self.upperBound = 255
        self.lowerBound = 0
        # self.pipetteFinder = PipetteFinder()
        self.pipetteFocuser = PipetteFocuser()
        self.lastFrame = self.prev_frame
        self.normalize() #normalize image on startup


        self.start_acquisition() #start thread that updates camera gui

    def set_exposure(self, value):
        pass

    def get_exposure(self):
        '''return the exposure time of the camera in ms
        '''
        return 0


    def close(self):
        pass

    def get_frame_rate(self):
        return 0

    def reset(self):
        pass

    def normalize(self, img = None):
        pass
                  

    def get_frame_no(self):
        return 0
        
    def get_16bit_image(self):
        '''get a 16 bit color image from the camera (no normalization)
           this compares to raw_snap which returns a 8 bit image with normalization
        '''
        print('-----get 16 bit image----- mostow_qcam_camera.py')
        self.lock.acquire()
        if self.cam.getRemainingImageCount() > 0:
            self.prev_frame = copy.deepcopy(self.cam.popNextImage()).astype(np.uint8)
        self.lock.release()
        return self.prev_frame
        

    def raw_snap(self):
        '''
        Returns the current image (8 bit color, with normalization).
        This is a blocking call (wait until next frame is available)
        '''
        img = self.get_16bit_image()

        # if img is not None:
        #     focusLvl = self.pipetteFocuser.get_pipette_focus(img)
        #     print(focusLvl)

        #apply upper / lower bounds (normalization)
        span = self.upperBound - self.lowerBound

        if span == 0:
            span = 1 #prevent divide by 0 for blank images

        img = img.astype(np.float32)
        img = img - self.lowerBound
        img = img / span

        #convert to 8 bit color
        img = img * 255
        img[np.where(img < 0)] = 0
        img[np.where(img > 255)] = 255
        img = img.astype(np.uint8)

        #resize if needed
        if self.width != None and self.height != None:
            img = cv2.resize(img, (self.width, self.height), interpolation= cv2.INTER_LINEAR)

        return img

================================================
File: /holypipette/devices/camera/pcocamera.py
================================================
'''
Camera for a PCO Panda Camera
'''
import numpy as np

from . import *
import warnings
import pco
from holypipette.deepLearning.pipetteFinder import PipetteFinder
from holypipette.deepLearning.pipetteFocuser import PipetteFocuser, FocusLevels


try:
    import cv2
except ImportError:
    warnings.warn('OpenCV is not installed.')

# ? See __init__.py for the following line
# __all__ = ['PcoCamera']


class PcoCamera(Camera):
    '''A camera class for the PCO Panda microscope camera.
       more info on the camera can be found here: https://www.pco.de/fileadmin/fileadmin/user_upload/pco-manuals/pco.panda_manual.pdf
    '''

    PCO_RECORDER_LATEST_IMAGE = 0xFFFFFFFF

    def __init__(self, width: int = 1280, height: int = 1280):
        super().__init__()

        self.width = width # update superclass img width / height vars
        self.height = height
        self.auto_normalize = False

        #setup the pco camera for continuous streaming
        self.cam = pco.Camera()

        print(f"CAMERA {self.cam}")

        # self.ca .sdk.set_timestamp_mode('binary & ascii')
        config = {'exposure time': 5e-3,
                    'roi': (385, 385, 1664, 1664),
                    'timestamp': 'off',
                    'trigger': 'auto sequence',
                    'acquire': 'auto',
                    'metadata': 'on',
                    'binning': (1, 1)}

        self.cam.configuration = config

        self.cam.record(number_of_images = 10, mode='ring buffer') #use "ring buffer" mode for continuous streaming from camera
        self.cam.wait_for_first_image()

        self.frameno = None

        self.currExposure = 0

        self.upperBound = 255
        self.lowerBound = 0

        self.last_frame_time = None
        self.fps = 0

        # self.pipetteFinder = PipetteFinder()
        self.pipetteFocuser = PipetteFocuser()

        self.normalize() #normalize image on startup

        self.start_acquisition() #start thread that updates camera gui

    def set_exposure(self, value: float) -> None:
        self.cam.set_exposure_time(value / 1000)

    def get_exposure(self):
        '''return the exposure time of the camera in ms
        '''
        exposure = self.cam.get_exposure_time() # this is in seconds
        self.currExposure = exposure
        return exposure * 1000 #convert to ms

    def close(self):
        if self.cam:
            self.cam.stop()
            self.cam.close()

    def reset(self) -> None:
        self.cam.close()
        self.cam = pco.Camera()
        
        config = {'exposure time': 10e-3,
                    'roi': (0, 0, 2048, 2048),
                    'timestamp': 'off',
                    'pixel rate': 500_000_000,
                    'trigger': 'auto sequence',
                    'acquire': 'auto',
                    'metadata': 'on',
                    'binning': (1, 1)}
        self.cam.configuration = config

        self.cam.record(number_of_images=10, mode='ring buffer')
        self.cam.wait_for_first_image()

    def normalize(self, img = None) -> None:

        if not self.auto_normalize:
            print("NORMALIZING")   

        # print(f"BEFORE IMAGE: {img}")
        if img is None:
            img = self.get_16bit_image()
            # print(f"IMAGE after get_16bit_image: {img}")
            # print(type(img))
        # print(f"AFTER IMAGE: {img}")
        #is there a better way to do this?
        #maybe 2 stdevs instead?
        self.lowerBound = img.min()
        self.upperBound = img.max()

    def autonormalize(self,flag = None):
        self.auto_normalize = flag
        return self.auto_normalize

    def get_frame_no(self) -> int:
        return self.frameno
        
    def get_16bit_image(self) -> np.ndarray:
        '''get a 16 bit color image from the camera (no normalization)
           this compares to raw_snap which returns a 8 bit image with normalization
        '''
        # if self.frameno == self.cam.rec.get_status()['dwProcImgCount'] and self.lastFrame is not None:
        #     return self.lastFrame
        # else:
        # print('-----get 16 bit image----- PcoCamera.py')
        self.frameno = self.cam.rec.get_status()['dwProcImgCount']
        # self.get_frame_rate()
        
        try:
            # print(f"IMAGE NUMBER: {PcoCamera.PCO_RECORDER_LATEST_IMAGE}")
            # img, meta = self.cam.image(PcoCamera.PCO_RECORDER_LATEST_IMAGE)
            # this is the line that is causing an error if pco <= 2.1.2
            img, meta = self.cam.image(image_number=PcoCamera.PCO_RECORDER_LATEST_IMAGE)
            self.lastFrame = img
            # logging.debug(f"Got image from camera: {datetime.now()}")
            # print(meta)
        except Exception as e:
            print(f"ERROR in get_16bit_image: {e}")
            return self.last_frame # there was an error grabbing the most recent frame

        return img

    def raw_snap(self):
        '''
        Returns the current image (8 bit color, with normalization).
        This is a blocking call (wait until next frame is available)
        '''
        img = self.get_16bit_image()

        if self.auto_normalize:
            # print("AutoNormalizing")
            self.normalize(img)

        if img is None:
            return None

        # if img is not None:
        #     focusLvl = self.pipetteFocuser.get_pipette_focus(img)
        #     print(focusLvl)

        # apply upper / lower bounds (normalization)
        span = np.maximum(self.upperBound - self.lowerBound, 1)  # Avoid division by zero

        img = np.clip((img.astype(np.float32) - self.lowerBound) / span * 255, 0, 255).astype(np.uint8)

        # resize if needed
        if self.width != None and self.height != None:
            img = cv2.resize(img, (self.width, self.height), interpolation = cv2.INTER_LINEAR)

        # if img is not None:
        #     out = self.pipetteFinder.find_pipette(img)
        #     if out is not None:
        #         img = cv2.circle(img, out, 2, 0, 2)

        # find good points to track
        # corners = cv2.goodFeaturesToTrack(img, 250, 0.005, 10)
        # corners = np.int0(corners)
        
        # draw points on image

        # we only want the top 100 corners

        # if self.lastFrame is not None:
        #     flow = cv2.calcOpticalFlowFarneback(self.lastFrame, img, None, 0.5, 3, 15, 3, 5, 1.2, 0)

        return img

================================================
File: /holypipette/devices/pressurecontroller/BasePressureController.py
================================================
'''
A general pressure controller class
'''
import collections
from time import time

from holypipette.controller.base import TaskController

all = ['PressureController',  'FakePressureController']


class PressureController(TaskController):
    def __init__(self):
        super().__init__()
        self._pressure = collections.defaultdict(int)

    def measure(self, port = 0):
        '''
        Measures the instantaneous pressure, on designated port.
        '''
        pass

    def set_pressure(self, pressure: int, port = 0):
        '''
        Sets the pressure, on designated port.
        '''
        self._pressure[port] = pressure

    def get_pressure(self, port=0) -> float | int | None:
        '''
        Gets the pressure on the designated port. Note that this does not refer
        to any measurement, but simply to the pressure as set via
        `.set_pressure`.
        '''
        return self._pressure[port]

    def ramp(self,amplitude = -230., duration = 1.5, port = 0):
        '''
        Makes a ramp of pressure
        '''
        t0 = time()
        t = t0
        while t-t0<duration:
            self.set_pressure(amplitude*(t-t0)/duration)
            t = time()
        self.set_pressure(0)

    def set_ATM(self, atm):
        self.state = atm
        pass


class FakePressureController(PressureController):
    def __init__(self):
        super(FakePressureController, self).__init__()
        self.pressure = 0

    def measure(self, port=0) -> int:
        '''
        Measures the instantaneous pressure, on designated port.
        '''
        return self.pressure
    
    def getLastVal(self) -> int:
        return self.pressure

    def set_pressure(self, pressure, port=0):
        '''
        Sets the pressure, on designated port.
        '''
        self.debug('Pressure set to: {}'.format(pressure))
        self.pressure = pressure

    def get_pressure(self, port=0) -> int:
        return self.pressure


================================================
File: /holypipette/devices/pressurecontroller/__init__.py
================================================
from __future__ import absolute_import
from .BasePressureController import *
from .IBBPressureController import IBBPressureController
from .TestPressureController import TestPressureController
from .MoscowPressureController import MoscowPressureController

================================================
File: /holypipette/devices/pressurecontroller/TestPressureController.py
================================================
'''
Pressure Controller classes to communicate with the Pressure Controller Box made by the IBB
'''
from logging import exception
import logging
from .BasePressureController import PressureController
import serial.tools.list_ports
import serial
import time
logging.basicConfig(level=logging.INFO)

all = ['TestPressureController']

class TestPressureController(PressureController):
    '''A PressureController child class that handles serial communication between the PC and
       the Arduino controlling the IBB Pressure box
    '''

                    
    nativePerMbar = 0.75 # The number of native pressure transucer units from the DAC (0 to 4095) in a millibar of pressure (-700 to 700)
    nativeZero = 2048 # The native units at a 0 pressure (y-intercept)


    def __init__(self, channel, controllerSerial=None, readerSerial=None):
        super().__init__()
        try:
            self.controllerSerial = controllerSerial
            self.readerSerial = readerSerial
        except Exception as e:
            logging.error(f"Error initializing pressure controller: {e}")
            return

        self.channel = channel
        self.isATM = None
        self.setpoint_raw = None
        self.lastVal = None

        self.serialCmdTimeout = 1 # (in sec) max time allowed between sending a serial command and expecting a response
        time.sleep(2) #wait for arduino to boot up

        #set initial configuration of pressure controller
        self.set_ATM(False)
        self.set_pressure(20)

    def set_pressure(self, pressure):
        '''Tell pressure controller to go to a given setpoint pressure in mbar
        '''
        nativeUnits = self.mbarToNative(pressure)
        self.set_pressure_raw(nativeUnits)
    
    def mbarToNative(self, pressure):
        '''Comvert from a pressure in mBar to native units
        '''
        raw_pressure = int(pressure * TestPressureController.nativePerMbar + TestPressureController.nativeZero)
        return min(max(raw_pressure, 0), 4095) #clamp native units to 0-4095

    def nativeToMbar(self, raw_pressure):
        '''Comvert from native units to a pressure in mBar
        '''
        pressure = (raw_pressure - TestPressureController.nativeZero) / TestPressureController.nativePerMbar
        return pressure

    def set_pressure_raw(self, raw_pressure):
        '''Tell pressure controller to go to a given setpoint pressure in native DAC units
        '''
        self.setpoint_raw = raw_pressure
        logging.info(f"Setting pressure to {self.nativeToMbar(raw_pressure)} mbar (raw: {raw_pressure})")

        cmd = f"set {self.channel} {raw_pressure}\n"
        logging.info(f"Sending command: {cmd}")
        
        logging.info(type(cmd))
        logging.info(cmd)
        logging.info(bytes(cmd, 'ascii'))
        self.controllerSerial.write(bytes(cmd, 'ascii'))
        self.controllerSerial.flush()

    def get_pressure(self):
        '''
        Get the current pressure reading from readerSerial
        '''
        # return self.lastVal
        pressureVal = self.lastVal
        if self.readerSerial.in_waiting > 0:
            reading = self.readerSerial.readline().decode('utf-8').strip()
            # print(reading)

            # check that S and E are in the string only once and that S is the first index and E is the last index
            # 
            # adding more checks results in lag somehow maybe, freezing. 
            # the GUI actuallu unfreezes due to an empty string being read in and therefore
            # pressure[0] or [-1] is indexing out of bounds, introducing a lag where the computer catches up and suddenly
            # can read values?!!
            # if "S" in pressure and "E" in pressure and pressure[0] == "S" and pressure[-1] == "E":
            # if pressure.startswith("S") and pressure.endswith("E"):
            # pressure.count("S") == 1 and pressure.count("E") == 1 and pressure.find("S") < pressure.find("E"):
            if reading[0] == "S" and reading[-1] == "E":
            # Extract the pressure reading between the markers
                pressure_str = reading[1:-1]

                # Try to convert the extracted pressure string to float
                try:
                    pressureVal = float(pressure_str)
                    # logging.info(f"Pressure: {pressureVal} mbar")
                    self.lastVal = pressureVal 
                except ValueError:
                    # pressureVal = None
                    logging.warning("Invalid pressure data received")
            else:
                # pressureVal = None
                logging.warning("Incomplete or invalid data received")
        else:
            # pressureVal = None
            logging.warning("No data received from pressure sensor")

        return pressureVal

    
    
    def getLastVal(self):
        return self.lastVal
      
    def measure(self):
        return self.get_pressure()
    
    def pulse(self, delayMs):
        '''Tell the onboard arduino to pulse pressure for a certain period of time
        '''
        cmd = f"pulse {self.channel} {delayMs}\n"
        logging.info(f"Pulsing pressure for {delayMs} ms")
        self.controllerSerial.write(bytes(cmd, 'ascii')) #do serial writing in main thread for timing?
        self.controllerSerial.flush()
    
    def set_ATM(self, atm):
        '''Send a serial command activating or deactivating the atmosphere solenoid valve
           atm = True -> pressure output is at atmospheric pressure 
           atm = False -> pressure output comes from pressure regulator
        '''
        if atm:
            cmd = f"switchAtm {self.channel}\n" #switch to ATM command
            logging.info("Switching to ATM")
        else:
            cmd = f"switchP {self.channel}\n" #switch to Pressure command
            logging.info("Switching to Pressure")
        self.controllerSerial.write(bytes(cmd, 'ascii'))
        self.controllerSerial.flush()

        self.isATM = atm
    def toggle_ATM(self,atm):
        '''Toggle the atmosphere solenoid valve
        '''
        if atm: 
            self.set_ATM(False)
        else:   
            self.set_ATM(True)

================================================
File: /holypipette/devices/pressurecontroller/IBBPressureController.py
================================================
'''
Pressure Controller classes to communicate with the Pressure Controller Box made by the IBB
'''
from logging import exception
import logging
from .BasePressureController import PressureController
import serial.tools.list_ports
import serial
import time
import threading
import collections
logging.basicConfig(level=logging.INFO)

all = ['IBBPressureController']

class IBBPressureController(PressureController):
    '''A PressureController child class that handles serial communication between the PC and
       the Arduino controlling the IBB Pressure box
    '''

                    
    nativePerMbar = 0.75 # The number of native pressure transucer units from the DAC (0 to 4095) in a millibar of pressure (-700 to 700)
    nativeZero = 2048 # The native units at a 0 pressure (y-intercept)


    def __init__(self, channel, arduinoSerial=None):
        super().__init__()

        self.serial = arduinoSerial

        self.channel = channel
        self.isATM = None
        self.setpoint_raw = None

        self.serialCmdTimeout = 1 # (in sec) max time allowed between sending a serial command and expecting a response
        time.sleep(2) #wait for arduino to boot up

        #set initial configuration of pressure controller
        self.set_ATM(False)
        self.set_pressure(20)

    def set_pressure(self, pressure):
        '''Tell pressure controller to go to a given setpoint pressure in mbar
        '''
        nativeUnits = self.mbarToNative(pressure)
        self.set_pressure_raw(nativeUnits)
    
    def mbarToNative(self, pressure):
        '''Comvert from a pressure in mBar to native units
        '''
        raw_pressure = int(pressure * IBBPressureController.nativePerMbar + IBBPressureController.nativeZero)
        return min(max(raw_pressure, 0), 4095) #clamp native units to 0-4095

    def nativeToMbar(self, raw_pressure):
        '''Comvert from native units to a pressure in mBar
        '''
        pressure = (raw_pressure - IBBPressureController.nativeZero) / IBBPressureController.nativePerMbar
        return pressure

    def set_pressure_raw(self, raw_pressure):
        '''Tell pressure controller to go to a given setpoint pressure in native DAC units
        '''
        self.setpoint_raw = raw_pressure
        logging.info(f"Setting pressure to {self.nativeToMbar(raw_pressure)} mbar (raw: {raw_pressure})")

        cmd = f"set {self.channel} {raw_pressure}\n"
        logging.info(f"Sending command: {cmd}")
        
        logging.info(type(cmd))
        logging.info(cmd)
        logging.info(bytes(cmd, 'ascii'))
        self.serial.write(bytes(cmd, 'ascii'))
        self.serial.flush()

    def get_setpoint(self):
        '''Gets the current setpoint in millibar
        '''
        return self.nativeToMbar(self.setpoint_raw)

    def get_setpoint_raw(self):
        '''Gets the current setpoint in native DAC units
        '''
        logging.info(f"Current setpoint: {self.nativeToMbar(self.setpoint_raw)} mbar (raw: {self.setpoint_raw})")
        return self.setpoint_raw
    
    def get_pressure(self):
        return self.get_setpoint() #maybe add a pressure sensor down the line?
    
    
    def measure(self):
        return self.get_pressure()
    

    def pulse(self, delayMs):
        '''Tell the onboard arduino to pulse pressure for a certain period of time
        '''
        cmd = f"pulse {self.channel} {delayMs}\n"
        logging.info(f"Pulsing pressure for {delayMs} ms")
        self.serial.write(bytes(cmd, 'ascii')) #do serial writing in main thread for timing?
        self.serial.flush()
    


    def set_ATM(self, atm):
        '''Send a serial command activating or deactivating the atmosphere solenoid valve
           atm = True -> pressure output is at atmospheric pressure 
           atm = False -> pressure output comes from pressure regulator
        '''
        if atm:
            cmd = f"switchAtm {self.channel}\n" #switch to ATM command
            logging.info("Switching to ATM")
        else:
            cmd = f"switchP {self.channel}\n" #switch to Pressure command
            logging.info("Switching to Pressure")
        self.serial.write(bytes(cmd, 'ascii'))
        self.serial.flush()

        self.isATM = atm


================================================
File: /holypipette/devices/pressurecontroller/MoscowPressureController.py
================================================

'''
Pressure Controller classes to communicate with the Pressure Controller Box made by the IBB.
Additionally, redesigning a closed loop pressure controller for the Moscow Rig
'''
import logging
from .BasePressureController import PressureController
import serial.tools.list_ports
import serial
import time
import collections
logging.basicConfig(level = logging.INFO)

all = ['MoscowPressureController']

class MoscowPressureController(PressureController):
    '''A PressureController child class that handles serial communication between the PC and
       the Arduino controlling the Moscow Pressure box
    '''
    validProducts = ["USB Serial"] # TODO: move to a constants or json file?
    validVIDs = [0x1a86, 0x403]
                    
    # nativeZero = 2048 # The native units at a 0 pressure (y-intercept)
    # nativePerMbar = float(4096/1380) # The number of native pressure transducer units from the DAC (0 to 4095) in a millibar of pressure (-446 to 736)
    nativeZero = 1962 # The native units at a 0 pressure (y-intercept)
    nativePerMbar = float(3062/1100) # The number of native pressure transducer units from the DAC (0 to 4095) in a millibar of pressure (-400 to 700)

    serialCmdTimeout = 1 # (in sec) max time allowed between sending a serial command and expecting a response

    def __init__(self, channel, controllerSerial = None, readerSerial = None):
        super().__init__()
        # time.sleep(2) # wait for arduino to boot up

        if controllerSerial is not None:
            # no port specified, we will use the user supplied serial port
            self.controllerSerial = controllerSerial
        else:
            self.controllerSerial = None
            logging.error("No controller serial port available")
        
        if readerSerial is not None:
            # no port specified, we will use the user supplied serial port
            self.readerSerial = readerSerial
        else: 
            self.readerSerial = None
            logging.error("No reader serial port available")

        self.channel = channel
        self.isATM = None
        self.setpoint_raw = None
        self.expectedResponses = collections.deque() # use a deque instead of a list for O(1) pop from beginning

        self.lastVal = 0.0

        # set initial configuration of pressure controller
        self.set_ATM(False)
        self.set_pressure(0) # set initial pressure to 0 mbar

    def autodetectSerial(self):
        '''
        Use VID and name of serial devices to figure out which one is the Moscow Pressure box
        '''
        allPorts = [COMPort for COMPort in serial.tools.list_ports.comports()]
        logging.info(f"Attempting to find Moscow Pressure Box from: {[(p.product, hex(p.vid) if p.vid != None else None, p.name) for p in allPorts]}")

    def set_pressure(self, pressure):
        '''
        Tell pressure controller to go to a given setpoint pressure in mbar
        '''
        nativeUnits = self.mbarToNative(pressure)
        # logging.info(f"Setting pressure to {nativeUnits} mbar")
        self.set_pressure_raw(nativeUnits)
    
    def mbarToNative(self, pressure):
        '''
        Comvert from a pressure in mBar to native units
        '''
        raw_pressure = int((pressure * MoscowPressureController.nativePerMbar + MoscowPressureController.nativeZero))
        return min(max(raw_pressure, 0), MoscowPressureController.nativeZero*2) # clamp native units to 0-3924
        # return min(max(raw_pressure, 0), 4095) # clamp native units to 0-4095

    def nativeToMbar(self, raw_pressure) -> float:
        '''
        Comvert from native units to a pressure in mBar
        '''
        pressure = (raw_pressure - MoscowPressureController.nativeZero) / MoscowPressureController.nativePerMbar
        return pressure

    def set_pressure_raw(self, raw_pressure: int):
        '''
        Tell pressure controller to go to a given setpoint pressure in native DAC units
        '''
        self.setpoint_raw = raw_pressure
        logging.info(f"Setting pressure to {self.nativeToMbar(raw_pressure)} mbar (raw: {raw_pressure})")

        cmd = f"set {self.channel} {raw_pressure}\n"
        # logging.info(type(cmd))
        # logging.info(cmd)
        # logging.info(bytes(cmd, 'ascii'))
        logging.info(f"Sending command: {cmd}")
        self.controllerSerial.write(bytes(cmd, 'ascii'))
        # print cmd in ascii
        self.controllerSerial.flush()
        logging.info(f"SenT command: {cmd}")

        # add expected arduino responces
        self.expectedResponses.append((time.time(), f"set {self.channel} {raw_pressure}"))
        self.expectedResponses.append((time.time(), f"set"))
        self.expectedResponses.append((time.time(), f"{self.channel}"))
        self.expectedResponses.append((time.time(), f"{raw_pressure}"))

    def get_setpoint(self) -> float:
        '''
        Gets the current setpoint in millibar
        '''
        return self.nativeToMbar(self.setpoint_raw)

    def get_setpoint_raw(self):
        '''
        Gets the current setpoint in native DAC units
        '''
        # logging.info(f"Current setpoint: {self.nativeToMbar(self.setpoint_raw)} mbar (raw: {self.setpoint_raw})")
        return self.setpoint_raw
    

    def get_pressure(self) -> float:
        '''
        Read the pressure sensor value from the Arduino
        '''
        pressureVal = self.lastVal

        # Send a request command to the Arduino
        self.readerSerial.write(b'R')

        # Wait for the response
        if self.readerSerial.in_waiting > 0:
            reading = self.readerSerial.readline().decode('utf-8').strip()

            # Check that S and E are in the string only once and that S is the first index and E is the last index
            if reading.startswith("S") and reading.endswith("E"):
                # Extract the pressure reading between the markers
                pressure_str = reading[1:-1]
                # Try to convert the extracted pressure string to float
                try:
                    pressureVal = float(pressure_str)
                    # logging.info(f"Pressure: {pressureVal} units (raw)")
                    # pressureVal = float((pressureVal/2.559) + 512) # conversion to raw because the seeed is not working
                    # pressureVal = float((pressureVal*0.3923)+516.72)
                    pressureVal = float((pressureVal - 516.72)/0.3923) # conversion to raw because the seeed is not working
                    self.lastVal = pressureVal
                except ValueError:
                    # pressureVal = None
                    logging.warning("Invalid pressure data received")
            # * Not sure if the else is needed.
            # else:
                # pressureVal = None
                # logging.warning("Incomplete or invalid data received")
        else:
            # pressureVal = None
            logging.warning("No data received from pressure sensor")

        # print(pressureVal)
        return pressureVal

    
    def getLastVal(self) -> float:
        return self.lastVal

    def measure(self) -> float:
        return self.get_pressure()
    
    def pulse(self, delayMs):
        '''Tell the onboard arduino to pulse pressure for a certain period of time
        '''
        cmd = f"pulse {self.channel} {delayMs}\n"
        logging.info(f"Pulsing pressure for {delayMs} ms")
        self.controllerSerial.write(bytes(cmd, 'ascii')) #do serial writing in main thread for timing?
        self.controllerSerial.flush()
        
        # add expected arduino responces
        # self.expectedResponses.append((time.time(), f"pulse {self.channel} {delayMs}"))
        # self.expectedResponses.append((time.time(), f"pulse"))
        # self.expectedResponses.append((time.time(), f"{self.channel}"))
        # self.expectedResponses.append((time.time(), f"{delayMs}"))


    def set_ATM(self, atm):
        '''Send a serial command activating or deactivating the atmosphere solenoid valve
           atm = True -> pressure output is at atmospheric pressure 
           atm = False -> pressure output comes from pressure regulator
        '''
        if atm:
            cmd = f"switchAtm {self.channel}\n" # switch to ATM command
            logging.info("Switching to ATM")
        else:
            cmd = f"switchP {self.channel}\n" # switch to Pressure command
            logging.info("Switching to Pressure")
        self.controllerSerial.write(bytes(cmd, 'ascii'))
        self.controllerSerial.flush()

        self.isATM = atm

        #add the expected arduino responses 
        # if atm:
        #     self.expectedResponses.append((time.time(), f"switchAtm {self.channel}"))
        #     self.expectedResponses.append((time.time(), f"switchAtm"))
        #     self.expectedResponses.append((time.time(), f"{self.channel}"))
        #     self.expectedResponses.append((time.time(), f"0"))
        # else:
        #     self.expectedResponses.append((time.time(), f"switchP {self.channel}"))
        #     self.expectedResponses.append((time.time(), f"switchP"))
        #     self.expectedResponses.append((time.time(), f"{self.channel}"))
        #     self.expectedResponses.append((time.time(), f"0"))

    # def waitForArduinoResponses(self):
    #     '''Continuously ensure that all expected responses are received within the timeout period.
    #        Runs in a deamon thread.
    #     '''
    #     while True:
    #         if len(self.expectedResponses) == 0 and self.controllerSerial.in_waiting == 0:
    #             time.sleep(0.1)
    #             continue #nothing to do
            
    #         #check for new responses
    #         resp = self.controllerSerial.readline().decode("ascii")
    #         while len(resp) > 0: #process all commands 
    #             #remove newlines from string
    #             resp = resp.replace('\n', '')
    #             resp = resp.replace('\r', '')
                
    #             #grab latest expected response
    #             if len(self.expectedResponses) > 0:
    #                 sendTime, expected = self.expectedResponses.popleft()
    #             else:
    #                 expected = None

    #             #make what was actually received and what was expected match
    #             if resp != expected:
    #                 logging.info(f"INVALID PRESSURE COMMAND, EXPECTED RESPONSE {expected} BUT GOT {resp}")
    #                 self.expectedResponses.clear()
    #             else :
    #                 logging.info(f"Pressure Box Response: {resp}")
                
    #             #grab the next line
    #             resp = self.controllerSerial.readline().decode("ascii")
            
    #         while len(self.expectedResponses) > 0 and time.time() - self.expectedResponses[0][0] > self.serialCmdTimeout:
    #             #the response on top of expectedResponses has timed out!
    #             self.expectedResponses.popleft() #remove timed out response
    #             logging.info("PRESSURE BOX SERIAL RESPONSE TIMEOUT!")
            
    #         time.sleep(0.01) #sleep less when there might be things to do shortly

================================================
File: /holypipette/devices/lamp/__init__.py
================================================
from __future__ import absolute_import
from .lumencor import Lumencore


================================================
File: /holypipette/devices/lamp/lumencor.py
================================================
from enum import Enum
import serial
import time
import logging

class LightColor(Enum):
    '''An enum to represent the colors the Lumencore can output
    '''
    RED = 0
    GREEN = 1
    CYAN = 2
    UV = 3
    # 4th bit is for green/yellow filter (not a color)
    BLUE = 5
    TEAL = 6
    OFF = 7

class ExcitationFilter(Enum):
    '''An enum to represent the excitation filters the Lumencore can use
    '''
    YELLOW = 0
    GREEN = 1

class Lumencore:
    '''A class to control the Lumencore Spectra X Light engine
       Documentation can be found here: https://cms.lumencor.com/system/uploads/fae/file/asset/150/57-10035_Spectra_X_Command_Reference.pdf
    '''
    def __init__(self, com: serial.Serial):
        self.com = com
        #send init commands
        self.com.write(bytearray([0x57, 0x02, 0xFF, 0x50])) #init cmd 1
        self.com.write(bytearray([0x57, 0x03, 0xAB, 0x50])) #init cmd 2

        self.logger = logging.getLogger(__name__)
        self.logger.info("Lumencore initialized")

    def enable(self, light : LightColor, excitation_filter : ExcitationFilter = ExcitationFilter.GREEN):

        if light == LightColor.OFF:
            cmd = bytearray([0x4F, 0x7F, 0x50])
            self.com.write(cmd)
            return
        
        light_index = 0x00
        light_index |= 1 << light.value #set the bit of the light we want to enable

        #invert the bits so that 0 is on and 1 is off
        light_index = ~light_index & 0x7F #we only want the first 7 bits

        if excitation_filter == ExcitationFilter.YELLOW:
            light_index &= 0xEF #set the 4th bit to 0

        cmd = bytearray([0x4F, light_index, 0x50])

        self.com.write(cmd)
        logging.info("Lumencore color {} enabled ({} Filter)".format(light.name, excitation_filter.name))

    
    def set_power(self, power_percent : float, light : LightColor):
        '''Sets the power of a light to a percentage of the maximum
           power_percent: float between 0 and 100
           light: LightColor enum
        '''
        if power_percent > 100:
            power_percent = 100
        elif power_percent < 0:
            power_percent = 0
        
        #calculate address of the DAC given light color
        dacAddress = None
        lightAddress = 0x01
        addr18Lights = [LightColor.UV, LightColor.CYAN, LightColor.GREEN, LightColor.RED]
        addr1ALights = [LightColor.BLUE, LightColor.TEAL]
        if light in addr18Lights:
            dacAddress = 0x18
            lightAddress = lightAddress << addr18Lights.index(light)
        else:
            dacAddress = 0x1A
            lightAddress = lightAddress << addr1ALights.index(light)
        
        # convert 0-100 to 0-2^8
        power = int((power_percent/100) * 255) & 0xFF
        #invert power (0xFF is 0% power, 0x00 is 100% power)
        power = ~power
        power_highnibble = (power & 0xF0) >> 4
        power_lownibble = power & 0x0F

        #form byte array to send to DAC
        cmd = bytearray([0x53, dacAddress, 0x03, lightAddress & 0x0F, power_highnibble | 0xF0, power_lownibble << 4, 0x50])

        #send command to DAC
        self.com.write(cmd)
        logging.info("Lumencore color {} set to {}%".format(light.name, power_percent))

    def get_IIC_temp(self):
        '''Gets the temperature of the IIC in degrees C
        '''
        cmd = bytearray([0x53, 0x91, 0x02, 0x50])
        self.com.write(cmd)
        time.sleep(0.1)
        temp = self.com.read(2)
        #we only want the Most Significant 11 bits
        temp = temp[1] << 3 | temp[0] >> 5
        #convert to degrees C
        temp = temp * 0.125
        return temp

if __name__ == '__main__':
    lampCom = serial.Serial('COM6', 9600, timeout=1, stopbits=serial.STOPBITS_ONE, parity=serial.PARITY_NONE, bytesize=serial.EIGHTBITS)
    l = Lumencore(lampCom)

    l.enable(LightColor.BLUE, ExcitationFilter.GREEN)
    l.set_power(100, LightColor.BLUE)
    time.sleep(1)

    l.enable(LightColor.RED, ExcitationFilter.GREEN)
    l.set_power(100, LightColor.RED)
    time.sleep(1)

    l.enable(LightColor.OFF, ExcitationFilter.GREEN)
    # l.set_power(48, LightColor.CYAN)
            


================================================
File: /holypipette/devices/manipulator/StageCalHelper.py
================================================
import time
import cv2
import numpy as np
from holypipette.devices.manipulator.microscope import Microscope
from holypipette.devices.manipulator import Manipulator
from holypipette.devices.camera import Camera
from threading import Thread
import math

class FocusHelper():
    '''A helper class to aid with microscope focusing
    '''
    
    FOCUSING_MAX_SPEED = 1000
    NORMAL_MAX_SPEED = 10000

    def __init__(self, microscope: Microscope, camera: Camera):
        self.microscope: Microscope = microscope
        self.camera : Camera = camera

    def autofocusContinuous(self, distance):
        '''tell the stage to go a certain (larger) distance at a low max speed.
           Take a bunch of pictures and determine focus score.  Finally,
           move the stage to the position with the best focus score 
        '''

        #move the microscope a certain distance forward
        commandedPos = self.microscope.position() + distance
        self.microscope.absolute_move(commandedPos)

        #start recording focus values and positions
        focusThread = FocusUpdater(self.microscope, self.camera)
        focusThread.start()

        #wait for the microscope to reach the pos
        posTimeArr = []
        currPos = self.microscope.position()
        while abs(currPos - commandedPos) > 0.3:
            currPos = self.microscope.position()
            posTimeArr.append((time.time(), currPos))
            time.sleep(0.1)

        posTimeArr = np.array(posTimeArr)

        #stop the focus recording thread
        focusThread.stop()

        #wait for focus thread to stop
        while not focusThread.didFinish:
            # print('waiting for thread finish...')
            time.sleep(0.01)

        #find index with best score
        bestIndex = np.argmax(focusThread.posFocusList[:, 1])

        #find results for that index
        bestScore = focusThread.posFocusList[bestIndex][1]
        bestPos = focusThread.posFocusList[bestIndex][0]
        
        #return best score, position
        return bestPos, bestScore

    def autofocus(self, dist=500):
        '''Attempts to auto focus the micrscope image by moving in the z-axis
        '''

        self.microscope.set_max_speed(self.FOCUSING_MAX_SPEED)
        initPos = self.microscope.position()
        bestForwardPos, bestForwardScore = self.autofocusContinuous(dist)
        
        self.microscope.set_max_speed(self.NORMAL_MAX_SPEED)
        self.microscope.absolute_move(initPos)
        self.microscope.wait_until_still()
        self.microscope.set_max_speed(self.FOCUSING_MAX_SPEED)

        bestBackwardPos, bestBackwardScore = self.autofocusContinuous(-dist)
        self.microscope.set_max_speed(self.NORMAL_MAX_SPEED)

        if bestBackwardScore < bestForwardScore:
            self.microscope.absolute_move(bestForwardPos)
        else:
            self.microscope.absolute_move(bestBackwardPos)

        self.microscope.wait_until_still()

class FocusUpdater(Thread):
    def __init__(self, microscope: Microscope, camera: Camera):
       Thread.__init__(self)

       self.isRunning : bool = True
       self.camera : Camera = camera
       self.microscope : Microscope = microscope
       self.lastFrame : int = 0
       self.posFocusList : list = []
       self.didFinish : bool = False

    def run(self):
        '''continuously read frames from camera, and record their focus and the microscope's z position.  Assumes constant velocity!
        '''
        while self.isRunning:
            while self.lastFrame == self.camera.get_frame_no() and self.isRunning:
                # print('waiting for new frame')
                time.sleep(0.01) #wait for a new frame to be read from the camera
            self.lastFrame = self.camera.get_frame_no()
            
            #get focus score from frame
            _, frametime, _, img = self.camera.raw_frame_queue[0]
            score = self._getFocusScore(img)

            #append to list
            self.posFocusList.append([self.microscope.position(), score])
        
        self.posFocusList = np.array(self.posFocusList)
        self.didFinish = True #create a flag when we creating the arr


    def _getFocusScore(self, image) -> float:
        '''Get a score stating how focused a given image is
        Higher Score == more focused image
        '''

        focusSize = 512
        x = image.shape[1]/2 - focusSize/2
        y = image.shape[0]/2 - focusSize/2
        crop_img = image[int(y):int(y+focusSize), int(x):int(x+focusSize)]

        xEdges = cv2.norm(cv2.Sobel(src=crop_img, ddepth=cv2.CV_32F, dx=1, dy=0, ksize=7))
        yEdges = cv2.norm(cv2.Sobel(src=crop_img, ddepth=cv2.CV_32F, dx=0, dy=1, ksize=7))
        score = xEdges ** 2 + yEdges ** 2
        # score = cv2.Laplacian(crop_img, cv2.CV_32F).var()
        
        return xEdges


    def stop(self):
        self.isRunning = False


class StageCalHelper():
    '''A helper class to aid with Stage Calibration
    '''
    
    CAL_MAX_SPEED = 1000
    NORMAL_MAX_SPEED = 10000

    def __init__(self, stage: Manipulator, camera: Camera, frameLag: int):
        self.stage : Manipulator = stage
        self.camera : Camera = camera
        self.lastFrameNo : int = None
        self.frameLag = frameLag

    def calibrateContinuous(self, distance, video=False):
        '''Tell the stage to go a certain distance at a low max speed.
           Take a bunch of pictures and run optical flow. Use optical flow information
           to create a linear transform from stage microns to image pixels.
           if set, video creates an mp4 of the optical flow running in the project directory.
        '''
        #move the microscope a certain distance forward and up
        currPos = self.stage.position()
        commandedPos = np.array([currPos[0] + distance, currPos[1] - distance])
        axes = np.array([0, 1], dtype=int)
        self.stage.absolute_move_group(commandedPos, axes)

        #wait for the microscope to reach the pos, recording frames
        framesAndPoses = []
        currPos = self.stage.position()
        startPos = currPos
        _, _, _, firstFrame = self.camera.raw_frame_queue[0]
        p0 = self.calcOpticalFlowP0(firstFrame)
        while abs(currPos[0] - commandedPos[0]) > 0.3 or abs(currPos[1] - commandedPos[1]) > 0.3:
            while self.lastFrameNo == self.camera.get_frame_no():
                time.sleep(0.05) #wait for a new frame to be read from the camera
            self.lastFrameNo = self.camera.get_frame_no()
            currPos = self.stage.position()

            #get latest img
            _, _, _, frame = self.camera.raw_frame_queue[0]

            framesAndPoses.append([frame.copy(), currPos[0] - startPos[0], currPos[1] - startPos[1]])

        #run optical flow on the recorded frames
        print('running optical flow...')
        imgPosStagePosList = []
        x_pix_total = 0
        y_pix_total = 0

        if video:
            out = cv2.VideoWriter('opticalFlow.mp4', -1, 10.0, (1024,1024))

        #calculate the average image
        avgImg = np.zeros_like(framesAndPoses[0][0], dtype=np.float64)
        for frame, _, _ in framesAndPoses:
            avgImg += frame
        avgImg = avgImg / len(framesAndPoses)
        avgImg = avgImg.astype(np.uint8)

        #subtract average from all frames
        for frame, _, _ in framesAndPoses:
            frame -= avgImg

        for i in range(len(framesAndPoses) - 1):
            currFrame, x_microns, y_microns = framesAndPoses[i + 1]
            lastFrame, last_x_microns, last_y_microns = framesAndPoses[i]

            p0 = self.calcOpticalFlowP0(lastFrame)

            x_pix, y_pix = self.calcOpticalFlow(lastFrame, currFrame, p0)
            x_pix_total += x_pix
            y_pix_total += y_pix

            if math.isnan(x_pix) or math.isnan(y_pix): #if no corners can be found with optical flow, nan could be returned.  Don't add this to the list
                continue

            if video:
                vidFrame = cv2.cvtColor(currFrame.copy(), cv2.COLOR_GRAY2BGR)
                cv2.line(vidFrame, (512,512), (512 + int(x_pix_total), 512 + int(y_pix_total)), (255,0,0), 3)
                cv2.line(vidFrame, (600,100), (600 + int(x_pix_total), 100 + int(y_pix_total)), (255,0,0), 3)
                cv2.line(vidFrame, (900,400), (900 + int(x_pix_total), 400 + int(y_pix_total)), (255,0,0), 3)
                out.write(vidFrame)


            imgPosStagePosList.append([x_pix_total, y_pix_total, x_microns, y_microns])
        imgPosStagePosList = np.array(imgPosStagePosList)
        

        if video:
            out.release()
        
        #for some reason, estimateAffinePartial2D only works with int64
        #we can multiply by 100, to preserve 2 decimal places without affecting rotation / scaling portion of affline transform
        imgPosStagePosList = (imgPosStagePosList).astype(np.int64)
        print(imgPosStagePosList)

        #compute affine transformation matrix
        mat, inVsOut = cv2.estimateAffinePartial2D(imgPosStagePosList[:,2:4], imgPosStagePosList[:,0:2])

        #fix intercept - set image center --> stage center
        mat[0,2] = 0
        mat[1,2] = 0

        print('completed optical flow. matrix:')
        print(mat)

        #return transformation matrix
        return mat

    def calcOpticalFlowP0(self, firstFrame):
        #params for corner detector
        feature_params = dict(maxCorners = 100,
                                qualityLevel = 0.1,
                                minDistance = 10,
                                blockSize = 10)
        p0 = cv2.goodFeaturesToTrack(firstFrame, 70, 0.05, 25)
        # p0 = cv2.goodFeaturesToTrack(firstFrame, mask = None, **feature_params)

        return p0
    
    def calcMotionTranslation(self, lastFrame, currFrame):
        warp_mode = cv2.MOTION_TRANSLATION
        warp_matrix = np.eye(2, 3, dtype=np.float32)
        criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 5000,  1e-10)

        #compute transformation for image translation
        (cc, warp_matrix) = cv2.findTransformECC (lastFrame, currFrame,warp_matrix, warp_mode, criteria)

        #get x, y translation (pixels)
        print(warp_matrix)
        x_pix = warp_matrix[0,2]
        y_pix = warp_matrix[1,2]

        print(x_pix, y_pix)

        return x_pix, y_pix

    def calcOpticalFlow(self, lastFrame, currFrame, p0):
        #params for optical flow
        lk_params = dict(winSize  = (20, 20),
                    maxLevel = 20)

        # calculate optical flow from first frame
        p1, st, err = cv2.calcOpticalFlowPyrLK(lastFrame, currFrame, p0, None, **lk_params)

        # Select good points
        if p1 is not None:
            good_new = p1[st==1]
            good_old = p0[st==1]
        
         #find median movement vector
        dMovement = good_new - good_old
        medianVect = np.median(dMovement, axis=0)
        
        return medianVect[0], medianVect[1]


    def calibrate(self, dist=500):
        '''Calibrates the microscope stage using optical flow and stage encoders to create a um -> pixels transformation matrix
        '''

        self.stage.set_max_speed(self.CAL_MAX_SPEED)
        # self.stage.set_max_accel(10)

        initPos = self.stage.position()
        print('starting optical flow')
        mat = self.calibrateContinuous(dist)
        # commandedPos = np.array([initPos[0] + 200, initPos[1] - 200])
        # axes = np.array([0, 1], dtype=int)
        # self.stage.absolute_move_group(commandedPos, axes)
        self.stage.wait_until_still()
        currPos = self.stage.position()
        
        self.stage.set_max_speed(self.NORMAL_MAX_SPEED)
        self.stage.absolute_move(initPos)
        self.stage.wait_until_still()

        return mat

================================================
File: /holypipette/devices/manipulator/fakemanipulator.py
================================================
"""
A fake device useful for development.
It has 9 axes, numbered 1 to 9.
"""
from __future__ import print_function
from __future__ import absolute_import
from .manipulator import Manipulator

from numpy import zeros, clip, pi
import time
import math

__all__ = ['FakeManipulator']

class FakeManipulator(Manipulator):
    def __init__(self, min=None, max=None):
        Manipulator.__init__(self)
        # Minimum and maximum positions for all axes
        self.min = min
        self.max = max
        if all([min is not None, max is not None]):
            if len(min) != len(max):
                raise ValueError('min/max needs to be the same length (# of axes)')

        self.num_axes = len(min)

        #continuous movement values
        self.x = zeros(self.num_axes) # Position of all axes
        self.set_max_speed(10000)
        self.setpoint = self.x.copy()
        self.speeds = zeros(self.num_axes)
        self.cmd_time = [None] * self.num_axes

    def set_max_speed(self, speed : int):
        self.max_speed = speed / 1000 * 82 #for some reason, when you specify 1000 as the max speed, it actually moves at 82 um/s

    def position(self, axis=None):
        '''
        Current position along an axis.

        Parameters
        ----------
        axis : axis number

        Returns
        -------
        The current position of the device axis in um.
        '''

        if axis == None:
            for i in range(self.num_axes):
                self.update_axis(i+1)
            return self.x
        else:
            self.update_axis(axis)
            return self.x[axis-1]

    def update_axis(self, axis):
        '''Updates the position on the given axis if a command is being executed.
        Returns True if the command is still running, False otherwise.
        '''

        #Nothing commanded on this axis
        if self.cmd_time[axis-1] is None:
            return False

        #see if the last command is still running
        dt = time.time() - self.cmd_time[axis-1]
        self.cmd_time[axis-1] = time.time()

        #we're moving forward, but haven't reached the setpoint
        if (self.x[axis-1] + self.speeds[axis-1] * dt < self.setpoint[axis-1]) and self.speeds[axis-1] > 0:
            self.x[axis-1] = self.x[axis-1] + self.speeds[axis-1] * dt
            return True
        
        #we're moving backward, but haven't reached the setpoint
        if (self.x[axis-1] + self.speeds[axis-1] * dt) > self.setpoint[axis-1] and self.speeds[axis-1] < 0:
            self.x[axis-1] = self.x[axis-1] + self.speeds[axis-1] * dt
            return True

        #we've reached the setpoint
        self.speeds[axis-1] = 0
        self.cmd_time[axis-1] = None
        self.x[axis-1] = self.setpoint[axis-1]
        return False

    def absolute_move(self, x, axis, speed=None):
        '''
        Moves the device axis to position x.

        Parameters
        ----------
        axis: axis number
        x : target position in um.
        '''

        if self.update_axis(axis):
            print(f'axis: {axis}\tpos: {self.x[axis-1]}\tspeed: {self.x[axis-1]:.2f}\tsetpoint: {self.setpoint[axis-1]}\tfail 1')
            raise RuntimeError("Cannot move while another command is running")

        if self.min is None:
            self.setpoint[axis-1] = x
        else:
            self.setpoint[axis-1] = clip(x, self.min[axis-1], self.max[axis-1])
        
        self.cmd_time[axis-1] = time.time()
        self.speeds[axis-1] = self.max_speed * math.copysign(1, x - self.x[axis-1])


    def absolute_move_group(self, x, axes, speed=None):
        for xi,axis in zip(x,axes):
            print(axis, xi)
            self.absolute_move(xi, axis)
    
    def wait_until_still(self, axes=None):
        for i in range(self.num_axes):
            while self.update_axis(i+1):
                time.sleep(0.1)

================================================
File: /holypipette/devices/manipulator/manipulator.py
================================================
"""
Generic Manipulator class for manipulators.

To make a new device, one must implement at least:
* position
* absolute_move

TODO:
* Add minimum and maximum for each axis
"""
import time

from numpy import array

from holypipette.controller import TaskController

__all__ = ['Manipulator', 'ManipulatorError']


class ManipulatorError(Exception):
    def __init__(self, message = 'Device is not calibrated'):
        self.message = message

    def __str__(self):
        return self.message


class Manipulator(TaskController):
    def position(self, axis=None):
        '''
        Current position along an axis.

        Parameters
        ----------
        axis : axis number

        Returns
        -------
        The current position of the device axis in um.
        '''
        return 0. # fake

    def save_state(self):
        self.saved_state = self.position()

    def delete_state(self):
        self.saved_state = None

    def recover_state(self):
        self.absolute_move(self.saved_state)

    def absolute_move(self, x, axis=None, speed=None):
        '''
        Moves the device axis to position x.

        Parameters
        ----------
        axis: axis number
        x : target position in um.
        '''
        pass

    def relative_move(self, x, axis, speed=None):
        '''
        Moves the device axis by relative amount x in um.

        Parameters
        ----------
        axis: axis number
        x : position shift in um.
        '''
        if speed is not None:
            self.absolute_move(self.position(axis)+x, axis, speed)
        else:
            self.absolute_move(self.position(axis)+x, axis)

    def position_group(self, axes):
        '''
        Current position along a group of axes.

        Parameters
        ----------
        axes : list of axis numbers

        Returns
        -------
        The current position of the device axis in um (vector).
        '''
        return array([self.position(axis) for axis in axes])

    def absolute_move_group(self, x, axes, speed=None):
        '''
        Moves the device group of axes to position x.

        Parameters
        ----------
        axes : list of axis numbers
        x : target position in um (vector or list).
        '''
        for xi,axis in zip(x,axes):
            self.absolute_move(xi, axis)

    def relative_move_group(self, x, axes, speed=None):
        '''
        Moves the device group of axes by relative amount x in um.

        Parameters
        ----------
        axes : list of axis numbers
        x : position shift in um (vector or list).
        '''
        self.absolute_move_group(array(self.position_group(axes))+array(x), axes)

    def stop(self, axis):
        """
        Stops current movements.
        """
        pass

    def wait_until_still(self, axes = None):
        """
        Waits until motors have stopped.

        Parameters
        ----------
        axes : list of axis numbers
        """
        previous_position = self.position_group(axes)
        new_position = None
        while new_position is None or array(previous_position != new_position).any():
            previous_position = new_position
            new_position = self.position_group(axes)
            self.sleep(0.1)  # 100 ms

    def wait_until_reached(self, position, axes = None, precision = 0.5, timeout = 10):
        """
        Waits until position is reached within precision, and raises an error if the
        target is not reached after the time out, unless the manipulator is still moving.

        Parameters
        ----------
        position : target position in micrometer
        axes : axis number of list of axis numbers
        precision : precision in micrometer
        timeout : time out in second
        """
        axes = array(axes)
        position = array(position)

        current_position = position
        previous_position = current_position
        t0 = time.time()
        while (abs(current_position-position)>precision).any():
            if (time.time()-t0>timeout) & (array(previous_position == current_position).all()):
                raise ManipulatorError("Time out while waiting for manipulator to reach target position.")
            previous_position = current_position
            if len(axes) == 1:
                current_position = array([self.position(axes[0])])
            else:
                current_position = self.position_group(axes)
            self.sleep(0.1)  # 100 ms

    def set_max_speed(self, speed):
        ''' sets the max speed of the device, (if possible)
        '''
        raise NotImplementedError('set_max_speed not implemented')

    def set_max_accel(self, accel):
        ''' sets the max acceleration of the device, (if possible)
        '''
        raise NotImplementedError('set_max_accel not implemented')

================================================
File: /holypipette/devices/manipulator/__init__.py
================================================
from __future__ import absolute_import
from .manipulator import ManipulatorError, Manipulator
from .fakemanipulator import *
from .sensapexWrapper import *
from .manipulatorunit import *
from .scientificaSerial import ScientificaSerialEncoder, ScientificaSerialNoEncoder
from .calibratedunit import *
from .microscope import *
import warnings

================================================
File: /holypipette/devices/manipulator/calibratedunit.py
================================================
# coding=utf-8
"""
A class to handle a manipulator unit with coordinates calibrated to the reference system of a camera.
It contains methods to calibrate the unit.

Should messages be issued?
Also ranges should be taken into account

Should this be in devices/ ? Maybe in a separate calibration folder
"""
from __future__ import print_function
from __future__ import absolute_import
from typing import List
from .manipulatorunit import *
from numpy import (array, zeros, dot, arange, vstack, sign, pi, arcsin,
                   mean, std, isnan)
import cv2
import numpy as np
import time
import math
from holypipette.devices.manipulator import *

from numpy.linalg import inv, pinv, norm
from threading import Thread
from .StageCalHelper import FocusHelper, StageCalHelper
from .PipetteCalHelper import PipetteCalHelper, PipetteFocusHelper

__all__ = ['CalibratedUnit', 'CalibrationError', 'CalibratedStage']

verbose = True

##### Calibration parameters #####
from holypipette.config import Config, NumberWithUnit, Number, Boolean


class CalibrationConfig(Config):
    position_update = NumberWithUnit(1000, unit='ms',
                                     doc='dt for updating displayed pos.',
                                     bounds=(0, 10000))
    
    autofocus_dist = NumberWithUnit(500, unit='um',
                                     doc='z dist to scan for autofocusing.',
                                     bounds=(100, 5000))
    
    stage_diag_move = NumberWithUnit(500, unit='um',
                                     doc='x, y dist to move for stage cal.',
                                     bounds=(0, 10000))
    
    frame_lag = NumberWithUnit(4, unit='frames',
                                     doc='number of frames between for computing change with optical flow',
                                     bounds=(1, 20))
    
    pipette_diag_move = NumberWithUnit(200, unit='um',
                                     doc='x, y dist to move for pipette cal.',
                                     bounds=(50, 10000))
    

    categories = [('Stage Calibration', ['autofocus_dist', 'stage_diag_move', 'frame_lag']),
                  ('Pipette Calibration', ['pipette_diag_move']),
                  ('Display', ['position_update'])]


class CalibrationError(Exception):
    def __init__(self, message='Device is not calibrated'):
        self.message = message

    def __str__(self):
        return self.message


class CalibratedUnit(ManipulatorUnit):
    def __init__(self, unit, stage=None, microscope=None, camera=None,
                 config=None):
        '''
        A manipulator unit calibrated to a fixed reference coordinate system.
        The stage refers to a platform on which the unit is mounted, which can
        be None.

        Parameters
        ----------
        unit : ManipulatorUnit for the (XYZ) unit
        stage : CalibratedUnit for the stage
        microscope : ManipulatorUnit for the microscope (single axis)
        camera : a camera, ie, object with a snap() method (optional, for visual calibration)
        '''
        ManipulatorUnit.__init__(self, unit.dev, unit.axes)
        self.saved_state_question = ('Move manipulator and stage back to '
                                     'initial position?')
        if config is None:
            config = CalibrationConfig(name='Calibration config')
        self.config = config
        if stage is None: # In this case we assume the unit is on a fixed element.
            self.stage = FixedStage()
            self.fixed = True
        else:
            self.stage = stage
            self.fixed = False
        self.microscope = microscope
        self.camera = camera

        self.calibrated = False
        self.must_be_recalibrated = False
        self.up_direction = [-1 for _ in range(len(unit.axes))] # Default up direction, determined during calibration

        self.pipette_position = None
        self.photos = None
        self.photo_x0 = None
        self.photo_y0 = None

        # Matrices for passing to the camera/microscope system
        self.M = zeros((3,len(unit.axes))) # stage units (in micron) to camera
        self.Minv = zeros((len(unit.axes),3)) # Inverse of M
        self.r0 = zeros(3) # offset for px -> um conversion
        self.r0_inv = zeros(3) # offset for um -> px conversion
        self.unit = unit

        self.emperical_offset = np.zeros(3) # offset for pipette position in px based on deep learning model

        #setup pipette calibration helper class
        self.pipetteCalHelper = PipetteCalHelper(unit, self.microscope, camera, stage)
        self.pipetteFocusHelper = PipetteFocusHelper(unit, camera)

    def save_state(self):
        if self.stage is not None:
            self.stage.save_state()
        if self.microscope is not None:
            self.microscope.save_state()
        self.saved_state = self.position()

    def delete_state(self):
        if self.stage is not None:
            self.stage.delete_state()
        if self.microscope is not None:
            self.microscope.delete_state()
        self.saved_state = None

    def recover_state(self):
        if self.stage is not None:
            self.stage.recover_state()
        if self.microscope is not None:
            self.microscope.recover_state()
        self.absolute_move(self.saved_state)

    def pixels_to_um(self, pos_pixels):
        '''
        Converts pixel coordinates to pipette um.
        '''
        if self.Minv.shape[1] == 2: #2x2 stage movement
            xy = dot(self.Minv, pos_pixels[0:2]) + self.r0_inv[0:2]
            return np.array([xy[0], xy[1], 0])
        else: #3x3 pipette movement
            return dot(self.Minv, pos_pixels) + self.r0_inv
    
    def pixels_to_um_relative(self, pos_pixels):
        '''
        Converts pixel coordinates to pipette um.
        '''
        if self.Minv.shape[1] == 2: #2x2 stage movement
            xy = dot(self.Minv, pos_pixels[0:2])
            return np.array([xy[0], xy[1], 0])
        else: #3x3 pipette movement
            return dot(self.Minv, pos_pixels)
    
    def um_to_pixels(self, pos_microns):
        '''
        Converts um to pixel coordinates.
        '''
        return dot(self.M, pos_microns) + self.r0 - self.emperical_offset
    
    def um_to_pixels_relative(self, pos_microns):
        '''
        Converts um to pixel coordinates.
        '''
        return dot(self.M, pos_microns)

    def reference_position(self, include_offset = True):
        '''
        Position of the pipette in pixels (camera coordinate frame)

        Returns
        -------
        The current position in um as an XYZ vector.
        '''
        # if not self.calibrated:
        #     raise CalibrationError
        pos_um = self.position() # position vector (um) in manipulator unit system
        if include_offset:
            pos_pixels = self.um_to_pixels(pos_um) + self.stage.reference_position() + self.emperical_offset
        else:
            pos_pixels = self.um_to_pixels(pos_um) + self.stage.reference_position()
        return pos_pixels # position vector (pixels) in camera system

    def reference_move(self, pos_pixels, yolo_correction=True):
        '''
        Moves the unit to position pos_pixels in reference camera system, without moving the stage.

        Parameters
        ----------
        r : XYZ position vector in um
        safe : if True, moves the Z axis first or last, so as to avoid touching the coverslip
        '''

        if np.isnan(np.array(pos_pixels)).any():
            raise RuntimeError("can not move to nan location.")
        
        print(f'Move position: {pos_pixels}')
        print(f'Reference position: {self.reference_position()}')
        pos_micron = self.pixels_to_um(pos_pixels - self.stage.reference_position()) # position vector (um) in manipulator unit system

        self.absolute_move(pos_micron)
        self.wait_until_still()

        if isinstance(self, CalibratedStage) or isinstance(self, FixedStage):
            return
        
        if not yolo_correction:
            return
        
        emperical_poses = []
        for i in range(10):
            _, _, _, frame = self.camera.raw_frame_queue[0]
            pos = self.pipetteCalHelper.pipetteFinder.find_pipette(frame)
            if pos != None:
                emperical_poses.append([pos[0], pos[1]])
        
        if len(emperical_poses) == 0:
            print('No pipette found in image, can\'t run correction')
            return
        
        pos_pixels_emperical = np.median(emperical_poses, axis=0)
        pos_pixels_theoretical = self.reference_position()[0:2]

        print('Theoretical position: ', pos_pixels_theoretical)
        print('Emperical position: ', pos_pixels_emperical)
        print('abs move completed!')

        #update offset
        self.emperical_offset[0:2] = pos_pixels_emperical - pos_pixels_theoretical
        print('Emperical offset (pix): ', self.emperical_offset)
              
        correction = self.pixels_to_um_relative(self.emperical_offset)

        #recalculate setpoint after offset correction
        pos_micron = self.pixels_to_um(pos_pixels - self.stage.reference_position()) - correction

        #move to emperical position
        self.absolute_move(pos_micron, blocking=True)

    def focus(self):
        '''
        Move the microscope so as to put the pipette tip in focus
        '''
        if not self.calibrated:
            raise CalibrationError('Pipette not calibrated')
        if self.must_be_recalibrated:
            raise CalibrationError('Pipette offsets must be recalibrated')
        
        self.microscope.absolute_move(self.reference_position()[2] + 200)
        self.microscope.wait_until_still()
        self.microscope.absolute_move(self.reference_position()[2])
        self.microscope.wait_until_still()

    def autofocus_pipette(self):
        '''Use the microscope image to put the pipette in focus
        '''
        print('Autofocusing pipette')
        self.pipetteFocusHelper.focus()

    def safe_move(self, r, yolo_correction=True):
        '''
        Moves the device to position x (an XYZ vector) in a way that minimizes
        interaction with tissue.

        If the movement is down, the manipulator is first moved horizontally,
        then along the pipette axis.
        If the movement is up, a direct move is done.

        Parameters
        ----------
        r : target position in um, an (X,Y,Z) vector
        withdraw : in um; if not 0, the pipette is withdrawn by this value from the target position x
        recalibrate : if True, pipette is recalibrated 1 mm before its target
        '''
        if not self.calibrated:
            raise CalibrationError
        if self.must_be_recalibrated:
            raise CalibrationError('Pipette offsets must be recalibrated')

        # r from pyQt has origin at the center of the image, move origin to the top left corner (as expected by calibration)
        r = np.array(r)
        r = r + np.array([self.camera.width // 2, self.camera.height // 2, 0])

        self.reference_move(r, yolo_correction) # Or relative move in manipulator coordinates, first axis (faster)


    def pixel_per_um(self, M=None):
        '''
        Returns the objective magnification in pixel per um, calculated for each manipulator axis.
        '''
        if M is None:
            M = self.M
        p = []
        for axis in range(len(self.axes)):
            # The third axis is in um, the first two in pixels, hence the odd formula
            p.append(((M[0,axis]**2 + M[1,axis]**2))**.5) #TODO: is this correct? 
        return p
    
    def record_cal_point(self):
        self.pipetteCalHelper.record_cal_point()

    def finish_calibration(self):
        '''
        Automatic calibration of the pipette manipulator.
        '''
        
        # move the pipette and create a calibration matrix (pix -> um)
        mat = self.pipetteCalHelper.calibrate()
        
        #make matrix 4x4 for inverse
        mat = np.vstack((mat, np.array([0,0,0,1])))

        self.stage.pipette_cal_position = self.stage.position() #update the position the pipette was calibrated at

        # *** Compute the (pseudo-)inverse ***
        mat_inv = pinv(mat)

        print(f'calibration matrix: {mat}')
        print('inv : ', mat_inv)

        # store r0 and r0_inv
        self.r0 = mat[0:3, 3] #um -> pixels offset
        self.r0_inv = mat_inv[0:3, 3] #pixels -> um offset

        #just 3x3 portion of M for self.M
        self.M = mat[0:3, 0:3]

        #just 3x3 portion of Minv
        self.Minv = mat_inv[0:3, 0:3]


        #check for nan values (invalid cal)
        if isnan(self.M).any() or isnan(self.Minv).any():
            raise CalibrationError('Matrix contains NaN values')

        print('Calibration Successful!')
        print('M: ', self.M)
        print('r0: ', self.r0)
        print()
        print('Minv: ', self.Minv)
        print('r0_inv: ', self.r0_inv)

        self.calibrated = True
        self.must_be_recalibrated = False
    

    def recalibrate_pipette(self):
        '''recalibrate pipette offset while keeping matrix
        '''
        if self.M is None or self.Minv is None:
            raise Exception("initial calibration required for single point recalibration!")
        
        print('recalculating piptte offsets...')
        emperical_poses = []
        for i in range(10):
            _, _, _, frame = self.camera.raw_frame_queue[0]
            pos = self.pipetteCalHelper.pipetteFinder.find_pipette(frame)
            if pos != None:
                emperical_poses.append([pos[0], pos[1]])
        
        if len(emperical_poses) == 0:
            print('No pipette found in image, can\'t run correction')
            return
        
        new_offset = np.zeros(3)
        pos_pixels_emperical = np.median(emperical_poses, axis=0)
        pos_pixels_emperical = np.append(pos_pixels_emperical, self.microscope.position())
        new_offset = pos_pixels_emperical - self.um_to_pixels_relative(self.dev.position()) - self.stage.reference_position()
        print('Old offsets: ', self.r0, self.r0_inv)

        self.r0 = np.array(new_offset)

        #create r0_inv
        #first create homogenous matrix

        homogenous_mat = np.zeros((4,4))
        homogenous_mat[0:3, 0:3] = self.M
        homogenous_mat[0:3, 3] = self.r0
        homogenous_mat[3, 3] = 1

        #invert
        homogenous_mat_inv = pinv(homogenous_mat)

        #get r0_inv
        self.r0_inv = homogenous_mat_inv[0:3, 3]
        self.calibrated = True
        self.must_be_recalibrated = False

        print('New offsets: ', self.r0, self.r0_inv)


    def save_configuration(self):
        '''
        Outputs configuration in a dictionary.
        '''
        config = {'up_direction' : self.up_direction,
                  'M' : self.M,
                  'r0' : self.r0}

        return config

    def load_configuration(self, config):
        '''
        Loads configuration from dictionary config.
        Variables not present in the dictionary are untouched.
        '''
        self.M = config.get('M', self.M)
        self.Minv = pinv(self.M)
        self.r0 = np.zeros(self.M.shape[0])
        self.r0_inv = np.zeros(self.M.shape[0])
        if self.M.shape[0] == 3:
            self.must_be_recalibrated = True #the pipette offsets need to be recalibrated upon reboot.
        self.calibrated = True

class CalibratedStage(CalibratedUnit):
    '''
    A horizontal stage calibrated to a fixed reference coordinate system.
    The optional stage refers to a platform on which the unit is mounted, which can
    be None.
    The stage is assumed to be parallel to the focal plane (no autofocus needed)

    Parameters
    ----------
    unit : ManipulatorUnit for this stage
    stage : CalibratedUnit for a stage on which this stage might be mounted
    microscope : ManipulatorUnit for the microscope (single axis)
    camera : a camera, ie, object with a ``snap()`` method (optional, for visual calibration)
    '''
    def __init__(self, unit, stage=None, microscope=None, camera=None,
                 config=None):
        CalibratedUnit.__init__(self, unit, stage, microscope, camera,
                                config=config)
        self.saved_state_question = 'Move stage back to initial position?'

        self.focusHelper = FocusHelper(microscope, camera)
        self.stageCalHelper = StageCalHelper(unit, camera, self.config.frame_lag)
        self.pipette_cal_position = np.zeros(2)
        self.unit = unit

        # It should be an XY stage, ie, two axes
        if len(self.axes) != 2:
            raise CalibrationError('The unit should have exactly two axes for horizontal calibration.')

    def reference_position(self):
        '''Returns the offset (in pixels) of the stage compared to where it was when calibrated
        '''
        #get delta in um
        posDelta = self.unit.position()

        #convert to pixels
        posDelta = dot(self.M, posDelta) + self.r0

        #just get x and y (only concerned with pixels)
        posDelta = posDelta[:2]

        #append 0 for z
        posDelta = np.append(posDelta, 0)

        return posDelta

    def reference_move(self, r, yolo_correction=None):
        if len(r)==2: # Third coordinate is actually not useful
            r3D = zeros(3)
            r3D[:2] = r
        else:
            r3D = r
        CalibratedUnit.reference_move(self, r3D) # Third coordinate is ignored

    def reference_relative_move(self, pos_pix):
        '''
        Moves the unit by vector r in reference camera system, without moving the stage.

        Parameters
        ----------
        pos_pix : position in pixels
        '''
        if not self.calibrated:
            raise CalibrationError
        if self.must_be_recalibrated:
            raise CalibrationError('Pipette offsets must be recalibrated')

            
        pos_microns = dot(self.Minv, pos_pix)
        self.relative_move(pos_microns)

    def calibrate(self):
        '''
        Automatic calibration for a horizontal XY stage

        '''
        if not self.stage.calibrated:
            self.stage.calibrate()

        self.info('Preparing stage calibration')
        # self.info("auto focusing microscope...")
        # self.focusHelper.autofocus(dist=self.config.autofocus_dist)
        # self.info("Finished focusing.")

        # use LK optical flow to determine transformation matrix
        mat = self.stageCalHelper.calibrate(dist=self.config.stage_diag_move)
        mat = np.append(mat, np.array([[0,0,1]]), axis=0)
        mat_inv = pinv(mat)

        # store r0 and r0_inv
        self.r0 = mat[0:2, 2] #um -> pixels offset
        self.r0_inv = mat_inv[0:2, 2] #pixels -> um offset

        #for M and Minv, we only want the upper 2x2 matrix (b/c assumption that z axis is equivilant), the rest of the matrix is just the identity
        self.M = mat[0:2, 0:2]
        self.Minv = mat_inv[0:2, 0:2]
        self.calibrated = True
        self.must_be_recalibrated = False

        self.info('Stage calibration done')



    def mosaic(self, width = None, height = None):
        '''
        Takes a photo mosaic. Current position corresponds to
        the top left corner of the collated image.
        Stops when the unit's position is out of range, unless
        width and height are specified.

        Parameters
        ----------
        width : total width in pixel (optional)
        height : total height in pixel (optional)

        Returns
        -------
        A large image of the mosaic.
        '''
        u0=self.position()
        if width == None:
            width = self.camera.width * 4
        if height == None:
            height = self.camera.height * 4

        dx, dy = self.camera.width, self.camera.height
        # Number of moves in each direction
        nx = 1+int(width/dx)
        ny = 1+int(height/dy)
        # Big image
        big_image = zeros((ny*dy,nx*dx))

        column = 0
        xdirection = 1 # moving direction along x axis

        try:
            for row in range(ny):
                img, _ = self.camera.snap()
                big_image[row*dy:(row+1)*dy, column*dx:(column+1)*dx] = img
                for _ in range(1,nx):
                    column+=xdirection
                    self.reference_relative_move([-dx*xdirection,0,0]) # sign: it's a compensatory move
                    self.wait_until_still()
                    self.sleep(0.1)
                    img, _ = self.camera.snap()
                    big_image[row * dy:(row + 1) * dy, column * dx:(column + 1) * dx] = img
                if row<ny-1:
                    xdirection = -xdirection
                    self.reference_relative_move([0,-dy,0])
                    self.wait_until_still()
        finally: # move back to initial position
            self.absolute_move(u0)

        cv2.imwrite('mosaic.png', big_image)

        return big_image

class FixedStage(CalibratedUnit):
    '''
    A stage that cannot move. This is used to simplify the code.
    '''
    def __init__(self):
        self.stage = None
        self.microscope = None
        self.r = array([0.,0.,0.]) # position in reference system
        self.u = array([0.,0.]) # position in stage system
        self.calibrated = True

    def position(self):
        return self.u

    def reference_position(self):
        return self.r

    def reference_move(self, r):
        # The fixed stage cannot move: maybe raise an error?
        pass

    def absolute_move(self, x, axis = None):
        pass

================================================
File: /holypipette/devices/manipulator/sensapexWrapper.py
================================================
from sensapex import UMP
import numpy as np
from ctypes import c_int, c_float, byref
import math
import time

from holypipette.devices.manipulator.manipulator import Manipulator

class SensapexManip(Manipulator):
    '''A wrapper class to interface between the sensapex python library and the holypipette minipulator classes
    '''
    
    def __init__(self, deviceID = None):
        Manipulator.__init__(self)
        self.ump = UMP.get_ump()

        # setup device ID
        if deviceID == None:
            umpList = self.ump.list_devices()
            assert(len(umpList) == 1, "must specify sensapex ump device id if there is more than 1 connected!")
            self.deviceID = umpList[0] #if there's only 1 device connected, use it
        else:
            self.deviceID = deviceID

        self.max_speed = 5000 # "feels good" default value
        self.max_acceleration = 1 # "feels good" default value
        self.armAngle = math.radians(-self._get_axis_angle())

    def position(self, axis=None):
        raw_pos = self.raw_position()
        if axis == None:
            return raw_pos
        else:
            return raw_pos[axis-1]

    def raw_position(self, axis=None):
        return self.ump.get_pos(self.deviceID, timeout=1)

    def absolute_move(self, x, axis, speed=None):
        setpoint = np.nan * np.ones(3)
        if axis is not None:
            setpoint[axis-1] = x
        else:
            setpoint = x

        print("moving to: {}".format(setpoint))
        speed = self.max_speed if speed is None else speed

        self.ump.goto_pos(self.deviceID, setpoint, speed, max_acceleration=self.max_acceleration, linear=True)


    def absolute_move_group(self, x, axes, speed=None):
        setpoint = np.nan * np.ones(3)
        for axis in axes:
            setpoint[axis-1] = x[axis-1]
        
        speed = self.max_speed if speed is None else speed

        self.ump.goto_pos(self.deviceID, setpoint, speed, max_acceleration=self.max_acceleration, linear=True)

        
    def stop(self, axis):
        """
        Stops current movements.
        """
        self.ump.stop()

    def _get_axis_angle(self):
        angle = c_float()
        rVal = self.ump.call("ump_get_axis_angle", self.deviceID, byref(angle))
        return angle.value

    def set_max_speed(self, speed):
        self.max_speed = speed
    
    def set_max_accel(self, accel):
        self.max_acceleration = accel

================================================
File: /holypipette/devices/manipulator/manipulatorunit.py
================================================
"""
A class for access to a particular unit managed by a device.
It is essentially a subset of a Manipulator
"""
from __future__ import absolute_import

from numpy import ones, arange
import numpy as np

from .manipulator import Manipulator

__all__ = ['ManipulatorUnit']


class ManipulatorUnit(Manipulator):
    def __init__(self, dev, axes):
        '''
        Parameters
        ----------
        dev : underlying device
        axes : list of 3 axis indexes
        '''
        Manipulator.__init__(self)
        self.dev = dev
        self.axes = axes
        # Motor ranges in um; by default +- one meter
        self.min = -ones(len(axes))*1e6
        self.max = ones(len(axes))*1e6

    def position(self, axis = None):
        '''
        Current position along an axis.

        Parameters
        ----------
        axis : axis number starting at 0; if None, all XYZ axes

        Returns
        -------
        The current position of the device axis in um.
        '''
        if axis is None: # all positions in a vector
            #return array([self.dev.position(self.axes[axis]) for axis in range(len(self.axes))])
            return self.dev.position_group(self.axes)
        else:
            return self.dev.position(self.axes[axis])

    def absolute_move(self, x, axis = None, blocking=False, speed=None):
        '''
        Moves the device axis to position x in um.

        Parameters
        ----------
        axis : axis number starting at 0; if None, all XYZ axes
        x : target position in um.
        '''
        if axis is None:
            # then we move all axes
            if blocking:
                for i, axis in enumerate(self.axes):
                    self.dev.absolute_move(x[i], axis, speed)
                    self.dev.wait_until_still([axis])
            else:
                self.dev.absolute_move_group(x, self.axes, speed)
        else:
            self.dev.absolute_move(x, self.axes[axis], speed)
            if blocking:
                self.dev.wait_until_still([self.axes[axis]])
        #self.sleep(.05)

    def absolute_move_group(self, x, axes, speed=None):
        '''
        Moves the device axes to positions x in um.
        '''
        
        self.dev.absolute_move_group(x, np.array(self.axes)[axes], speed)
        #self.sleep(.05)

    def relative_move(self, x, axis = None, speed=None):
        '''
        Moves the device axis by relative amount x in um.

        Parameters
        ----------
        axis : axis number starting at 0; if None, all XYZ axes
        x : position shift in um.
        '''
        if axis is None:
            self.dev.relative_move_group(x, self.axes, speed)
        else:
            self.dev.relative_move(x, self.axes[axis], speed)
        # self.sleep(.05)

    def absolute_move_group_velocity(self, vel, axes):
        '''
        Moves the device axes to positions x in um.
        '''
        
        self.dev.absolute_move_group_velocity(vel, np.array(self.axes)[axes])
        # self.sleep(.005)

    def stop(self, axis = None):
        """
        Stop current movements.
        """
        if axis is None:
            # then we stop all axes
            for i, axis in enumerate(self.axes):
                self.dev.stop(axis)
        else:
            self.dev.stop(self.axes[axis])

    def wait_until_still(self, axes = None):
        """
        Waits for the motors to stop.
        """
        if axes is None: # all axes
            axes = arange(len(self.axes))
        if hasattr(axes, '__len__'):  # is that useful?
            for i in axes:
                self.wait_until_still(i)
        else:
            self.dev.wait_until_still([self.axes[axes]])
        self.sleep(.05)

    def wait_until_reached(self, position, axes=None, precision=0.5, timeout=10):
        """
        Waits until position is reached within precision, and raises an error if the
        target is not reached after the time out, unless the manipulator is still moving.

        Parameters
        ----------
        position : target position in micrometer
        axes : axis number of list of axis numbers
        precision : precision in micrometer
        timeout : time out in second
        """
        self.dev.wait_until_reached(position, axes, precision, timeout)

    def set_max_speed(self, speed):
        self.dev.set_max_speed(speed)
    
    def set_max_accel(self, accel):
        self.dev.set_max_accel(accel)

================================================
File: /holypipette/devices/manipulator/scientificaSerial.py
================================================

import serial
from .manipulator import Manipulator
import time
import threading

__all__ = ['ScientificaSerial']

class SerialCommands():
    GET_X_POS = 'PX\r'
    GET_Y_POS = 'PY\r'
    GET_Z_POS = 'PZ\r'
    GET_X_Y_Z = '\r'
    GET_MAX_SPEED = 'TOP\r'
    GET_MAX_ACCEL = 'ACC\r'
    GET_IS_BUSY = 's\r'

    SET_X_Y_POS_ABS = 'abs {} {}\r'
    SET_X_Y_POS_REL = 'rel {} {}\r'
    SET_X_Y_Z_POS_ABS = 'abs {} {} {}\r'
    SET_X_Z_POS_REL = 'rel {} {}\r'
    

    SET_Z_POS = 'absz {}\r'
    SET_MAX_SPEED = 'TOP {}\r'
    SET_MAX_ACCEL = 'ACC {}\r'

    SET_X_Y_Z_VEL = 'VJ {} {} {}\r'

    STOP = 'STOP\r'

class ScientificaSerialEncoder(Manipulator):

    def __init__(self, comPort: serial.Serial, zAxisComPort):
        self.comPort : serial.Serial = comPort

        self.zAxisComPort : serial.Serial = zAxisComPort
        self.stageUnitsPerEncoderPulse = 1.45
        self.encoderZ = 0

        self._lock = threading.Lock()
        self.current_pos = [0, 0, 0]

        self.set_max_accel(100)
        self.set_max_speed(10000)

        #start constantly polling position in a new thread
        self._polling_thread = threading.Thread(target=self.update_pos_continuous, daemon=True)
        self._polling_thread.start()
        self._polling_thread.deamon = True
    
    def set_max_speed(self, speed):
        '''Sets the max speed for the Scientifica Stage.  
           It seems like the range for this is around (1000, 100000)
        '''
        self._sendCmd(SerialCommands.SET_MAX_SPEED.format(int(speed)))

    def set_max_accel(self, accel):
        '''Sets the max acceleration for the Scientifica Stage.
           It seems like the range for this is around (10, 10000)
        '''
        self._sendCmd(SerialCommands.SET_MAX_ACCEL.format(int(accel)))

    def __del__(self):
        self.comPort.close()

    def _sendCmd(self, cmd):
        '''Sends a command to the stage and returns the response
        '''

        self._lock.acquire()
        self.comPort.write(cmd.encode())
        resp = self.comPort.read_until(b'\r') #read reply to message
        resp = resp[:-1]
        self._lock.release()

        return resp.decode()

    def position(self, axis=None):
        if axis == 1:
            return self.current_pos[0]
        if axis == 2:
            return self.current_pos[1]
        if axis == 3:
            return self.encoderZ
        if axis == None:
            return self.current_pos
        
    def update_pos_continuous(self, freq=10):
        '''constantly polls the device's position and updates the current_pos variable
        '''
        while True:
            startTime = time.time()
            self.zAxisComPort.read_all()
            self.zAxisComPort.read_until(b'\r\n')
            encoderZ = self.zAxisComPort.read_until(b'\r\n').strip()
            encoderZ = int(encoderZ)
            self.encoderZ = encoderZ * self.stageUnitsPerEncoderPulse

            xyz = self._sendCmd(SerialCommands.GET_X_Y_Z)
            xyz = xyz.split('\t')
            
            try:
                xPos = int(xyz[0]) / 10.0
                yPos = int(xyz[1]) / 10.0
                zPos = int(xyz[2]) / 10.0
                self.current_pos = [xPos, yPos, zPos]
            except:
                print('error reading position')

            sleepTime = 1 / freq - (time.time() - startTime)
            if sleepTime > 0:
                time.sleep(sleepTime)

    def absolute_move(self, pos, axis):
        if axis == 1:
            yPos = self.position(axis=2)
            self._sendCmd(SerialCommands.SET_X_Y_POS_ABS.format(int(pos * 10) , int(yPos * 10)))
        if axis == 2:
            xPos = self.position(axis=1)
            self._sendCmd(SerialCommands.SET_X_Y_POS_ABS.format(int(xPos * 10), int(pos * 10)))
        if axis == 3:
            stageZ = self.current_pos[2]
            setpointStage = stageZ + (pos - self.encoderZ)
            self._sendCmd(SerialCommands.SET_Z_POS.format(int(setpointStage * 10)))
            self.wait_until_still()
            time.sleep(1)
            print(f'expected encoder: {pos} actual {self.encoderZ}')
            error = pos - self.encoderZ
            print(f'error: {error}')
            if abs(error) > 2:
                print('retrying')
                self.absolute_move(pos, axis)
    
    def absolute_move_group(self, x, axes, speed=None):
        x = list(x)
        axes = list(axes)

        if 1 in axes and 2 in axes:
            # Move X and Y axes together
            xPos = x[axes.index(1)]
            yPos = x[axes.index(2)]
            print("sent cmd", xPos, yPos)
            self._sendCmd(SerialCommands.SET_X_Y_POS_ABS.format(int(xPos * 10), int(yPos * 10)))

        elif 1 in axes and 2 in axes and 3 in axes:
            # Move X, Y and Z axes together
            xPos = x[axes.index(1)]
            yPos = x[axes.index(2)]
            zPos = x[axes.index(3)]
            print("sent cmd", xPos, yPos, zPos)
            self._sendCmd(SerialCommands.SET_X_Y_Z_POS_ABS.format(int(xPos * 10), int(yPos * 10), int(zPos * 10)))

        else:
            print(f'unimplemented move group {x} {axes}')

    
    def relative_move_group(self, pos, axis, speed=None):
        if axis == 1:
            self._sendCmd(SerialCommands.SET_X_Y_POS_REL.format(pos, 0))
        if axis == 2:
            self._sendCmd(SerialCommands.SET_X_Y_POS_REL.format(0, pos))
        if axis == 3:
            absZCmd = self.position(3) + pos
            self.absolute_move(absZCmd, 3)

    def relative_move_group(self, x, axes):
        cmd = [0, 0, 0]
        for pos, axis in zip(x, axes):
            cmd[axis  - 1] = pos
        
        if cmd[0] != 0 or cmd[1] != 0:
            self._sendCmd(SerialCommands.SET_X_Y_POS_REL.format(int(cmd[0] * 10), int(cmd[1] * 10)))

        if cmd[2] != 0:
            self.relative_move(cmd[2], 3)

    def absolute_move_group_velocity(self,vel,axes):   
        try: 
         vel = list(vel)
         axes = list(axes)
         xvel = vel[axes.index(1)]
         yvel = vel[axes.index(2)]
         zvel = vel[axes.index(3)]
         self._sendCmd(SerialCommands.SET_X_Y_Z_VEL.format(xvel, yvel, zvel))
        except Exception as e:
            self.error(f"Error in absolute_move: {e}")

    def wait_until_still(self, axes = None, axis = None):
        while True:
            resp = self._sendCmd(SerialCommands.GET_IS_BUSY)
            busy = resp != '0'

            if not busy:
                break

    def stop(self):
        self._sendCmd(SerialCommands.STOP)


class ScientificaSerialNoEncoder(Manipulator):

    def __init__(self, comPort: serial.Serial):
        self.comPort : serial.Serial = comPort
        self._lock = threading.Lock()
        self.current_pos = [0, 0, 0]

        self.set_max_accel(1000)
        self.set_max_speed(100000)

        #start constantly polling position in a new thread
        self._polling_thread = threading.Thread(target=self.update_pos_continuous, daemon=True)
        self._polling_thread.start()
        self._polling_thread.deamon = True
    
    def set_max_speed(self, speed):
        '''Sets the max speed for the Scientifica Stage.  
           It seems like the range for this is around (1000, 100000)
        '''
        self._sendCmd(SerialCommands.SET_MAX_SPEED.format(int(speed)))

    def set_max_accel(self, accel):
        '''Sets the max acceleration for the Scientifica Stage.
           It seems like the range for this is around (10, 10000)
        '''
        self._sendCmd(SerialCommands.SET_MAX_ACCEL.format(int(accel)))

    def __del__(self):
        self.comPort.close()

    def _sendCmd(self, cmd):
        '''Sends a command to the stage and returns the response
        '''
        
        self._lock.acquire()
        self.comPort.write(cmd.encode())
        resp = self.comPort.read_until(b'\r') #read reply to message
        resp = resp[:-1]
        self._lock.release()
        return resp.decode()

    def position(self, axis=None):
        if axis == 1:
            return self.current_pos[0]
        if axis == 2:
            return self.current_pos[1]
        if axis == 3:
            return self.current_pos[2]
        if axis == None:
            return self.current_pos
        
    def update_pos_continuous(self, freq=100):
        '''constantly polls the device's position and updates the current_pos variable
        '''
        while True:
            startTime = time.time()
            xyz = self._sendCmd(SerialCommands.GET_X_Y_Z)
            xyz = xyz.split('\t')
            
            try:
                xPos = int(xyz[0]) / 10.0
                yPos = int(xyz[1]) / 10.0
                zPos = int(xyz[2]) / 10.0
                self.current_pos = [xPos, yPos, zPos]
            except:
                print('error reading position')

            sleepTime = 1 / freq - (time.time() - startTime)
            if sleepTime > 0:
                time.sleep(sleepTime)

    def absolute_move(self, pos, axis, speed=None):
        try: 
            if axis == 1:
                yPos = self.position(axis=2)
                self._sendCmd(SerialCommands.SET_X_Y_POS_ABS.format(int(pos * 10) , int(yPos * 10)))
            if axis == 2:
                xPos = self.position(axis=1)
                self._sendCmd(SerialCommands.SET_X_Y_POS_ABS.format(int(xPos * 10), int(pos * 10)))
            if axis == 3:
                self._sendCmd(SerialCommands.SET_Z_POS.format(int(pos * 10)))
        except Exception as e:
            self.error(f"Error in absolute_move: {e}")
    
    def absolute_move_group(self, x, axes, speed=None):
      
        x = list(x)
        axes = list(axes)

        if 1 in axes and 2 in axes and 3 not in axes:
            # Move X and Y axes together
            xPos = x[axes.index(1)]
            yPos = x[axes.index(2)]
            self._sendCmd(SerialCommands.SET_X_Y_POS_ABS.format(int(xPos * 10), int(yPos * 10)))

        elif 1 in axes and 2 in axes and 3 in axes:
            # Move X, Y and Z axes together
            xPos = x[axes.index(1)]
            yPos = x[axes.index(2)]
            zPos = x[axes.index(3)]
            self._sendCmd(SerialCommands.SET_X_Y_Z_POS_ABS.format(int(xPos * 10), int(yPos * 10), int(zPos * 10)))


        else:
            print(f'unimplemented move group {x} {axes}')
        
    def relative_move_group(self, pos, axis, speed=None):
        if axis == 1:
            self._sendCmd(SerialCommands.SET_X_Y_POS_REL.format(pos, 0))
        if axis == 2:
            self._sendCmd(SerialCommands.SET_X_Y_POS_REL.format(0, pos))
        if axis == 3:
            absZCmd = self.position(3) + pos
            self.absolute_move(absZCmd, 3)

    def relative_move_group(self, x, axes, speed=None):
        cmd = [0, 0, 0]
        for pos, axis in zip(x, axes):
            cmd[axis  - 1] = pos
        
        if cmd[0] != 0 or cmd[1] != 0:
            self._sendCmd(SerialCommands.SET_X_Y_POS_REL.format(int(cmd[0] * 10), int(cmd[1] * 10)))

        if cmd[2] != 0:
            self.relative_move(cmd[2], 3)

    def wait_until_still(self, axes = None, axis = None):
        while True:
            resp = self._sendCmd(SerialCommands.GET_IS_BUSY)
            busy = resp != '0'

            if not busy:
                break

    def stop(self):
        self._sendCmd(SerialCommands.STOP)




================================================
File: /holypipette/devices/manipulator/microscope.py
================================================
'''
A microscope is a manipulator with a single axis.
With methods to take a stack of images, autofocus, etc.

TODO:
* a umanager class that autoconfigures with umanager config file
* steps for stack acquisition?
'''
from holypipette.devices.manipulator import Manipulator
import time
import warnings
try:
    import cv2
except:
    warnings.warn('OpenCV not available')

__all__ = ['Microscope']

class Microscope(Manipulator):
    '''
    A microscope Z axis, obtained here from an axis of a Manipulator.
    '''
    def __init__(self, dev, axis):
        '''
        Parameters
        ----------
        dev : underlying device
        axis : axis index
        '''
        Manipulator.__init__(self)
        self.dev : Manipulator = dev
        self.axis = axis
        self.up_direction = None # Up direction, must be provided or calculated
        self.floor_Z = None # This is the Z coordinate of the coverslip
        # Motor range in um; by default +- one meter
        self.min = -1e6 # This could replace floor_Z
        self.max = 1e6

    def set_max_speed(self, speed):
        self.dev.set_max_speed(speed)

    def position(self):
        '''
        Current position

        Returns
        -------
        The current position of the device axis in um.
        '''
        true_position = float(5.0* self.dev.position(self.axis))
        
        return true_position

    def absolute_move(self, x):
        '''
        Moves the device axis to position x in um.

        Parameters
        ----------
        x : target position in um.
        '''
        self.dev.absolute_move(x, self.axis)
        self.sleep(.05)

    def absolute_move_velocity(self, vel):
        '''
        Moves the device axis at velocity vel in um/s.

        Parameters
        ----------
        vel : velocity in um/s.
        '''
        self.dev.absolute_move_group_velocity(vel, self.axis)
        self.sleep(.05)

    def move_to_floor(self):
        self.dev.absolute_move(self.floor_Z + 200, self.axis)
        self.dev.wait_until_still([self.axis])
        self.dev.absolute_move(self.floor_Z, self.axis)
        self.dev.wait_until_still([self.axis])

    def fix_backlash(self):
        curr_pos = self.position()
        self.absolute_move(curr_pos + 200)
        self.wait_until_still()
        self.absolute_move(curr_pos)
        self.wait_until_still()

    def relative_move(self, x):
        '''
        Moves the device axis by relative amount x in um.

        Parameters
        ----------
        x : position shift in um.
        '''
        self.dev.relative_move(x, self.axis)
        self.sleep(.05)

    def step_move(self, distance):
        self.dev.step_move(distance, self.axis)

    def stop(self):
        """
        Stop current movements.
        """
        self.dev.stop(self.axis)

    def wait_until_still(self):
        """
        Waits for the motors to stop.
        """
        self.dev.wait_until_still([self.axis])
        self.sleep(.05)

    def stack(self, camera, z, preprocessing=lambda img:img, save = None, pause = 0.3):
        '''
        Take a stack of images at the positions given in the z list

        Parameters
        ----------
        camera : a camera, eg with a snap() method
        z : A list of z positions
        preprocessing : a function that processes the images (optional)
        save : saves images to disk if True
        pause : pause in second after each movement
        '''
        position = self.position()
        images = []
        current_z = position
        for k,zi in enumerate(z):
            #self.absolute_move(zi)
            self.relative_move(zi-current_z)
            current_z = zi
            self.wait_until_still()
            # We wait a little bit because there might be mechanical oscillations
            time.sleep(pause) # also make sure the camera is in sync
            img = preprocessing(camera.snap())
            images.append(img)
            if save is not None:
                cv2.imwrite('./screenshots/'+save+'{}.jpg'.format(k), img)
        self.absolute_move(position)
        self.wait_until_still()
        return images

    def save_configuration(self):
        '''
        Outputs configuration in a dictionary.
        '''
        config = {'up_direction' : self.up_direction,
                  'floor_Z' : self.floor_Z}
        return config

    def load_configuration(self, config):
        '''
        Loads configuration from dictionary config.
        Variables not present in the dictionary are untouched.
        '''
        self.up_direction = config.get('up_direction', self.up_direction)
        #self.floor_Z = config.get('floor_Z', self.floor_Z)


================================================
File: /holypipette/devices/manipulator/PipetteCalHelper.py
================================================
import time
import cv2
import numpy as np
from holypipette.devices.manipulator.microscope import Microscope
from holypipette.devices.manipulator import Manipulator
from holypipette.devices.camera import Camera
from holypipette.deepLearning.pipetteFinder import PipetteFinder
from holypipette.deepLearning.pipetteFocuser import PipetteFocuser, FocusLevels
from threading import Thread

class PipetteCalHelper():
    '''A helper class to aid with Pipette Calibration
    '''
    
    CAL_MAX_SPEED = 1000
    NORMAL_MAX_SPEED = 1000

    def __init__(self, pipette: Manipulator, microscope: Microscope, camera: Camera, calibrated_stage):
        self.pipette : Manipulator = pipette
        self.microscope: Microscope = microscope
        self.camera = camera
        self.pipetteFinder : PipetteFinder = PipetteFinder()
        self.calibrated_stage = calibrated_stage
        self.cal_points = [] #the points we've recorded for calibration

        
    def record_cal_point(self):
        '''Records a calibration point by moving the pipette to the center of the pipette in the current frame
        '''
        _, _, _, frame = self.camera.raw_frame_queue[0]
        pos_pix = self.pipetteFinder.find_pipette(frame)
        if pos_pix != None:
            frame = cv2.circle(frame, pos_pix, 10, 0, 2)
            stage_pos_pix = self.calibrated_stage.reference_position()
            self.cal_points.append((pos_pix[0] - stage_pos_pix[0], pos_pix[1] - stage_pos_pix[1], self.microscope.position(), self.pipette.position()[0], self.pipette.position()[1], self.pipette.position()[2]))

            self.camera.show_point(pos_pix)
            print('recorded: ', self.cal_points[-1])
        else:
            print('no pipette found')

    def calibrate(self):
        '''Calibrates the pipette using YOLO object detection and pipette encoders to create a um -> pixels transformation matrix
        '''
        print('calibrating...')
        #convert to int64 for cv2
        cal_points_int = np.array(self.cal_points, dtype=np.int64)
        print(f'cal points: {self.cal_points}')
        ret, mat, inliers = cv2.estimateAffine3D(np.array(cal_points_int)[:,3:6], np.array(cal_points_int)[:,0:3])


        #convert to float64 for cv2
        self.cal_points = np.array(self.cal_points, dtype=np.float64)

        #use least squares to find the 4x4 homogeneous transform matrix
        A = np.zeros((self.cal_points.shape[0] * 3, 12))

        #construct vectorized A matrix
        for i in range(0, self.cal_points.shape[0], 3):
            A[i] = [self.cal_points[i,3], self.cal_points[i,4], self.cal_points[i,5], 1, 0, 0, 0, 0, 0, 0, 0, 0]
            A[i + 1] = [0, 0, 0, 0, self.cal_points[i,3], self.cal_points[i,4], self.cal_points[i,5], 1, 0, 0, 0, 0]
            A[i + 2] = [0, 0, 0, 0, 0, 0, 0, 0, self.cal_points[i,3], self.cal_points[i,4], self.cal_points[i,5], 1]

        #construct vectorized b matrix
        b = np.zeros((self.cal_points.shape[0] * 3, 1))
        for i in range(0, self.cal_points.shape[0], 3):
            b[i] = self.cal_points[i,0]
            b[i + 1] = self.cal_points[i,1]
            b[i + 2] = self.cal_points[i,2]

        #solve least squares
        m2 = np.linalg.inv(A.T @ A) @ A.T @ b
        
        #reshape into 4x4 matrix
        m2 = np.reshape(m2, (3,4))
        print('least squares: ', m2)

        
        print(f'calibration matrix: {mat}')
        self.cal_points = []
        return m2

class PipetteFocusHelper():
    def __init__(self, pipette: Manipulator, camera: Camera):
        self.pipette = pipette
        self.camera = camera
        self.pipetteFocuser : PipetteFocuser = PipetteFocuser()
    
    def focus(self):
        '''Moves the pipette into focus, if it's in the current frame
        '''
        print('focusing...')
        frame = self.camera.get_16bit_image()
        focusLevel = self.pipetteFocuser.get_pipette_focus(frame)
        print(focusLevel)
        for i in range(10):
            if focusLevel == FocusLevels.OUT_OF_FOCUS_DOWN:
                print("moving pipette down")
                self.pipette.relative_move(-50, 2)
            elif focusLevel == FocusLevels.OUT_OF_FOCUS_UP:
                print("moving pipette up")
                self.pipette.relative_move(50, 2)
            elif focusLevel == FocusLevels.IN_FOCUS:
                print('in focus')
                break
            
            self.pipette.wait_until_still()

            frame = self.camera.get_16bit_image()
            focusLevel = self.pipetteFocuser.get_pipette_focus(frame)

================================================
File: /holypipette/config.py
================================================
'''
Support for configuration objects (based on the param package)
'''
import warnings
import yaml
import logging
import param
from param import Number, Boolean  # to make it available for import

class NumberWithUnit(param.Number):
    __slots__ = ['unit', 'magnitude']

    def __init__(self, default, unit, magnitude=1.0, *args, **kwds):
        super(NumberWithUnit, self).__init__(default=default, *args, **kwds)
        self.unit = unit
        self.magnitude = magnitude


class Config(param.Parameterized):
    def __init__(self, value_changed=None, *args, **kwds):
        super(Config, self).__init__(*args, **kwds)
        self._value_changed = value_changed

    def __setattr__(self, key, value):
        super(Config, self).__setattr__(key, value)
        if not key.startswith('_') and getattr(self, '_value_changed', None) is not None:
            self._value_changed(key, value)
            logging.debug('Config value changed: %s = %s', key, value)

    def to_dict(self):
        return {name: getattr(self, name) for name in self.params()
                if name != 'name'}

    def from_dict(self, config_dict):
        for name, value in config_dict.items():
            setattr(self, name, value)

    def to_file(self, filename):
        config_dict = self.to_dict()
        with open(filename, 'w') as f:
            yaml.dump(config_dict, f)

    def from_file(self, filename):
        with open(filename, 'r') as f:
            config_dict = yaml.load(f)
        self.from_dict(config_dict)


================================================
File: /holypipette/log_utils.py
================================================
import logging
import csv
import os
from datetime import datetime

class CSVLogHandler(logging.Handler):
    """Custom logging handler that logs to a CSV file."""

    def __init__(self, base_filename, mode='a'):
        # Generate a filename with only the date
        timestamp = datetime.now().strftime("%Y_%m_%d")
        filename = f"{base_filename}_{timestamp}.csv"
        super().__init__()
        self.filename = filename
        self.mode = mode
        self.output_file = open(self.filename, self.mode, newline='')
        self.csv_writer = csv.writer(self.output_file)
        
        # Write headers if the file is new/empty
        if os.stat(self.filename).st_size == 0:
            headers = ["Time(HH:MM:SS)", "Time(ms)", "Level", "Message", "Logger Name", "Thread ID"]
            self.csv_writer.writerow(headers)

        self.setFormatter(logging.Formatter('%(asctime)s,%(levelname)s,%(message)s,%(name)s,%(thread)d'))

    def emit(self, record):
        try:
            log_entry = self.format(record)
            self.csv_writer.writerow(log_entry.split(","))
            # Ensure the log is flushed after every write to prevent data loss
            self.output_file.flush()
        except Exception as e:
            self.handleError(record)

    def close(self):
        if not self.output_file.closed:
            # Flush and close the file properly when done
            self.output_file.flush()
            self.output_file.close()
        super().close()

class LoggingObject(object):
    @property
    def logger(self):
        if getattr(self, '_logger', None) is None:
            logger_name = f"{self.__class__.__module__}.{self.__class__.__name__}"
            self._logger = logging.getLogger(logger_name)
            self._logger.setLevel(logging.DEBUG)
        return self._logger

    def debug(self, message, *args, **kwds):
        self.logger.debug(message, *args, **kwds)

    def info(self, message, *args, **kwds):
        self.logger.info(message, *args, **kwds)

    def warn(self, message, *args, **kwds):
        self.logger.warn(message, *args, **kwds)

    def error(self, message, *args, **kwds):
        self.logger.error(message, *args, **kwds)

    def exception(self, message, *args, **kwds):
        self.logger.exception(message, *args, **kwds)

def setup_logging():
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)
    
    # Console handler
    console_handler = logging.StreamHandler()
    console_formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s [%(name)s - thread %(thread)d]')
    console_handler.setFormatter(console_formatter)
    root_logger.addHandler(console_handler)
    
    # Path for logs
    path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\log_data"
    
    # CSV file handler with a daily timestamped filename
    csv_handler = CSVLogHandler(base_filename=path + r'\logs')
    root_logger.addHandler(csv_handler)

# Initialize the logging
setup_logging()

logging.info("Program Started")


================================================
File: /holypipette/interface/camera.py
================================================
from __future__ import print_function
import numpy as np
from PyQt5 import QtCore, QtWidgets
import warnings
import cv2
from numpy import *
from holypipette.interface import TaskInterface, command, blocking_command
import logging


class CameraInterface(TaskInterface):
    updated_exposure = QtCore.pyqtSignal('QString', 'QString')

    def __init__(self, camera, with_tracking=False):
        super().__init__()
        self.camera = camera
        self.with_tracking = with_tracking

    def connect(self, main_gui):
        self.updated_exposure.connect(main_gui.set_status_message)
        self.signal_updated_exposure()
        if self.with_tracking:
            main_gui.image_edit_funcs.append(self.show_tracked_objects)
            #main_gui.image_edit_funcs.append(self.show_tracked_paramecium)
            #main_gui.image_edit_funcs.append(self.pipette_contact_detection)

    def signal_updated_exposure(self):
        # Should be called by subclasses that actually support setting the exposure
        exposure = self.camera.get_exposure()
        if exposure > 0:
            self.updated_exposure.emit('Camera', 'Exposure: %.1f ms' % exposure)

    @blocking_command(category='Camera',
                      description='Auto exposure',
                      task_description='Adjusting exposure')
    def auto_exposure(self,args):
        self.camera.auto_exposure()
        self.signal_updated_exposure()

    @command(category='Camera',
             description='Increase exposure time by {:.1f}ms',
             default_arg=2.5)
    def increase_exposure(self, increase):
        self.camera.change_exposure(increase)
        self.signal_updated_exposure()
    @command(category='Camera',
                description='Set exposure time to {:.1f}ms',
                default_arg=2.5)
    def set_exposure(self, exposure):     
        currexpos = self.camera.get_exposure()
        change = exposure - currexpos
        if change > 0:
            self.increase_exposure(change)
        elif change < 0:
            self.decrease_exposure(-change)
        # logging.info('Current exposure time is: {}'.format(currexpos))
        # logging.info("difference is: {}".format(change))
        logging.info('New exposure time is: {}'.format(exposure))
        # self.camera.set_exposure(exposure)
        self.signal_updated_exposure()
    
    @command(category='Camera',
             description='Normalize the image',
             )
    def normalize(self, param=None):
        self.camera.normalize()

    @command(category='Camera',
             description='AutoNormalize the image',
             )
    def autonormalize(self, state):
        # if state: 
        #     print("AutoNormalizing")
        # else:
        #     print("Not AutoNormalizing")
        self.camera.autonormalize(state)

    @command(category='Camera',
             description='Decrease exposure time by {:.1f}ms',
             default_arg=2.5)
    def decrease_exposure(self, decrease):
        self.camera.change_exposure(-decrease)
        self.signal_updated_exposure()

    # @command(category='Camera',
    #          description='Save the current image to a file')
    # def save_image(self):
    #     # try:
    #     #     from PIL import Image
    #     # except ImportError:
    #     #     self.error('Saving images needs the PIL or Pillow module')
    #     #     return
    #     frame, _ = self.camera.snap()
    #     fname, _ = QtWidgets.QFileDialog.getSaveFileName(caption='Save image',
    #                                                      filter='Images (*.png, *.tiff)',
    #                                                      options=QtWidgets.QFileDialog.DontUseNativeDialog)
    #     if len(fname):
    #         img = Image.fromarray(frame)
    #         try:
    #             img.save(fname)
    #         except (KeyError, IOError):
    #             self.exception('Saving image as "%s" failed.' % fname)

================================================
File: /holypipette/interface/pipettes.py
================================================
# coding=utf-8
import pickle
import os

import numpy as np

from holypipette.interface import TaskInterface, command, blocking_command
from holypipette.devices.manipulator.calibratedunit import CalibratedUnit, CalibratedStage, CalibrationConfig
from holypipette.devices.cellsorter import CalibratedCellSorter
import time

from holypipette.devices.manipulator.microscope import Microscope

class PipetteInterface(TaskInterface):
    '''
    Controller for the stage, the microscope, a pipette, and the cell sorter.
    '''

    def __init__(self, stage, microscope: Microscope, camera, unit, cellsorterManip, cellsorterController,
                 config_filename='calibration.pickle'):
        super().__init__()
        self.microscope = microscope
        self.camera = camera
        # Create a common calibration configuration for all stages/manipulators
        self.calibration_config = CalibrationConfig(name='Calibration')
        self.calibrated_stage = CalibratedStage(stage, None, microscope, camera,
                                                config=self.calibration_config)
        self.calibrated_unit = CalibratedUnit(unit,
                                                self.calibrated_stage,
                                                microscope,
                                                camera,
                                                config=self.calibration_config)
        self.calibrated_cellsorter = CalibratedCellSorter(cellsorterManip, cellsorterController, self.calibrated_stage, microscope, camera)

        if config_filename is not None:
            #read calibration from file
            if os.path.isfile(config_filename):
                with open(config_filename, 'rb') as f:
                    cal = pickle.load(f)
                    self.calibrated_unit.load_configuration(cal['manip'])
                    self.calibrated_stage.load_configuration(cal['stage'])

                    print('Loaded calibration from file!')
                    print('Manipulator calibration:')
                    print(cal['manip'])
                    print('Stage calibration:')
                    print(cal['stage'])
            else:
                pass
            # print('No calibration file found, need to calibrate before usage!')


        self.cleaning_bath_position = None
        self.contact_position = None
        self.rinsing_bath_position = None
        self.paramecium_tank_position = None
        self.timer_t0 = time.time()
        self.pos_before_raise = None

    def connect(self, main_gui):
        pass #TODO: unused?

    @blocking_command(category='Manipulators',
             description='Move to a repeatable position in the z axis (eliminate backlash)',
             task_description='Moving to a repeatable position in the z axis',
             default_arg=10)
    def fix_backlash(self, none):
        self.execute(self.microscope.fix_backlash)


    @command(category='Manipulators',
             description='Record a calibration point at the current position',
             default_arg=10)
    def record_cal_point(self, none):
        self.calibrated_unit.record_cal_point()
    
    @command(category='Manipulators',
             description='Finish calibration',
             default_arg=10)
    def finish_calibration(self, none):
        self.calibrated_unit.finish_calibration()

    @command(category='Manipulators',
             description='Move pipette in x direction by {:.0f}μm',
             default_arg=10)
    def move_pipette_x(self, distance):
        self.calibrated_unit.relative_move(distance, axis=0)

    @command(category='Manipulators',
                description='Write current calibration to file')
    def write_calibration(self):
        if not self.calibrated_stage.calibrated:
            raise RuntimeError('Stage not calibrated')
        if not self.calibrated_unit.calibrated:
            raise RuntimeError('Manipulator not calibrated')
        
        with open('calibration.pickle', 'wb') as f:
            pickle.dump({'manip': self.calibrated_unit.save_configuration(),
                         'stage': self.calibrated_stage.save_configuration()}, f)
            
    @command(category='Manipulators',
                description='recalibrate manipulator offset while preserving matrix')
    def recalibrate_manipulator(self):
        self.calibrated_unit.recalibrate_pipette()
            
    @command(category='Manipulators',
             description='Move pipette in y direction by {:.0f}μm',
             default_arg=10)
    def move_pipette_y(self, distance):
        self.calibrated_unit.relative_move(distance, axis=1)

    @command(category='Manipulators',
             description='Move pipette in z direction by {:.0f}μm',
             default_arg=10)
    def move_pipette_z(self, distance):
        self.calibrated_unit.relative_move(distance, axis=2)

    @command(category='Microscope',
             description='Move microscope by {:.0f}μm',
             default_arg=10)
    def move_microscope(self, distance):
        self.microscope.relative_move(distance)

    @command(category='Microscope',
             description='Set the position of the floor (cover slip)',
             success_message='Cover slip position stored')
    def set_floor(self):
        self.microscope.floor_Z = self.microscope.position()
        self.info(f'Cell plane position set to {self.microscope.floor_Z}')

    @command(category='Stage',
             description='Move stage vertically by {:.0f}μm',
             default_arg=10)
    def move_stage_vertical(self, distance):
        self.calibrated_stage.relative_move(distance, axis=1)

    @command(category='Stage',
             description='Move stage horizontally by {:.0f}μm',
             default_arg=10)
    def move_stage_horizontal(self, distance):
        self.calibrated_stage.relative_move(distance, axis=0)

    @blocking_command(category='Stage',
                      description='Calibrate stage only',
                      task_description='Calibrating stage')
    def calibrate_stage(self):
        self.execute([self.calibrated_stage.calibrate])

    @blocking_command(category='Manipulators',
                      description='Calibrate manipulator',
                      task_description='Calibrating manipulator')
    def calibrate_manipulator(self):
        self.execute([self.calibrated_unit.calibrate])
    @blocking_command(category='Manipulators',
                        description='Home the manipulator',
                        task_description='Homming the manipulator')
    def Home_manipulator(self):
        self.execute([self.calibrated_unit.calibrate])

    @blocking_command(category='Manipulators',
                      description='Focus the pipette',
                      task_description='Calibrating manipulator')
    def focus_pipette(self):
        self.execute([self.calibrated_unit.focus])

    @blocking_command(category='Manipulators',
                     description='Move pipette to position',
                     task_description='Moving to position with safe approach')
    def move_pipette(self, xy_position):
        x, y = xy_position
        position = np.array([x, y, self.microscope.position()])
        self.debug('asking for safe move to {}'.format(position))
        self.execute(self.calibrated_unit.safe_move, argument=position)

    @blocking_command(category='Manipulators',
                    description='Raise the pipette high enough to insert the coverslip',
                    task_description='Raising the pipette high enough to insert the coverslip')
    def raise_pipette(self, raise_distance = 1000):
        if self.pos_before_raise is None:
            self.pos_before_raise = self.calibrated_unit.dev.position()
            position = np.array([self.pos_before_raise[0], self.pos_before_raise[1], 0])
            self.execute(self.calibrated_unit.absolute_move, argument=position)
        else:
            raise RuntimeError('Pipette already raised')

    @blocking_command(category='Manipulators',
                description='Lower the pipette after inserting the coverslip',
                task_description='Lowering the pipette after inserting the coverslip')
    def lower_pipette(self):
        if self.pos_before_raise is not None:
            self.execute(self.calibrated_unit.absolute_move, argument=self.pos_before_raise)
            self.pos_before_raise = None
        else:
            raise RuntimeError('Pipette not raised')
        
    @blocking_command(category='Cell Sorter',
                    description='calibrate the cell sorter',
                    task_description='Calibrating the cell sorter')
    def calibrate_cell_sorter(self):
        self.execute(self.calibrated_cellsorter.calibrate)

    @blocking_command(category='Manipulators',
                     description='Move stage to position',
                     task_description='Moving stage to position')
    def move_stage(self, xy_position):
        x, y = xy_position
        position = np.array([x, y])
        self.debug('asking for reference move to {}'.format(position))
        self.execute(self.calibrated_stage.reference_relative_move, argument=-position) # compensatory move

    @blocking_command(category='Manipulators',
                    description='Center Pipette in Image Frame',
                    task_description='Centering Pipette in Image Frame')
    def center_pipette(self):
        x = 0
        y = 0
        z = self.microscope.position()
        position = np.array([x, y, z])
        self.execute(self.calibrated_unit.safe_move, argument=position) # compensatory move


    @blocking_command(category='Microscope',
                      description='Go to the floor (cover slip)',
                      task_description='Go to the floor (cover slip)')
    def go_to_floor(self):
        if self.microscope.floor_Z is None:
            raise RuntimeError("Coverslip floor must be set.")
        self.execute(self.microscope.move_to_floor)

================================================
File: /holypipette/interface/__init__.py
================================================
"""
Package defining `.TaskInterface` classes. These classes are the interfaces
between the GUI and the classes that perform the actual tasks such as patching,
controlling the camera, etc. The key role of the `.TaskInterface` classes is
to define the commands that it supports (e.g. patching, moving the manipulators,
etc.) and what should be done if such command is received.
"""
from .base import *
from .camera import *
from .pipettes import PipetteInterface
from .patch import AutoPatchInterface
from .patchConfig import PatchConfig


================================================
File: /holypipette/interface/base.py
================================================
"""
Package defining the `TaskInterface` class, central to the interface between
GUI and `.TaskController` objects.
"""
import functools
import textwrap
import collections
from collections.abc import Sequence
from types import MethodType

from PyQt5 import QtCore

from holypipette.controller import TaskController, RequestedAbortException
from holypipette.log_utils import LoggingObject


def command(category, description, default_arg=None, success_message=None):
    '''
    Decorator that annotates a function with information about the implemented
    command.

    Parameters
    ----------
    category : str
        The command category (used for structuring the help window).
    description : str
        A descriptive text for the command (used in the help window).
    default_arg : object, optional
        A default argument provided to the method or ``None`` (the default).
    success_message : str, optional
        A message that will be displayed in the status bar of the GUI window
        after the execution of the command. For simple commands that have visual
        feedback, e.g. moving the manipulator or changing the exposure time,
        this should not be set to avoid unnecessary messages. For actions that
        have no visual feedback, e.g. storing a position, this should be set to
        give the user an indication that something happened.
    '''
    def decorator(func):
        @functools.wraps(func)
        def wrapped(self, argument=None):
            if argument is None and default_arg is not None:
                argument = default_arg
            if argument is None:
                result = func(self)
                if success_message:
                    self.task_finished.emit(0, success_message)
                    self.info(success_message)
            else:
                result = func(self, argument)
            if success_message:
                self.task_finished.emit(0, success_message)
                self.info(success_message)
            return result
        wrapped.category = category
        wrapped.description = description
        wrapped.default_arg = default_arg
        wrapped.is_blocking = False

        def auto_description(argument=None):
            if argument is None:
                argument = default_arg
            return description.format(argument)
        wrapped.auto_description = auto_description

        if wrapped.__doc__ is None:
            import inspect
            try:
                args = inspect.getfullargspec(func).args  # Python 3
            except AttributeError:
                args = inspect.getargspec(func).args  # Python 2
            if len(args) > 1:
                arg_name = args[1]
            else:
                arg_name = None
            docstring = textwrap.dedent('''
            {description}
            ''').format(description=auto_description())

            if arg_name is not None:
                if default_arg is None:
                    default_argument_description = ''
                else:
                    default_argument_description = (
                        ' If no argument is given, {} '
                        'will be used as a default '
                        'argument').format(
                        repr(default_arg))
                docstring += textwrap.dedent('''
                Parameters
                ----------
                {arg_name} : object, optional
                    {default_argument}
                ''').format(arg_name=arg_name,
                            default_argument=default_argument_description)
            wrapped.__doc__ = docstring

        return wrapped
    return decorator


def blocking_command(category, description, task_description,
                     default_arg=None):
    '''
    Decorator that annotates a function with information about the implemented
    (blocking) command.

    Parameters
    ----------
    category : str
        The command category (used for structuring the help window).
    description : str
        A descriptive text for the command (used in the help window).
    task_description : str
        Text that will be displayed to the user while the task is running
    default_arg : object, optional
        A default argument provided to the method or ``None`` (the default).
    '''
    def decorator(func):
        @functools.wraps(func)
        def wrapped(self, argument=None):
            if argument is None and default_arg is not None:
                argument = default_arg
            if argument is None:
                result = func(self)
            else:
                result = func(self, argument)
            return result
        wrapped.category = category
        wrapped.description = description
        wrapped.task_description = task_description
        wrapped.is_blocking = True
        wrapped.default_arg = default_arg

        def auto_description(argument=None):
            if argument is None:
                argument = default_arg
            return description.format(argument)
        wrapped.auto_description = auto_description

        if wrapped.__doc__ is None:
            import inspect
            try:
                args = inspect.getfullargspec(func).args  # Python 3
            except AttributeError:
                args = inspect.getargspec(func).args  # Python 2
            if len(args) > 1:
                arg_name = args[1]
            else:
                arg_name = None
            docstring = textwrap.dedent('''
            {description}
            ''').format(description=auto_description())

            if arg_name is not None:
                if default_arg is None:
                    default_argument_description = ''
                else:
                    default_argument_description = (
                        ' If no argument is given, {} '
                        'will be used as a default '
                        'argument').format(
                        repr(default_arg))
                docstring += textwrap.dedent('''
                Parameters
                ----------
                {arg_name} : object, optional
                    {default_argument}
                ''').format(arg_name=arg_name,
                            default_argument=default_argument_description)
            wrapped.__doc__ = docstring

        return wrapped
    return decorator


class TaskInterface(QtCore.QObject, LoggingObject):
    """
    Class defining the basic interface between the GUI and the objects
    controlling the hardware. Classes inheriting from this class should:

    * Call this class's ``__init__`` function in its ``__init__``
    * Annotate all functions providing commands with the `@command <.command>`
      or `@blocking_command <.blocking_command>` decorator.
    * To correctly interact with the GUI for blocking commands (show that task
      is running, show error message if task fails, etc.), the method needs to
      call the `~.TaskInterface.execute` function to execute the command.
    """
    #: Signals the end of a task with an "error code":
    #: 0: successful execution; 1: error during execution; 2: aborted
    task_finished = QtCore.pyqtSignal(int, object)

    def __init__(self):
        super().__init__()
        self._current_controller = None

    @QtCore.pyqtSlot(MethodType, object)
    def command_received(self, command, argument):
        """
        Slot that is triggered when the GUI triggers a command handled by this
        `.TaskInterface`. If an error occurs in the handling of the command
        (e.g., the command does not exist or received the wrong number of
        arguments), an error is logged and the `.task_finished` signal is
        emitted. Note that the handling of errors *within* the command, as well
        as the handling of abort requests is performed in the `.execute` method.

        Parameters
        ----------
        command : method
            A reference to the requested command.
        argument : object
            The argument of the requested command (possibly ``None``).
        """
        try:
            if argument is None:
                command()
            else:
                command(argument)
        except Exception:
            self.exception('"{}" failed.'.format(command.__name__))
            self.task_finished.emit(1, None)

    def _execute_single_task(self, controller, func, argument):
        controller.save_state()

        self._current_controller = controller
        controller.abort_requested = False
        try:
            if argument is not None:
                func(argument)
            else:
                func()
        # We send a reference to the "controller" with the task_finished signal,
        # this can be used to ask the user for a state reset after a failed
        # command (e.g. move back the pipette to its start position in case a
        # calibration failed or was aborted)
        except RequestedAbortException:
            self.info('Task "{}" aborted'.format(func.__name__))
            self.task_finished.emit(2, controller)
            self._current_controller = None
            return False
        except Exception:
            self.exception('Task "{}" failed'.format(func.__name__))
            self.task_finished.emit(1, controller)
            self._current_controller = None
            return False

        # Task finished successfully
        controller.delete_state()
        self._current_controller = None
        return True

    def execute(self, task, argument=None):
        """
        Execute a function in a `.TaskController` and signal the (successful or
        unsuccessful) completion via the `.task_finished` signal.

        Can either execute a single task or a chain of tasks where each task is
        only executed when the previous was successful.

        Parameters
        ----------
        task: method or list of methods
            A method of a `TaskController` object that should be executed, or
            a list of such methods.
        argument : object or list of object, optional
            An argument that will be provided to ``task`` or ``None`` (the
            default). For a chain of function calls, provide a list of
            arguments.

        Returns
        -------
        success : bool
            Whether the execution was completed successfully. This can be used
            to manually enchain multiple tasks to avoid calling subsequent tasks
            after a failed/aborted task. Note that it can be easier to pass a
            list of functions instead.
        """
        if not isinstance(task, Sequence):
            task = [task]
            argument = [argument]
        if argument is None:
            argument = [None]

        for one_task, one_argument in zip(task, argument):
            controller = one_task.__self__
            if not isinstance(controller, TaskController):
                raise TypeError('Can only execute methods of TaskController'
                                'objects, but object for method {} is of type '
                                '{}'.format(one_task.__name__, type(controller)))
            success = self._execute_single_task(controller, one_task,
                                                one_argument)
            if not success:
                return
        self.task_finished.emit(0, controller)

    @QtCore.pyqtSlot(TaskController)
    def reset_requested(self, controller):
        """
        Slot that will be triggered when the user asks for resetting the state
        after an aborted or failed command.

        Parameters
        ----------
        controller : `.TaskController`
            The object that was executing the task that failed or was aborted.
            This object is requested to reset its state.

        """
        try:
            # Set abort_requested to False, otherwise it will trigger another
            # abort when it uses sleep, etc.
            controller.abort_requested = False
            controller.recover_state()
        except Exception:
            self.exception('Recovering the state for {} failed.'.format(controller))

    def abort_task(self):
        """
        The user asked for an abort of the currently running (blocking) command.
        We transmit this information to all executing objects (for simplicity,
        only one should be running) by setting the
        `TaskController.abort_requested` attribute. The object runs in a separate
        thread, but will finish its operation as soon as it checks for this
        attribute (either by explicitly checking with
        `.TaskController.abort_if_requested`, or by using
        `.TaskController.sleep` or one of the logging methods).
        """
        self._current_controller.abort_requested = True

    # This function will be automatically called by the main GUI and can be
    # overwritten to connect signals in this class to the main GUI (e.g. to
    # update information in the status bar)
    def connect(self, main_gui):
        """
        Connect signals to slots in the main GUI. Will be called automatically
        during initialization of the GUI.

        Parameters
        ----------
        main_gui : `.CameraGui`
            The main GUI in control.
        """
        pass


================================================
File: /holypipette/interface/patchConfig.py
================================================


from holypipette.config import Config, NumberWithUnit, Number, Boolean
import logging

class PatchConfig(Config):
    '''
    Control of automatic patch clamp algorithm
    '''
    # Define parameters directly without try-except
    pressure_near = NumberWithUnit(20, bounds=(0, 100), doc='Pressure during approach', unit='mbar')
    pressure_sealing = NumberWithUnit(-20, bounds=(-100, 0), doc='Pressure for sealing', unit='mbar')
    pressure_ramp_increment = NumberWithUnit(-25, bounds=(-100, 0), doc='Pressure ramp increment', unit='mbar')
    pressure_ramp_max = NumberWithUnit(-300., bounds=(-1000, 0), doc='Pressure ramp maximum', unit='mbar')
    pressure_ramp_duration = NumberWithUnit(1.15, bounds=(0, 10), doc='Pressure ramp duration', unit='s')

    min_R = NumberWithUnit(2e6, bounds=(0, 1000e6), doc='Minimum normal resistance', unit='MΩ', magnitude=1e6)
    max_R = NumberWithUnit(25e6, bounds=(0, 1000e6), doc='Maximum normal resistance', unit='MΩ', magnitude=1e6)
    max_cell_R = NumberWithUnit(300e6, bounds=(0, 1000e6), doc='Maximum cell resistance', unit='MΩ', magnitude=1e6)
    cell_distance = NumberWithUnit(25, bounds=(0, 100), doc='Initial distance above target cell', unit='μm')
    max_distance = NumberWithUnit(30, bounds=(0, 100), doc='Maximum movement during approach', unit='μm')

    max_R_increase = NumberWithUnit(1e6, bounds=(0, 100e6), doc='Increase in resistance indicating obstruction', unit='MΩ', magnitude=1e6)
    cell_R_increase = Number(.15, bounds=(0, 1), doc='Proportional increase in resistance indicating cell presence')
    gigaseal_R = NumberWithUnit(1000e6, bounds=(100e6, 10000e6), doc='Gigaseal resistance', unit='MΩ', magnitude=1e6)

    seal_min_time = NumberWithUnit(15, bounds=(0, 60), doc='Minimum time for seal', unit='s')
    seal_deadline = NumberWithUnit(90., bounds=(0, 300), doc='Maximum time for seal formation', unit='s')

    Vramp_duration = NumberWithUnit(10., bounds=(0, 60), doc='Voltage ramp duration', unit='s')
    Vramp_amplitude = NumberWithUnit(-70e-3, bounds=(-200e-3, 0), doc='Holding Potential', unit='mV', magnitude=1e-3)

    zap = Boolean(False, doc='Zap the cell to break the seal')

    voltage_protocol = Boolean(default = True, doc='Run the Voltage Protocol automatically')
    current_protocol = Boolean(default = True, doc='Run the Current Protocol automatically')
    holding_protocol = Boolean(default = True, doc='Run the Holding Protocol automatically')

    custom_protocol = Boolean(default = False, doc='Customize the protocol parameters')
    cclamp_step = NumberWithUnit(10, bounds=(0, 20), doc='Step Current', unit='pA', magnitude=1)
    cclamp_start = NumberWithUnit(-50, bounds=(-300, -20), doc='Start Current', unit='pA', magnitude=1)
    cclamp_end = NumberWithUnit(50, bounds=(0, 300), doc='End Current', unit='pA', magnitude=1)

    categories = [
        ('Approach', ['min_R', 'max_R', 'pressure_near', 'cell_distance', 'max_distance', 'cell_R_increase']),
        ('Sealing', ['pressure_sealing', 'gigaseal_R', 'Vramp_duration', 'Vramp_amplitude', 'seal_min_time', 'seal_deadline']),
        ('Break-in', ['zap', 'pressure_ramp_increment', 'pressure_ramp_max', 'pressure_ramp_duration', 'max_cell_R']),
        ('Protocols', ['voltage_protocol', 'current_protocol', 'holding_protocol']),
        ('Current Clamp', ['custom_protocol', 'cclamp_step', 'cclamp_start', 'cclamp_end']),
    ]

    logging.info("PatchConfig initialized successfully.")

================================================
File: /holypipette/interface/patch.py
================================================
# coding=utf-8
'''
Control of automatic patch clamp algorithm
'''
import numpy as np

from holypipette.interface import TaskInterface, command, blocking_command
from holypipette.controller import AutoPatcher
from holypipette.devices.pressurecontroller.BasePressureController import PressureController
from holypipette.devices.amplifier.amplifier import Amplifier
from holypipette.interface.pipettes import PipetteInterface
from holypipette.devices.amplifier.DAQ import DAQ
from .patchConfig import PatchConfig
from PyQt5 import QtCore
import time

__all__ = ['AutoPatchInterface']

class AutoPatchInterface(TaskInterface):
    '''
    A class to run automatic patch-clamp
    '''
    def __init__(self, amplifier: Amplifier, daq: DAQ, pressure: PressureController, pipette_interface: PipetteInterface):
        super().__init__()
        self.config = PatchConfig(name='Patch')
        self.amplifier = amplifier
        self.daq = daq
        self.pressure = pressure
        self.pipette_controller = pipette_interface
        autopatcher = AutoPatcher(amplifier, daq, pressure, self.pipette_controller.calibrated_unit,
                                    self.pipette_controller.calibrated_unit.microscope,
                                    calibrated_stage=self.pipette_controller.calibrated_stage,
                                    config=self.config)
        self.current_autopatcher = autopatcher

        self.is_selecting_cells = False
        self.cells_to_patch = []

        #call update_camera_cell_list every 0.1 seconds using a QTimer
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_camera_cell_list)
        self.timer.start(50)
        

    @blocking_command(category='Patch', description='Break into the cell',
                      task_description='Breaking into the cell')
    def break_in(self):
        self.execute(self.current_autopatcher.break_in)

    def start_selecting_cells(self):
        self.is_selecting_cells = True

    def remove_last_cell(self):
        if len(self.cells_to_patch) > 0:
            self.cells_to_patch = self.cells_to_patch[:-1]

    @blocking_command(category='Cell Sorter',
            description='Move the cell sorter to a cell',
            task_description='Move the cell sorter to a cell')
    def move_cellsorter_to_cell(self):
        #grab cell from list
        cellx = self.cells_to_patch[0][0][0]
        celly = self.cells_to_patch[0][0][1]
        cellz = self.pipette_controller.calibrated_unit.microscope.floor_Z

        #move cell sorter to cell
        self.execute(self.pipette_controller.calibrated_cellsorter.center_cellsorter_on_point, argument=[cellx, celly, cellz])

    @blocking_command(category='DAQ',
            description='Run Protocols on the Cell',
            task_description='Run Protocols on the Cell')
    def run_protocols(self):
        self.execute(self.current_autopatcher.run_protocols)
    

    @command(category='Patch', description='Add a mouse position to the list of cells to patch')
    def add_cell(self, position):
        #add half the size of the camera image to the position to get the center of the cell
        position = np.array(position)

        position[0] += self.current_autopatcher.calibrated_unit.camera.width / 2
        position[1] += self.current_autopatcher.calibrated_unit.camera.height / 2
        # add the z position of the microscope
        z_pos = self.current_autopatcher.calibrated_unit.microscope.position()
        self.debug(f'z position of the microscope: {z_pos}')
        print(f'adding cell... {self.is_selecting_cells}')
        if self.is_selecting_cells:
            print('Adding cell at', position, 'to list of cells to patch')
            stage_pos_pixels = self.current_autopatcher.calibrated_stage.reference_position()
            stage_pos_pixels[0:2] -= position
            # display stage position
            # add the z_pos to the stage position as a third dimension in the np array
            np.append(stage_pos_pixels, z_pos)
            print(f'Stage position dimensions: {np.size(stage_pos_pixels)}')
            #take a 256x256 image centered on the cell
            img = self.current_autopatcher.calibrated_unit.camera.get_16bit_image()
            img = img[int(position[1]-128):int(position[1]+128), int(position[0]-128):int(position[0]+128)]
            if img is None or img.shape != (256, 256):
                raise RuntimeError('Cell too Close to edge!')
            
            #save the image
            # img = cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
            # cv2.imwrite(f'cell_{len(self.cells_to_patch)}.png', img)
            self.cells_to_patch.append((np.array(stage_pos_pixels), img))
            self.is_selecting_cells = False

    def update_camera_cell_list(self) -> None:
        self.current_autopatcher.calibrated_unit.camera.cell_list = []
        for cell, img in self.cells_to_patch:
            camera_pos = -cell + self.current_autopatcher.calibrated_stage.reference_position()
            self.current_autopatcher.calibrated_unit.camera.cell_list.append(camera_pos[0:2].astype(int))
            

    @command(category='Patch',
                description='emit the states to logger that are being attempted in manual mode',
                success_message='state emitted')
    def state_emitter(self,state):
        self.execute(self.current_autopatcher.state_emitter, argument=(state))
                
    @blocking_command(category='Patch', description='Move to cell and patch it',
                      task_description='Moving to cell and patching it')
    def patch(self) -> None:
        cell, img = self.cells_to_patch[0]
        self.execute(self.current_autopatcher.patch,
                     argument=(cell, img))
        time.sleep(2)
        self.cells_to_patch = self.cells_to_patch[1:]
    @blocking_command(category='Patch',
                        description='Hunt the cell',
                        task_description='Moving to the cell and detecting it ')
    def hunt_cell(self):
        cell, img = self.cells_to_patch[0]
        self.execute(self.current_autopatcher.hunt_cell,
                      argument = (cell, img))
        time.sleep(2)
        self.cells_to_patch = self.cells_to_patch[1:]

    @command(category='Patch',
             description='Store the position of the washing bath',
             success_message='Cleaning path position stored')
    def store_cleaning_position(self) -> None:
        self.current_autopatcher.cleaning_bath_position = self.pipette_controller.calibrated_unit.position()

    @command(category='Patch',
                description='Store the position of the safe space',
                success_message='Safe space position stored')
    def store_safe_position(self) -> None:
        
        self.current_autopatcher.safe_position = self.pipette_controller.calibrated_unit.position()
        x,y = self.pipette_controller.calibrated_stage.position()
        z = self.pipette_controller.calibrated_unit.microscope.position()
        self.current_autopatcher.safe_stage_position = [x,y,z]
        self.info(f'safe space position stored: {self.current_autopatcher.safe_position} and {self.current_autopatcher.safe_stage_position}')

    @command(category='Patch',
                description='Store the position of the home space',
                success_message='Home position stored')
    def store_home_position(self) -> None:
        
        self.current_autopatcher.home_position = self.pipette_controller.calibrated_unit.position()
        x,y = self.pipette_controller.calibrated_stage.position()
        z = self.pipette_controller.calibrated_unit.microscope.position()
        self.current_autopatcher.home_stage_position = [x,y,z]
        self.info(f'safe home position stored: {self.current_autopatcher.home_position} and {self.current_autopatcher.home_stage_position}')
    

    @command(category='Patch',
             description='Store the position of the rinsing bath',
             success_message='Rinsing bath position stored')
    def store_rinsing_position(self) -> None:
        self.current_autopatcher.rinsing_bath_position = self.pipette_controller.calibrated_unit.position()

    @blocking_command(category='Patch',
                      description='Clean the pipette (wash and rinse)',
                      task_description='Cleaning the pipette')
    def clean_pipette(self):
        self.execute(self.current_autopatcher.clean_pipette)

    @blocking_command(category='Patch',
                      description= 'Move to safe space',
                      task_description='Moving to safe space')
    def move_to_safe_space(self):
        self.execute(self.current_autopatcher.move_to_safe_space)

    @blocking_command(category='Patch',
                        description='Move to home position',
                        task_description='Moving to home position')
    def move_to_home_space(self):
        self.execute(self.current_autopatcher.move_to_home_space)

    @blocking_command(category='Patch',
                        description='Move the group down',
                        task_description='Moving the group down')
    def move_group_down(self):
        self.execute(self.current_autopatcher.move_group_down)

    @blocking_command(category='Patch',
                        description='Move the group up',
                        task_description='Moving the group up')
    def move_group_up(self):
        self.execute(self.current_autopatcher.move_group_up)


    @blocking_command(category='Patch',
                      description='Sequential patching and cleaning for multiple cells',
                      task_description='Sequential patch clamping')
    def sequential_patching(self):
        self.execute(self.current_autopatcher.sequential_patching)

    @blocking_command(category='Patch',
                      description='Moving down the calibrated manipulator to detect the contact point with the coverslip',
                      task_description='Contact detection')
    def contact_detection(self):
        # TODO: Figure out what this should link to
        self.execute(self.current_autopatcher.contact_detection)

    def set_pressure_near(self) -> None:
        '''puts the pipette under positive pressure to prevent blockages
        '''
        self.pressure.set_pressure(self.config.pressure_near)

================================================
File: /holypipette/exception_handler.py
================================================
# exception_handler.py
import sys
import logging

def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logging.error("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))

def set_global_exception_hook():
    sys.excepthook = handle_exception

================================================
File: /holypipette/controller/__init__.py
================================================
"""
Package defining `TaskController` classes. Objects of these classes are
responsible for the high-level logic of controlling the hardware, e.g. dealing
with the calibration of a manipulator, or defining the procedure for an
automatic patch clamp experiment.
"""
from .base import *
from .patch import *

================================================
File: /holypipette/controller/base.py
================================================
"""
Module defining the `TaskController` class.
"""
import functools
import time

from holypipette.log_utils import LoggingObject


class RequestedAbortException(Exception):
    """Exception that should be raised when a function aborts its execution due
       to ``abort_requested``."""
    pass


def check_for_abort(obj, func):
    """Decorator to make a function raise a `RequestedAbortException` if
       ``abort_requested`` attribute is set."""
    @functools.wraps(func)
    def decorated(*args, **kwds):
        if getattr(obj, 'abort_requested', False):
            raise RequestedAbortException()
        return func(*args, **kwds)
    return decorated


class TaskController(LoggingObject):
    """
    Base class for objects that control the high-level logic to control the
    hardware, e.g. the calibration of a manipulator or the steps to follow for
    a patch clamp experiment. Objects will usually be instantiated from more
    specific subclasses.

    The class provides several convenient ways to interact with an
    asynchronously requested abort of the current task. A long-running task
    can check explicitly whether an abort has been requested with
    `abort_if_requested` which will raise a `RequestedAbortException` if the
    ``abort_requested`` attribute has been set. This check will also be
    performed automatically if `~TaskController.debug`,
    `~TaskController.info`, or
    `~TaskController.warn` is called (which otherwise simply forward their
    message to the logging system). Finally, tasks should call `sleep`
    (instead of `time.sleep`) which will periodically check for an abort
    request during the sleep time.
    """
    def __init__(self):
        super(TaskController, self).__init__()
        self.abort_requested = False
        self.saved_state = None
        self.saved_state_question = None
        # Overwrite the logging functions so that they check for `abort_requested`
        self.debug = check_for_abort(self, self.debug)
        self.info = check_for_abort(self, self.info)
        self.warn = check_for_abort(self, self.warn)

    def abort_if_requested(self):
        """
        Checks for an abort request and interrupts the current task if
        necessary. Can be explicitly called during long-running tasks, but will
        also be called automatically by the logging functions `debug`, `info`,
        `warn`, or the wait function `sleep`.
        Raises
        ------
        RequestedAbortException
            If the `abort_requested` attribute is set
        """
        if self.abort_requested:
            raise RequestedAbortException()

    def sleep(self, seconds):
        """Convenience function that sleeps (as `time.sleep`) but remains
        sensitive to abort requests"""
        check_every = 0.25
        start = time.time()
        self.abort_if_requested()
        while time.time() - start < (seconds-check_every):
            time.sleep(check_every)
            self.abort_if_requested()

        remaining = seconds - (time.time() - start)
        if remaining > 0:
            time.sleep(remaining)
        self.abort_if_requested()

    # SAVED STATES:
    # Functions to overwrite to enable a reset of the state after a failed or
    # aborted task. Note that these functions are used for resets that are
    # optional, i.e. will only be performed after asking the user (with the
    # question defined in the `saved_state_question` attribute). For important
    # resets that should be performed right-away, regardless of any
    # user-interaction (e.g. resetting the pressure of the pressure controller),
    # rather use a try/finally construct in the respective function
    def save_state(self):
        """
        Save the current state (e.g. the position of the manipulators) for
        later recovery in the case of a failure or abort. Has to be overwritten
        in subclasses. Should save the state to the `saved_state` variable or
        overwrite `has_saved_state` as well.
        """
        pass

    def has_saved_state(self):
        """
        Whether this object has a saved state that can be recovered with
        `recover_state`.

        Returns
        -------
        has_state : bool
            Whether this object has a saved state. By default, checks whether
            the `saved_state` attribute is not ``None``.
        """
        return self.saved_state is not None

    def delete_state(self):
        """
        Delete any previously saved state. By default, overwrites the
        `saved_state` attribute with ``None``.
        """
        self.saved_state = None

    def recover_state(self):
        """
        Recover the state (e.g. the position of the manipulators) after a
        failure or abort. Has to be overwritten in subclasses.
        """
        pass


================================================
File: /holypipette/controller/patch.py
================================================
import time

import numpy as np
import cv2
import ctypes
from holypipette.devices.amplifier.amplifier import Amplifier
from holypipette.devices.amplifier.DAQ import DAQ
from holypipette.devices.manipulator.calibratedunit import CalibratedUnit, CalibratedStage
from holypipette.devices.manipulator.microscope import Microscope
from holypipette.devices.pressurecontroller import PressureController
import collections
import logging

from holypipette.interface.patchConfig import PatchConfig

from .base import TaskController


class AutopatchError(Exception):
    def __init__(self, message = 'Automatic patching error'):
        self.message = message

    def __str__(self):
        return self.message


class AutoPatcher(TaskController):
    def __init__(self, amplifier: Amplifier, daq: DAQ, pressure: PressureController, calibrated_unit: CalibratedUnit, microscope: Microscope, calibrated_stage: CalibratedStage, config : PatchConfig):
        super().__init__()
        self.config = config
        self.amplifier = amplifier
        self.daq = daq
        self.pressure = pressure
        self.calibrated_unit = calibrated_unit
        self.calibrated_stage = calibrated_stage
        self.microscope = microscope
        self.safe_position = None
        self.safe_stage_position = None
        self.home_position = None
        self.home_stage_position = None
        self.cleaning_bath_position = None
        self.rinsing_bath_position = None
        self.contact_position = None
        self.initial_resistance = None
        self.vholding = None
        self.iholding = None
        self.rig_ready = False
        

        self.current_protocol_graph = None
        
    def state_emitter(self, state):
        self.info(f"emitting state: {state}")

    def run_protocols(self):
        # TODO : implement an abort mechanism
        if self.config.voltage_protocol:
            self.run_voltage_protocol()
            self.sleep(0.25)
        if self.config.current_protocol:
            self.iholding = self.daq.holding_current
            # self.iholding = 0
            logging.debug(f"custom_current_protocol state: {self.config.custom_protocol}")
            logging.debug(f"start cclamp current: {self.config.cclamp_start}")
            logging.debug(f"end cclamp current: {self.config.cclamp_end}")
            logging.debug(f"step cclamp current: {self.config.cclamp_step}")
            self.run_current_protocol()
            self.sleep(0.25)
        if self.config.holding_protocol:
            self.run_holding_protocol()

    def run_voltage_protocol(self):
        self.info('Running voltage protocol (membrane test)')
        self.amplifier.voltage_clamp()
        self.sleep(0.25)
        holding = self.amplifier.get_holding()
        if holding is None:
            holding = -0.070
        self.amplifier.set_holding(holding)
        self.info(f'holding at {holding} mV')
        self.sleep(0.25)
        self.amplifier.switch_holding(True)
        self.info('enabled holding')
        self.sleep(0.25)
        self.info("Getting data from voltage protocol")
        self.daq.getDataFromVoltageProtocol()
        self.sleep(0.25)
        self.info('finished running voltage protocol (membrane test)')

    def run_current_protocol(self):
        self.info('Running current protocol (current clamp)')
        self.amplifier.voltage_clamp()
        self.sleep(0.1)
        self.amplifier.auto_fast_compensation()
        self.sleep(0.25)
        self.amplifier.auto_slow_compensation()
        self.sleep(0.25)
        self.info('auto capacitance compensation')  
        cap_c_double = self.amplifier.get_fast_compensation_capacitance()
        cap = float(cap_c_double.value) * 1e12 - 0.5
        cap = cap*1e-12
        self.info(f'fast compensation capacitance: {cap} pF' )
        self.sleep(0.1)
        self.amplifier.current_clamp()
        self.sleep(0.1)
        self.amplifier.set_bridge_balance(True)
        self.info('auto bridge balance')
        self.amplifier.auto_bridge_balance()
        self.sleep(0.1)
        self.amplifier.set_neutralization_capacitance(cap)
        self.info('set neutralization capacitance')
        self.amplifier.set_neutralization_enable(True)
        self.info('enabled neutralization')
        if self.iholding is None:
            current = -50

        else:
            current = (self.iholding)
        current = current * 1e-12
        self.amplifier.set_holding(current)
        self.info(f'holding at {current} pA')
        self.sleep(0.1)
        self.amplifier.switch_holding(True)
        self.info('enabled holding')
        self.sleep(0.1)
        if self.config.custom_protocol:
            self.debug('running custom current protocol')
            self.daq.getDataFromCurrentProtocol(custom =self.config.custom_protocol,factor= 1,startCurrentPicoAmp=(self.config.cclamp_start), endCurrentPicoAmp=(self.config.cclamp_end), stepCurrentPicoAmp=(self.config.cclamp_step), highTimeMs=400)                                            
        else:
            self.debug('running default current protocol')
            self.daq.getDataFromCurrentProtocol(custom=self.config.custom_protocol, factor=2, startCurrentPicoAmp=None, endCurrentPicoAmp=None, stepCurrentPicoAmp=10, highTimeMs=400)
        self.sleep(0.1)
        self.amplifier.switch_holding(False)
        self.info('disabled holding')
        self.sleep(0.1)
        self.amplifier.voltage_clamp()
        self.info('finished running current protocol(current clamp)')

    def run_holding_protocol(self):
        self.info('Running holding protocol (E/I PSC test)')
        self.amplifier.voltage_clamp()
        self.sleep(0.25)
        holding = self.amplifier.get_holding()
        if holding is None:
            holding = -0.070
        self.amplifier.set_holding(holding)
        self.info(f'holding at {holding} mV')
        self.sleep(0.25)
        self.daq.getDataFromHoldingProtocol()
        self.sleep(0.25)
        # self.amplifier.set_holding(0)
        self.sleep(0.25)
        self.amplifier.voltage_clamp()
        self.info('finished running holding protocol (E/I PSC test)')
    
    def isrigready(self):
        try:
            if not self.calibrated_unit.calibrated:
                raise AutopatchError("Pipette not calibrated")
            if not self.calibrated_stage.calibrated:
                raise AutopatchError("Stage not calibrated")
            if self.safe_position is None:
                raise ValueError('Safe position has not been set')
            if self.home_position is None:
                raise ValueError('Home position has not been set')
            if self.microscope.floor_Z is None:
                raise AutopatchError("Cell Plane not set")
            self.rig_ready = True
        except (AutopatchError, ValueError) as e:
            self.rig_ready = False
            raise e

    
    def hunt_cell(self,cell = None):
        '''
        Moves the pipette down to cell plane and detects a cell using resistance measurements
        '''
        self.info("Hunting for cell")
        
        self.isrigready()

        if self.rig_ready == False:
            raise AutopatchError("Rig not ready for cell hunting")
        
        if cell is None:
            raise AutopatchError("No cell given to patch!")

        # move stage and pipette to safe space
        self.move_to_safe_space()
        # set pipette pressure to 200 mbar
        self.pressure.set_pressure(200)
        # move to home space
        self.move_to_home_space()
        # center pipette and stage on cell XY
        cell_pos, cell_img = cell
        self.calibrated_stage._move(np.array([cell_pos[0], cell_pos[1], 0]))
        self.calibrated_stage.wait_until_still()
        # move stage and pipette to cell plane 

        self.calibrated_unit.absolute_move(np.array([0, 0, self.microscope.floor_Z]))
        self.microscope.absolute_move(self.microscope.floor_Z)

        # move stage and pipette rapidly down to initial distance above cell
        # let say we have the z position of the cell, we will move down to 25 um above it
        #TODO will check if distance move implementation is correct
        z_position = cell_pos[2]
        curr_position = self.calibrated_unit.position()
        desired_position = np.array([curr_position[0], curr_position[1], z_position - 25])
        # change to relative move distance
        dist = desired_position[2] - curr_position[2]
        self.move_group_down(dist=dist)
  
        #ensure "near cell" pressure
        self.pressure.set_pressure(self.config.pressure_near)

        lastResDeque = collections.deque(maxlen=3)
        # get initial resistance
        daqResistance = self.daq.resistance()
        lastResDeque.append(daqResistance)

        # move pipette down at 1um/s and check reistance every 50 ms
        # get starting position 
        start_pos = self.calibrated_unit.position()

        self.calibrated_unit.absolute_move_group_velocity(1, [2])
        self.calibrated_stage.microscope.absolute_move_velocity(1)
        while not self._isCellDetected(lastResDeque):
            curr_pos = self.calibrated_unit.position()
            if self.abort_requested():
                # stop the movement
                self.calibrated_unit.stop()
                self.calibrated_stage.microscope.stop()
                self.info("Hunt cancelled")
                break
            elif abs(curr_pos[2] - start_pos[2]) >= int(self.config.max_distance):
                # we have moved 25 um down and still no cell detected
                self.calibrated_unit.stop()
                self.calibrated_stage.microscope.stop()
                self.info("No cell detected")
                break
            elif self._isCellDetected(lastResDeque):
                self.info("Cell detected")
                self.calibrated_unit.stop()
                self.calibrated_stage.microscope.stop()
                break
            #TODO will add another condition to check if cell and pipette have moved away from each other based on the mask and original image.
            self.sleep(0.05)
            lastResDeque.append(daqResistance)
            daqResistance = self.daq.resistance()

    def gigaseal(self):
        lastResDeque = collections.deque(maxlen=3)
        # Release pressure
        self.info("Cell Detected, Lowering pressure")
        currPressure = 0
        self.pressure.set_pressure(currPressure)
        self.amplifier.set_holding(self.config.Vramp_amplitude)
        
        self.sleep(10)
        t0 = time.time()
        while daqResistance < self.config.gigaseal_R:
            t = time.time()
            if currPressure < -40:
                currPressure = 0
            self.pressure.set_pressure(currPressure)
                
            if t - t0 >= self.config.seal_deadline:
                # Time timeout for gigaseal
                self.amplifier.stop_patch()
                self.pressure.set_pressure(20)
                raise AutopatchError("Seal unsuccessful")
            
            # did we reach gigaseal?
            daqResistance = self.daq.resistance()
            lastResDeque.append(daqResistance)
            if daqResistance > self.config.gigaseal_R or len(lastResDeque) == 3 and all([lastResDeque == None for x in lastResDeque]):
                success = True
                break
            
            # else, wait a bit and lower pressure
            self.sleep(5)
            currPressure -= 10

        if not success:
            self.pressure.set_pressure(20)
            raise AutopatchError("Seal unsuccessful")

        self.info("Seal successful, R = " + str(self.daq.resistance() / 1e6))

    def break_in(self):
        '''
        Breaks in. The pipette must be in cell-attached mode
        '''
        self.info("Breaking in")
        measuredResistance = self.daq.resistance()
        # if R is not None and R < self.config.gigaseal_R:
        #     raise AutopatchError("Seal lost")

        pressure = 0
        trials = 0
        while measuredResistance is None or self.daq.resistance() > self.config.max_cell_R:  # Success when resistance goes below 300 MOhm
            trials += 1
            self.debug(f"Trial: {trials}")
            pressure += self.config.pressure_ramp_increment
            if abs(pressure) > abs(self.config.pressure_ramp_max):
                raise AutopatchError("Break-in unsuccessful")
            if self.config.zap:
                self.debug('zapping')
                self.amplifier.zap()
            self.pressure.ramp(amplitude=pressure, duration=self.config.pressure_ramp_duration)
            self.sleep(1.3)

        self.info("Successful break-in, R = " + str(self.daq.resistance() / 1e6))

    def _verify_resistance(self):
        return # * just for testing TODO: remove

        R = self.daq.resistance()

        if R < self.config.min_R:
            # print("Resistance is too low (broken tip?)")
            raise AutopatchError("Resistance is too low (broken tip?)")
        elif self.config.max_R < R:
            # print("Resistance is too high (obstructed?)")
            raise AutopatchError("Resistance is too high (obstructed?)")
        
    def _isCellDetected(self, lastResDeque, cellThreshold = 0.3*10**6):
        '''Given a list of three resistance readings, do we think there is a cell where the pipette is?
        '''
        print(lastResDeque)

        #criteria 1: the last three readings must be increasing
        if not lastResDeque[0] < lastResDeque[1] < lastResDeque[2]:
            return False #last three resistances must be ascending
        
        print('ascending')
        
        #criteria 2: there must be an increase of at least 0.3 mega ohms
        r_delta = lastResDeque[2] - lastResDeque[0]
        return cellThreshold <= r_delta

    def patch(self, cell=None):
        '''
        Runs the automatic patch-clamp algorithm, including manipulator movements.
        '''

        # ------ rig preparation -------------------------------#
        
        #check for stage and pipette calibration

        self.isrigready()
        if self.rig_ready == False:
            raise AutopatchError("Rig not ready for patching")
        
        if cell is None:
            raise AutopatchError("No cell given to patch!")

        #setup amp for patching
        self.amplifier.start_patch()
        #! phase 1: hunt for cell
        self.hunt_cell(cell)
        # move a bit further down to make sure we're at the cell
        self.calibrated_unit.relative_move(1, axis=2)
        #! phase 2: attempt to form a gigaseal
        self.gigaseal()

        #! Phase 3: break into cell
        self.break_in()

        #! Phase 4: run protocols
        self.run_protocols()

        #! Phase 5: clean pipette
        # move set pipette pressure to 25 mbar
        self.pressure.set_pressure(25)
        # move pipette and stage up 25 um
        self.move_group_up(dist=25)
        self.sleep(0.1)
        self.clean_pipette()

    def move_to_safe_space(self):
        '''
        Moves the pipette to the safe space.
        '''
        if self.safe_position is None:
            raise ValueError('Safe position has not been set')

        try:
            # Extract individual coordinates from the safe position
            safe_x, safe_y, safe_z = self.safe_position
            # safe_stage_x, safe_stage_y, safe_microscope_z = self.safe_stage_position
            # self.info(f"Moving to safe space: {safe_x}, {safe_y}, {safe_z}")

            # # Step 0: Move the microscope to the safe position
            # logging.debug(f'Moving microscope to safe position value: Z={safe_microscope_z}')
            # self.microscope.absolute_move(safe_microscope_z)
            # # Step 1: Move the stage to the safe position
            # self.calibrated_stage.absolute_move([safe_stage_x,safe_stage_y])

            # Step 2: Move Y axis first to align with the safe position value
            logging.debug(f'Moving Y axis to safe position value: {safe_y}')
            self.calibrated_unit.absolute_move(safe_y, axis=1)
            self.calibrated_unit.wait_until_still()  # Ensure movement completes

            # Step 3: Simultaneously move X and Z axes to reach the safe position
            logging.debug(f'Moving X and Z axes to safe position values: X={safe_x}, Z={safe_z}')
            self.calibrated_unit.absolute_move_group([safe_x,safe_y,safe_z], [0,1,2])
            self.calibrated_unit.wait_until_still()  # Ensure movement completes

        finally:
            pass
        
    def move_to_home_space(self):
        '''
        Moves the pipette to the home space.
        '''
        if self.home_position is None:
            raise ValueError('Home position has not been set')

        try:
            # # Extract individual coordinates from the home position
            home_x, home_y, home_z = self.home_position
            # stage_home_x, stage_home_y, microscope_home_z = self.home_stage_position
            # # step 0: move the microscope to the home position
            # logging.debug(f'Moving microscope to home position value: Z={microscope_home_z}')
            # self.microscope.absolute_move(microscope_home_z)
            # # Step 1: Move the stage to the home position
            # logging.debug(f'Moving stage to home position values: X={stage_home_x}, Y={stage_home_y}')
            # self.calibrated_stage.absolute_move([stage_home_x,stage_home_y])

            # Step 2: Move Y axis first to align with the home position value
            logging.debug(f'Moving Y axis to home position value: {home_y}')
            self.calibrated_unit.absolute_move(home_y, axis=1)
            self.calibrated_unit.wait_until_still()  # Ensure movement completes

            # Step 3: Simultaneously move X and Z axes to reach the home position
            logging.debug(f'Moving X and Z axes to home position values: X={home_x}, Z={home_z}')
            self.calibrated_unit.absolute_move_group([home_x,home_y,home_z], [0,1,2])
            self.calibrated_unit.wait_until_still()  # Ensure movement completes

        finally:
            pass

    def move_group_down(self,dist = 100):
        '''
        Moves the microsope and manipulator down by input distance in the z axis
        '''

        try:
            self.calibrated_unit.relative_move(dist, axis=2)
            self.calibrated_unit.wait_until_still(2)
            self.microscope.relative_move(dist)
            self.microscope.wait_until_still()
        finally:
            pass
    def move_group_up(self,dist = 100):
        '''
        Moves the microscope and manipulator up by input distance in the z axis
        '''
    
        try:
            self.calibrated_unit.relative_move(-dist, axis=2)
            self.calibrated_unit.wait_until_still(2)
            self.microscope.relative_move(-dist)
            self.microscope.wait_until_still()
        finally:
            pass
    
    def clean_pipette(self):
        if self.cleaning_bath_position is None:
            raise ValueError('Cleaning bath position has not been set')

        if self.safe_position is None:
            raise ValueError('Safe position has not been set')
        # TODO: implement an abort mechanism
        try:
            start_x, start_y, start_z = self.calibrated_unit.position()
            safe_x, safe_y, safe_z = self.safe_position
            # Step 1: Move to the safe space
            self.move_to_safe_space()
            clean_x, clean_y, clean_z = self.cleaning_bath_position
            # Step 2: Move the pipette above the cleaning bath in the x and y directions
            self.calibrated_unit.absolute_move(clean_y, axis=1)
            self.calibrated_unit.wait_until_still(1)
            self.calibrated_unit.absolute_move(clean_x, axis=0)
            self.calibrated_unit.wait_until_still(0)
            # Step 3: Move the pipette down to the cleaning bath
            self.calibrated_unit.absolute_move(clean_z, axis=2)
            self.calibrated_unit.wait_until_still(2)

            # Step 4: Cleaning
            # Fill up with the Alconox
            self.pressure.set_pressure(-600)
            self.sleep(1)
            # 5 cycles of tip cleaning
            for i in range(1, 5):
                self.pressure.set_pressure(-600)
                self.sleep(0.625)
                self.pressure.set_pressure(1000)
                self.sleep(0.375)

            # Step 5: Drying
            # move pipette back to safe space in reverse
            self.calibrated_unit.absolute_move(safe_z, axis=2)
            self.calibrated_unit.wait_until_still(2)
            self.calibrated_unit.absolute_move(safe_x, axis=0)
            self.calibrated_unit.wait_until_still(0)
            self.calibrated_unit.absolute_move(safe_y, axis=1)
            self.calibrated_unit.wait_until_still(1)

            self.pressure.set_pressure(-600)
            self.sleep(1)
            # 5 cycles of tip cleaning
            for i in range(1, 5):
                self.pressure.set_pressure(-600)
                self.sleep(0.625)
                self.pressure.set_pressure(1000)
                self.sleep(0.375)
            self.pressure.set_pressure(200)
  
            # Step 6: Move back to start from safespace
            self.calibrated_unit.absolute_move_group([start_x,safe_y,start_z], [0,1,2])
            self.calibrated_unit.wait_until_still()
            self.calibrated_unit.absolute_move(start_y, axis=1)
            self.calibrated_unit.wait_until_still() # Ensure movement completes
        finally:
            pass


================================================
File: /holypipette/deepLearning/pipetteModelTrainer/labeler/Labeler.py
================================================
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget, QPushButton,
    QFileDialog, QGraphicsView, QGraphicsScene, QGraphicsRectItem, QHBoxLayout,
    QFrame, QMessageBox, QShortcut, QInputDialog, QListWidget
)
from PyQt5.QtCore import Qt, QRectF, QPointF
from PyQt5.QtGui import QPixmap, QPen, QColor, QKeySequence
import os
import json
import sys

class ResizableRectItem(QGraphicsRectItem):
    """Custom QGraphicsRectItem that can be resized and holds a label. Used to make a bounding box."""
    def __init__(self, rect, label="", parent=None):
        super().__init__(rect, parent)
        self.setFlags(
            QGraphicsRectItem.ItemIsSelectable |
            QGraphicsRectItem.ItemIsMovable |
            QGraphicsRectItem.ItemSendsGeometryChanges
        )
        self.setAcceptHoverEvents(True)
        self.handle_size = 8.0
        self.handles = {}
        self._current_handle = None
        self._resizing = False
        self.update_handles()
        self.label = label  # Label for the bounding box

    def update_handles(self):
        """Update the positions of the resize handles."""
        s = self.handle_size
        rect = self.rect()
        self.handles = {
            'top_left': QRectF(rect.topLeft().x() - s/2, rect.topLeft().y() - s/2, s, s),
            'top_right': QRectF(rect.topRight().x() - s/2, rect.topRight().y() - s/2, s, s),
            'bottom_left': QRectF(rect.bottomLeft().x() - s/2, rect.bottomLeft().y() - s/2, s, s),
            'bottom_right': QRectF(rect.bottomRight().x() - s/2, rect.bottomRight().y() - s/2, s, s),
        }

    def paint(self, painter, option, widget=None):
        """Paint the rectangle and its resize handles."""
        super().paint(painter, option, widget)
        if self.isSelected():
            pen = QPen(QColor(0, 255, 0), 2, Qt.DashLine)
            painter.setPen(pen)
            painter.drawRect(self.rect())
            # Draw handles
            painter.setBrush(QColor(255, 0, 0))
            for handle in self.handles.values():
                painter.drawRect(handle)

    def hoverMoveEvent(self, event):
        """Change cursor when hovering over resize handles."""
        cursor = Qt.ArrowCursor
        for key, handle in self.handles.items():
            if handle.contains(event.pos()):
                if 'left' in key or 'right' in key:
                    if 'top' in key or 'bottom' in key:
                        cursor = Qt.SizeFDiagCursor
                break
        self.setCursor(cursor)
        super().hoverMoveEvent(event)

    def mousePressEvent(self, event):
        """Determine if a resize handle is pressed."""
        for key, handle in self.handles.items():
            if handle.contains(event.pos()):
                self._current_handle = key
                self._resizing = True
                break
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        """Resize the rectangle based on the handle being dragged."""
        if self._resizing and self._current_handle:
            rect = self.rect()
            delta = event.scenePos() - event.lastScenePos()
            if 'left' in self._current_handle:
                new_left = rect.left() + delta.x()
                if new_left < 0:
                    new_left = 0
                rect.setLeft(new_left)
            if 'right' in self._current_handle:
                new_right = rect.right() + delta.x()
                if new_right > self.scene().width():
                    new_right = self.scene().width()
                rect.setRight(new_right)
            if 'top' in self._current_handle:
                new_top = rect.top() + delta.y()
                if new_top < 0:
                    new_top = 0
                rect.setTop(new_top)
            if 'bottom' in self._current_handle:
                new_bottom = rect.bottom() + delta.y()
                if new_bottom > self.scene().height():
                    new_bottom = self.scene().height()
                rect.setBottom(new_bottom)
            self.setRect(rect)
            self.update_handles()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Reset resizing flags."""
        self._resizing = False
        self._current_handle = None
        super().mouseReleaseEvent(event)

class CustomGraphicsScene(QGraphicsScene):
    """Custom QGraphicsScene to handle drawing of bounding boxes."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.drawing = False
        self.start_point = QPointF()
        self.current_rect_item = None

    def mousePressEvent(self, event):
        """Start drawing a new rectangle only if click is not on an existing item."""
        if event.button() == Qt.LeftButton:
            items = self.items(event.scenePos())
            if not any(isinstance(item, ResizableRectItem) for item in items):
                self.drawing = True
                self.start_point = event.scenePos()
                self.current_rect_item = ResizableRectItem(QRectF(self.start_point, self.start_point))
                pen = QPen(QColor(255, 0, 0), 2)
                self.current_rect_item.setPen(pen)
                self.addItem(self.current_rect_item)
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        """Update the size of the rectangle being drawn."""
        if self.drawing and self.current_rect_item:
            rect = QRectF(self.start_point, event.scenePos()).normalized()
            self.current_rect_item.setRect(rect)
            self.current_rect_item.update_handles()
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Finish drawing the rectangle and assign label."""
        if event.button() == Qt.LeftButton and self.drawing:
            self.drawing = False
            if self.current_rect_item:
                rect = self.current_rect_item.rect()
                if rect.width() < 10 or rect.height() < 10:
                    self.removeItem(self.current_rect_item)
                else:
                    # Assign label
                    parent = self.parent()  # Reference to ImageLabeler
                    if parent.default_label:
                        label = parent.default_label
                        self.current_rect_item.label = label
                        self.current_rect_item.setToolTip(label)
                        parent.add_label_to_list(self.current_rect_item)
                        parent.save_bounding_boxes(parent.image_paths[parent.current_index])  # Save immediately
                    else:
                        # Prompt for label if no default_label is set
                        label, ok = QInputDialog.getText(None, "Input Label", "Enter label for the bounding box:")
                        if ok and label.strip():
                            self.current_rect_item.label = label.strip()
                            self.current_rect_item.setToolTip(label.strip())
                            parent.default_label = label.strip()  # Save as default label
                            parent.add_label_to_list(self.current_rect_item)
                            parent.save_bounding_boxes(parent.image_paths[parent.current_index])  # Save immediately
                        else:
                            # If no label is provided, remove the box
                            self.removeItem(self.current_rect_item)
            self.current_rect_item = None
        super().mouseReleaseEvent(event)

class ImageLabeler(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Image Labeler")
        self.setGeometry(50, 50, 1000, 800)  # Increased width to accommodate new button

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)

        self.main_layout = QVBoxLayout(self.central_widget)

        # Horizontal layout for image and side list
        self.top_layout = QHBoxLayout()

        # Graphics scene and view for bounding boxes
        self.scene = CustomGraphicsScene(self)
        self.view = QGraphicsView(self.scene, self)
        self.view.setMinimumSize(800, 600)

        # Side list for labeled bounding boxes
        self.list_widget = QListWidget()
        self.list_widget.setFixedWidth(300)  # Fixed width for the side list

        # Add the view and list widget to the top layout
        self.top_layout.addWidget(self.view)
        self.top_layout.addWidget(self.list_widget)
        self.main_layout.addLayout(self.top_layout)

        # Info pane layout for displaying messages to the user
        self.info_label = QLabel("No info yet!")
        self.info_label.setAlignment(Qt.AlignLeft)
        self.info_label.setFixedHeight(20)
        self.info_frame = QFrame()
        info_frame_layout = QHBoxLayout(self.info_frame)
        info_frame_layout.addWidget(self.info_label)
        self.info_frame.setFrameShape(QFrame.StyledPanel)
        self.info_frame.setFrameShadow(QFrame.Sunken)

        self.main_layout.addWidget(self.info_frame)

        # Add buttons for navigation and directory selection at the bottom
        self.buttons_layout = QHBoxLayout()

        self.load_button = QPushButton("Select Data Directory")
        self.load_button.clicked.connect(self.open_directory)

        self.prev_button = QPushButton("Previous Image")
        self.prev_button.clicked.connect(self.show_previous_image)

        self.next_button = QPushButton("Next Image")
        self.next_button.clicked.connect(self.show_next_image)

        # Add the new buttons: Delete Selected Box and Delete All Boxes
        self.delete_selected_button = QPushButton("Delete Selected Box")
        self.delete_selected_button.clicked.connect(self.delete_selected_box)

        self.delete_all_button = QPushButton("Delete All Boxes")
        self.delete_all_button.clicked.connect(self.delete_all_boxes)

        # *** New Button: Change Label Name ***
        self.change_label_button = QPushButton("Change Label Name")
        self.change_label_button.clicked.connect(self.change_label_name)
        # *** End of New Button ***

        self.buttons_layout.addWidget(self.prev_button)
        self.buttons_layout.addWidget(self.load_button)
        self.buttons_layout.addWidget(self.next_button)
        self.buttons_layout.addWidget(self.delete_selected_button)
        self.buttons_layout.addWidget(self.delete_all_button)
        self.buttons_layout.addWidget(self.change_label_button)  # Add new button to layout

        self.main_layout.addLayout(self.buttons_layout)

        # Set initial state
        self.image_paths = []
        self.labels_path = ''
        self.current_index = 0
        self.default_label = None  # To store the default label after first input

        self.label_ID = {
            "in_focus" : 0,
            "above_plane": 1,
            "below_plane": 2,
            "not_detected": 3
        } # parameterise the labels from words to numbers

        # Keyboard shortcuts
        self.shortcut_left = QShortcut(QKeySequence(Qt.Key_Left), self)
        self.shortcut_left.activated.connect(self.show_previous_image)
        self.shortcut_right = QShortcut(QKeySequence(Qt.Key_Right), self)
        self.shortcut_right.activated.connect(self.show_next_image)

    def refresh_list_widget(self):
        """Refresh the sidebar list_widget to reflect current labels."""
        self.list_widget.clear()
        for item in self.scene.items():
            if isinstance(item, ResizableRectItem):
                self.add_label_to_list(item)

    def add_label_to_list(self, rect_item):
        """Add a labeled bounding box to the side list."""
        label_text = f"Label: {rect_item.label}, " \
                     f"x: {rect_item.rect().x():.4f}, " \
                     f"y: {rect_item.rect().y():.4f}, " \
                     f"w: {rect_item.rect().width():.4f}, " \
                     f"h: {rect_item.rect().height():.4f}"
        self.list_widget.addItem(label_text)

    def remove_label_from_list(self, rect_item):
        """Remove a labeled bounding box from the side list."""
        # Iterate in reverse to safely remove items while iterating
        for index in reversed(range(self.list_widget.count())):
            item = self.list_widget.item(index)
            if (f"Label: {rect_item.label}," in item.text() and
                f"x: {rect_item.rect().x():.4f}," in item.text() and
                f"y: {rect_item.rect().y():.4f}," in item.text() and
                f"w: {rect_item.rect().width():.4f}," in item.text() and
                f"h: {rect_item.rect().height():.4f}" in item.text()):
                self.list_widget.takeItem(index)
                break

    def open_directory(self):
        """Open a directory with 'P_DET_IMAGES' and 'P_DET_LABELS' folders."""
        directory = QFileDialog.getExistingDirectory(self, "Open Directory", "")
        if directory:
            images_dir = os.path.join(directory, 'P_DET_IMAGES')
            labels_dir = os.path.join(directory, 'P_DET_LABELS')

            if os.path.exists(images_dir) and os.path.exists(labels_dir):
                self.load_images_from_directory(images_dir)
                self.labels_path = labels_dir
                self.info_label.setText(f"Loaded images and labels from {directory}.")
                if self.image_paths:
                    self.current_index = 0
                    self.display_image(self.image_paths[self.current_index])
            else:
                QMessageBox.warning(self, "Directory Error",
                                    "Selected folder must contain 'P_DET_IMAGES' and 'P_DET_LABELS' subfolders.")

    def load_images_from_directory(self, directory):
        """Load images from the 'P_DET_IMAGES' folder."""
        if not os.path.exists(directory):
            self.info_label.setText(f"Directory {directory} does not exist")
            return

        self.image_paths = [os.path.join(directory, f) for f in os.listdir(directory)
                           if f.lower().endswith(('.png', '.jpg', '.jpeg', '.webp'))]
        if not self.image_paths:
            self.info_label.setText(f"No images found in {directory}")
            return

        self.current_index = 0
        self.info_label.setText(f"Loaded {len(self.image_paths)} images.")

    def display_image(self, image_path):
        """Display the image on the QGraphicsView using QGraphicsScene."""
        if not os.path.exists(image_path):
            QMessageBox.warning(self, "Error", f"Image file {image_path} does not exist.")
            return  # Exit if image path is invalid

        pixmap = QPixmap(image_path)
        if pixmap.isNull():
            QMessageBox.warning(self, "Error", "Unable to load image.")
        else:
            # Clear the scene to remove any previous content
            self.scene.clear()

            # Add the image to the QGraphicsScene
            pixmap_item = self.scene.addPixmap(pixmap)
            pixmap_item.setZValue(-1)  # Ensure the image is at the back

            # Fit the image to the view
            self.view.fitInView(pixmap_item, Qt.KeepAspectRatio)
            self.info_label.setText(f"Displaying {os.path.basename(image_path)}")

            # Load bounding boxes for the image
            self.load_bounding_boxes(image_path)

    def load_bounding_boxes(self, image_path, format="txt"):
        """Load bounding boxes from the corresponding label file."""
        extension = '.json' if format == "json" else '.txt'
        label_file = os.path.join(
            self.labels_path,
            os.path.basename(image_path).rsplit('.', 1)[0] + extension
        )

        self.list_widget.clear()  # Clear the side list

        if os.path.exists(label_file):
            try:
                if format == "json":
                    with open(label_file, 'r') as f:
                        data = json.load(f)
                        bounding_boxes = data.get('bounding_boxes', [])
                        # Update labels to use the label_ID dictionary
                        for box in bounding_boxes:
                            label = box.get('label', '')
                            if label in self.label_ID:
                                box['label'] = self.label_ID[label]  # Replace string label with numeric ID

                else:
                    bounding_boxes = []
                    with open(label_file, 'r') as f:
                        for line in f:
                            parts = line.strip().split()
                            if len(parts) == 5:
                                label_num, x_center, y_center, width, height = map(float, parts[1:])
                                label = next((key for key, val in self.label_ID.items() if val == int(parts[0])), "")
                                bounding_boxes.append({
                                    'label': label,
                                    'x_center': x_center,
                                    'y_center': y_center,
                                    'width': width,
                                    'height': height
                                })

                # Handle the default label (preserving across images)
                if not self.default_label:
                    for box in bounding_boxes:
                        label = box.get('label', '')
                        if label:
                            self.default_label = label
                            break

                # Convert YOLO format to pixel coordinates and add to the scene
                pixmap = QPixmap(image_path)
                image_width = pixmap.width()
                image_height = pixmap.height()

                for box in bounding_boxes:
                    label = box.get('label', '')
                    x_center = box.get('x_center', 0)
                    y_center = box.get('y_center', 0)
                    width = box.get('width', 0)
                    height = box.get('height', 0)

                    x = (x_center - width / 2) * image_width
                    y = (y_center - height / 2) * image_height
                    w = width * image_width
                    h = height * image_height

                    rect = QRectF(x, y, w, h)
                    rect_item = ResizableRectItem(rect, label)
                    rect_item.setPen(QPen(QColor(255, 0, 0), 2))
                    self.scene.addItem(rect_item)
                    self.add_label_to_list(rect_item)

                self.info_label.setText(f"Loaded labels for {os.path.basename(image_path)}")

            except (json.JSONDecodeError, ValueError):
                QMessageBox.warning(self, "Error", f"Invalid format in {label_file}.")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to load bounding boxes: {e}")
        else:
            self.info_label.setText(f"No labels found for {os.path.basename(image_path)}")

    def save_bounding_boxes(self, image_path, format="txt"):
        """Save bounding boxes to the corresponding label file in YOLO format."""
        label_file = os.path.join(
            self.labels_path,
            os.path.basename(image_path).rsplit('.', 1)[0] + '.json'
        )
        bounding_boxes = []
        pixmap = QPixmap(image_path)
        image_width = pixmap.width()
        image_height = pixmap.height()

        for item in self.scene.items():
            if isinstance(item, ResizableRectItem):
                rect = item.rect()
                # Calculate YOLO format
                x_center = (rect.x() + rect.width() / 2) / image_width
                y_center = (rect.y() + rect.height() / 2) / image_height
                width = rect.width() / image_width
                height = rect.height() / image_height
                bounding_boxes.append({
                    'label': item.label,
                    'x_center': round(x_center, 6),
                    'y_center': round(y_center, 6),
                    'width': round(width, 6),
                    'height': round(height, 6)
                })
        if format == "json":
            extension = '.json' 
        else:
            extension = '.txt'
        label_file = os.path.join(self.labels_path, os.path.basename(image_path).rsplit('.', 1)[0] + extension)

        try:
            with open(label_file, 'w') as f:
                if format == "json":
                    json.dump({'bounding_boxes': bounding_boxes}, f, indent=4)
                else:
                    for box in bounding_boxes:
                        label_number = self.label_ID.get(box['label'], -1)
                        if label_number != -1:
                            f.write(f"{label_number} {box['x_center']} {box['y_center']} {box['width']} {box['height']}\n")

            self.info_label.setText(f"Saved labels for {os.path.basename(image_path)}")
        except IOError as e:
            QMessageBox.warning(self, "Save Error", f"Failed to save labels: {e}")

    def show_previous_image(self):
        """Show the previous image and load its bounding boxes."""
        if self.current_index > 0:
            current_image = self.image_paths[self.current_index]
            self.save_bounding_boxes(current_image)  # Save before switching
            self.current_index -= 1
            self.display_image(self.image_paths[self.current_index])
        else:
            QMessageBox.information(self, "Start of List", "This is the first image.")

    def show_next_image(self):
        """Show the next image and load its bounding boxes."""
        if self.current_index < len(self.image_paths) - 1:
            current_image = self.image_paths[self.current_index]
            self.save_bounding_boxes(current_image)  # Save before switching
            self.current_index += 1
            self.display_image(self.image_paths[self.current_index])
        else:
            QMessageBox.information(self, "End of List", "This is the last image.")

    def delete_selected_box(self):
        """Delete the currently selected bounding box."""
        selected_items = self.scene.selectedItems()
        if not selected_items:
            QMessageBox.information(self, "No Selection", "No box is selected to delete.")
            return
        for item in selected_items:
            if isinstance(item, ResizableRectItem):
                self.remove_label_from_list(item)
                self.scene.removeItem(item)
        # Save changes after deletion
        if self.image_paths:
            current_image = self.image_paths[self.current_index]
            self.save_bounding_boxes(current_image)
        self.info_label.setText("Selected box(es) deleted.")

    def delete_all_boxes(self):
        """Delete all bounding boxes in the current image."""
        items_to_remove = [item for item in self.scene.items() if isinstance(item, ResizableRectItem)]
        if not items_to_remove:
            QMessageBox.information(self, "No Boxes", "There are no boxes to delete.")
            return
        for item in items_to_remove:
            self.remove_label_from_list(item)
            self.scene.removeItem(item)
        # Save changes after deletion
        if self.image_paths:
            current_image = self.image_paths[self.current_index]
            self.save_bounding_boxes(current_image)
        self.info_label.setText("All boxes deleted.")

    def change_label_name(self):
        """Change the label name for the selected box and all subsequent boxes."""
        selected_items = self.scene.selectedItems()
        if not selected_items:
            QMessageBox.information(self, "No Selection", "Please select a box to change its label.")
            return

        # Prompt the user to enter a new label
        new_label, ok = QInputDialog.getText(self, "Change Label Name", "Enter new label name:")
        if not ok or not new_label.strip():
            QMessageBox.information(self, "No Input", "No label name was entered.")
            return

        new_label = new_label.strip()

        # Get the selected box
        selected_item = selected_items[0]
        if not isinstance(selected_item, ResizableRectItem):
            QMessageBox.warning(self, "Invalid Selection", "Selected item is not a bounding box.")
            return

        # Update the label for the selected box and all subsequent boxes
        boxes = [item for item in self.scene.items() if isinstance(item, ResizableRectItem)]
        # Sort boxes based on their creation order (assuming last items are newer)
        boxes_sorted = sorted(boxes, key=lambda x: self.scene.items().index(x), reverse=True)
        try:
            selected_index = boxes_sorted.index(selected_item)
        except ValueError:
            QMessageBox.warning(self, "Error", "Selected box not found.")
            return

        # Only update the selected box and boxes created after it
        for box in boxes_sorted[:selected_index + 1]:
            box.label = new_label
            box.setToolTip(new_label)

        # Update the default_label for future boxes
        self.default_label = new_label

        # Refresh the sidebar to reflect label changes
        self.refresh_list_widget()

        # Save the updated labels to the file
        if self.image_paths:
            current_image = self.image_paths[self.current_index]
            self.save_bounding_boxes(current_image)

        self.info_label.setText(f"Label changed to '{new_label}' for selected and subsequent boxes.")

    def update_list_widget(self, rect_item):
        """Update the corresponding list widget entry for a rect_item."""
        for index in range(self.list_widget.count()):
            item = self.list_widget.item(index)
            # To ensure accurate matching, split the text and compare positions
            item_parts = item.text().split(", ")
            if len(item_parts) >= 1 and item_parts[0].startswith("Label:"):
                current_label = item_parts[0].split("Label:")[1].strip()
                x = float(item_parts[1].split("x:")[1].strip())
                y = float(item_parts[2].split("y:")[1].strip())
                w = float(item_parts[3].split("w:")[1].strip())
                h = float(item_parts[4].split("h:")[1].strip())
                if (current_label == rect_item.label and
                    abs(x - rect_item.rect().x()) < 0.0001 and
                    abs(y - rect_item.rect().y()) < 0.0001 and
                    abs(w - rect_item.rect().width()) < 0.0001 and
                    abs(h - rect_item.rect().height()) < 0.0001):
                    # Reconstruct the label text with updated label
                    label_text = f"Label: {rect_item.label}, " \
                                 f"x: {rect_item.rect().x():.4f}, " \
                                 f"y: {rect_item.rect().y():.4f}, " \
                                 f"w: {rect_item.rect().width():.4f}, " \
                                 f"h: {rect_item.rect().height():.4f}"
                    self.list_widget.item(index).setText(label_text)
                    break

    def closeEvent(self, event):
        """Prompt to save bounding boxes on exit."""
        reply = QMessageBox.question(self, 'Quit',
                                     "Do you want to save changes before quitting?",
                                     QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel,
                                     QMessageBox.Yes)
        if reply == QMessageBox.Yes:
            if self.image_paths:
                current_image = self.image_paths[self.current_index]
                self.save_bounding_boxes(current_image)
            event.accept()
        elif reply == QMessageBox.No:
            event.accept()
        else:
            event.ignore()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    labeler = ImageLabeler()
    labeler.show()
    sys.exit(app.exec_())

================================================
File: /holypipette/deepLearning/pipetteModelTrainer/labeler/LabelResizer.py
================================================
import os

# Parameters to adjust the bounding box size
ADJUST_AMOUNT = (5/3)  # Modify this value to control the adjustment

def adjust_bounding_box_size(folder_path, adjust_amount):
    # Loop through all files in the specified folder
    for file_name in os.listdir(folder_path):
        if file_name.endswith('.txt'):
            file_path = os.path.join(folder_path, file_name)

            with open(file_path, 'r') as file:
                lines = file.readlines()

            # Store adjusted bounding boxes
            updated_lines = []

            for line in lines:
                components = line.strip().split()
                
                if len(components) != 5:
                    # Skip invalid lines
                    continue
                
                class_id = components[0]
                x_center = float(components[1])
                y_center = float(components[2])
                width = float(components[3])
                height = float(components[4])

                # Adjust width and height
                new_width = max(0, min(1, width*adjust_amount))
                new_height = max(0, min(1, height*adjust_amount))

                # Format and add the updated line
                updated_line = f"{class_id} {x_center:.6f} {y_center:.6f} {new_width:.6f} {new_height:.6f}\n"
                updated_lines.append(updated_line)

            # Write the updated bounding boxes back to the file
            with open(file_path, 'w') as file:
                file.writelines(updated_lines)

# Specify the folder containing YOLO label files
folder_path = r"C:\Users\sa-forest\GaTech Dropbox\Benjamin Magondu\YOLOretrainingdata\classified_images\focus_set-2\P_DET_LABELS"  # Replace with your folder path

# Call the function to adjust bounding box sizes
adjust_bounding_box_size(folder_path, ADJUST_AMOUNT)


================================================
File: /holypipette/deepLearning/pipetteModelTrainer/labeler/Labeler_guide.ipynb
================================================
{"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# Image Labeling Tool User Guide\n", "\n", "Welcome to the Image Labeling Tool User Guide! This notebook provides a comprehensive overview of how to set up, run, and utilize the Image Labeling Tool designed for generating bounding box labels for images. Whether you're preparing data for machine learning models like YOLOv8 or organizing your image datasets, this guide will help you navigate the tool's functionalities effectively."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Table of Contents\n", "1. [Introduction](#introduction)\n", "2. [Prerequisites](#prerequisites)\n", "3. [Setup Instructions](#setup-instructions)\n", "4. [Running the Application](#running-the-application)\n", "5. [Using the Image Labeler](#using-the-image-labeler)\n", "    - [Selecting the Data Directory](#1-selecting-the-data-directory)\n", "    - [Navigating Between Images](#2-navigating-between-images)\n", "    - [Creating Bounding Boxes](#3-creating-bounding-boxes)\n", "    - [Labeling Bounding Boxes](#4-labeling-bounding-boxes)\n", "    - [Changing Label Names](#5-changing-label-names)\n", "    - [Deleting Bounding Boxes](#6-deleting-bounding-boxes)\n", "6. [Saving and Persisting Labels](#saving-and-persisting-labels)\n", "7. [Troubleshooting](#troubleshooting)\n", "8. [Best Practices](#best-practices)\n", "9. [Conclusion](#conclusion)\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Introduction\n", "\n", "The **Image Labeling Tool** is a Python-based application that allows users to create, manage, and save bounding box annotations for images. It's particularly useful for preparing datasets for object detection models like YOLOv8. The tool provides an intuitive graphical user interface (GUI) built with PyQt5, enabling users to draw and label bounding boxes, navigate through images, and manage annotations efficiently."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Prerequisites\n", "\n", "Before setting up and using the Image Labeling Tool, ensure that the following prerequisites are met:\n", "\n", "1. **Operating System:**\n", "    - Windows, macOS, or Linux.\n", "\n", "2. **Python Installation:**\n", "    - **Python 3.6** or higher is required.\n", "    - Download Python from the [official website](https://www.python.org/downloads/).\n", "\n", "3. **Python Libraries:**\n", "    - **PyQt5:** For the GUI components.\n", "    - **Other Standard Libraries:** `os`, `json`, `sys` (usually included with Python).\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Setup Instructions\n", "\n", "Follow these steps to set up the Image Labeling Tool on your system:\n", "\n", "1. **Install Python 3.6 or Higher:**\n", "    - If you haven't installed Python yet, download and install it from the [official Python website](https://www.python.org/downloads/).\n", "    - During installation, ensure that you check the option to add Python to your system's PATH.\n", "\n", "2. **Install Required Python Libraries:**\n", "    - Open your terminal or command prompt.\n", "    - Install PyQt5 using `pip` by running the following command:\n", "      ```bash\n", "      pip install PyQt5\n", "      ```\n", "    - *Note:* If you encounter permission issues, you might need to use `pip3` or add `--user`:\n", "      ```bash\n", "      pip3 install PyQt5\n", "      ```\n", "      or\n", "      ```bash\n", "      pip install --user PyQt5\n", "      ```\n", "\n", "3. **Prepare Directory Structure:**\n", "    - Create a main directory where you will store your images and labels.\n", "    - Inside this main directory, create two subdirectories:\n", "      - **P_DET_IMAGES:** To store all the images you want to label.\n", "      - **P_DET_LABELS:** This will store the JSON files containing your bounding box labels.\n", "    - **Example Structure:**\n", "      ```\n", "      /Your_Main_Directory\n", "        /P_DET_IMAGES\n", "            image1.jpg\n", "            image2.png\n", "        /P_DET_LABELS\n", "            image1.json\n", "            image2.json\n", "      ```\n", "4. **Place Images for Labeling:**\n", "    - Copy or move all the images you intend to label into the `P_DET_IMAGES` folder. Supported formats include `.png`, `.jpg`, `.jpeg`, and `.webp`.\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Running the Application\n", "\n", "1. **Navigate to the Script Directory:**\n", "    - Open your terminal or command prompt.\n", "    - Change the directory to where the Image Labeling Tool script is located using the `cd` command.\n", "      ```bash\n", "      cd /path/to/your/script\n", "      ```\n", "\n", "2. **Run the Script:**\n", "    - Execute the script using Python:\n", "      ```bash\n", "      python image_labeler.py\n", "      ```\n", "    - *Note:* Replace `image_labeler.py` with the actual name of your script file if different.\n", "\n", "3. **Launching the GUI:**\n", "    - Upon running the script, a window titled **\"Image Labeler\"** will appear, presenting the main interface.\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Using the Image Labeler\n", "\n", "The Image Labeler interface consists of several components:\n", "\n", "- **Image Display Area:** Shows the current image with existing bounding boxes.\n", "- **Sidebar (`list_widget`):** Displays a list of all labeled bounding boxes for the current image, including labels and their coordinates.\n", "- **Info Pane:** Provides informational messages and statuses.\n", "- **Control Buttons:** Allow you to select directories, navigate images, delete bounding boxes, and change label names.\n", "\n", "Let's walk through each functionality step-by-step."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### 1. Selecting the Data Directory\n", "\n", "**Purpose:**\n", "To load images and corresponding labels into the application.\n", "\n", "**Steps:**\n", "\n", "1. **Click the \"Select Data Directory\" Button:**\n", "   - Located at the bottom of the window among other control buttons.\n", "\n", "2. **Choose the Main Directory:**\n", "   - A file dialog will appear. Navigate to and select the **main directory** that contains both `P_DET_IMAGES` and `P_DET_LABELS` folders.\n", "   - *Example Path:* `/Users/YourName/Documents/ImageLabeling/P_DET_IMAGES`\n", "\n", "3. **Confirmation:**\n", "   - After selection, the application will load all images from `P_DET_IMAGES` and their corresponding labels from `P_DET_LABELS`.\n", "   - The info pane will display a message like:\n", "     ```\n", "     Loaded images and labels from /path/to/your/main/directory.\n", "     ```\n", "\n", "4. **First Image Display:**\n", "   - The first image in the `P_DET_IMAGES` folder will be displayed along with any existing bounding boxes.\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### 2. Navigating Between Images\n", "\n", "**Purpose:**\n", "To move through your collection of images for labeling or review.\n", "\n", "**Control Buttons:**\n", "\n", "- **\"Previous Image\":** Navigate to the previous image in the list.\n", "- **\"Next Image\":** Navigate to the next image in the list.\n", "\n", "**Keyboard Shortcuts:**\n", "\n", "- **Left Arrow Key (`\u2190`):** Equivalent to clicking \"Previous Image\".\n", "- **Right Arrow Key (`\u2192`):** Equivalent to clicking \"Next Image\".\n", "\n", "**Steps:**\n", "\n", "1. **Using Control Buttons:**\n", "   - Click **\"Previous Image\"** to view the image before the current one.\n", "   - Click **\"Next Image\"** to view the image after the current one.\n", "\n", "2. **Using Keyboard Shortcuts:**\n", "   - Press the **Left Arrow Key** to go to the previous image.\n", "   - Press the **Right Arrow Key** to go to the next image.\n", "\n", "**Behavior:**\n", "- **Saving Labels:**\n", "  - When navigating away from the current image, any unsaved labels (bounding boxes) will be automatically saved to the corresponding JSON file.\n", "- **Info Pane Messages:**\n", "  - Displays messages like:\n", "    ```\n", "    Displaying image1.jpg\n", "    ```\n", "- **Boundary Conditions:**\n", "  - If you attempt to navigate beyond the first or last image, a message will inform you:\n", "    ```\n", "    This is the first image.\n", "    ```\n", "    or\n", "    ```\n", "    This is the last image.\n", "    ```\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### 3. Creating Bounding Boxes\n", "\n", "**Purpose:**\n", "To draw rectangular areas around objects or regions of interest within an image.\n", "\n", "**Steps:**\n", "\n", "1. **Initiate Drawing:**\n", "   - Move your cursor to the **Image Display Area**.\n", "   - **Click and Drag:**\n", "     - Press and hold the **Left Mouse Button** at the starting point.\n", "     - Drag the mouse to form the desired rectangle.\n", "     - Release the button to finalize the bounding box.\n", "\n", "2. **Bounding Box Appearance:**\n", "   - A red-bordered rectangle will appear, representing the bounding box.\n", "   - If the box is smaller than 10x10 pixels, it will be automatically removed to prevent accidental or insignificant annotations.\n", "\n", "3. **Label Assignment:**\n", "   - **First Bounding Box:**\n", "     - Upon creating the first bounding box in an image, you will be prompted to **enter a label name**.\n", "     - Enter a descriptive label (e.g., \"Person\", \"Car\", \"Tree\") and confirm.\n", "     - This label becomes the **default label** for all subsequent bounding boxes in the current image.\n", "   - **Subsequent Bounding Boxes:**\n", "     - New bounding boxes will automatically inherit the **default label** without prompting.\n"]}, {"cell_type": "markdown", "metadata": {}, "source": ["### 4. Labeling Bounding Boxes\n", "\n", "**Purpose:**\n", "To assign meaningful names to the annotated regions, facilitating tasks like object detection in machine learning models.\n", "\n", "**Automatic Labeling:**\n", "- **Default Label:**\n", "  - After assigning a label to the first bounding box in an image, all subsequent bounding boxes will automatically use this **default label** without requiring further input.\n", "\n", "**Changing Labels:**\n", "- **\"Change Label Name\" Button:**\n", "  - Allows you to change the label of a selected bounding box and all bounding boxes created after it.\n", "  - This updates both the JSON label file and the sidebar (`list_widget`).\n", "\n", "**Steps to Change Labels:**\n", "1. **Select the Bounding Box:**\n", "   - Click on the bounding box you wish to modify to **select** it. The selected box will be highlighted (e.g., with a green dashed border).\n", "2. **Click \"Change Label Name\":**\n", "   - Located among the control buttons at the bottom of the window.\n", "3. **Enter New Label:**\n", "   - A prompt will appear asking for the **new label name**.\n", "   - Input the desired label (e.g., changing from \"Car\" to \"Truck\") and confirm.\n", "4. **Automatic Updates:**\n", "   - The selected bounding box and all boxes created **after** it will update to the new label.\n", "   - The sidebar will reflect these changes immediately."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### 5. Changing Label Names\n", "\n", "**Purpose:**\n", "To update the labels of bounding boxes for consistency, correction, or refinement of annotations.\n", "\n", "**Using the \"Change Label Name\" Feature:**\n", "\n", "1. **Select the Target Bounding Box:**\n", "   - Click on the bounding box whose label you want to change. Ensure it's highlighted to indicate selection.\n", "\n", "2. **Click the \"Change Label Name\" Button:**\n", "   - Located at the bottom of the application window.\n", "\n", "3. **Input New Label:**\n", "   - A dialog box will appear prompting you to **enter the new label name**.\n", "   - Type the desired label and confirm.\n", "\n", "4. **Automatic Application:**\n", "   - The new label will be applied to the **selected bounding box** and **all bounding boxes created after it** in the current image.\n", "   - The sidebar will automatically refresh to display the updated labels and coordinates."]}, {"cell_type": "markdown", "metadata": {}, "source": ["### 6. Deleting Bounding Boxes\n", "\n", "**Purpose:**\n", "To remove incorrect, redundant, or unnecessary bounding boxes from an image.\n", "\n", "**Control Buttons:**\n", "- **\"Delete Selected Box\":**\n", "  - Removes the currently **selected** bounding box.\n", "- **\"Delete All Boxes\":**\n", "  - Removes **all** bounding boxes from the current image.\n", "\n", "**Steps to Delete a Selected Bounding Box:**\n", "\n", "1. **Select the Bounding Box:**\n", "   - Click on the bounding box you wish to delete to **select** it. The selected box will be highlighted.\n", "\n", "2. **Click \"Delete Selected Box\":**\n", "   - Located among the control buttons at the bottom of the window.\n", "\n", "3. **Confirmation:**\n", "   - The bounding box will be removed from the image display area and the sidebar.\n", "\n", "**Steps to Delete All Bounding Boxes:**\n", "\n", "1. **Ensure No Bounding Boxes Are Selected:**\n", "   - If you have a bounding box selected, it will also be removed upon deletion.\n", "\n", "2. **Click \"Delete All Boxes\":**\n", "   - Located among the control buttons at the bottom of the window.\n", "\n", "3. **Confirmation:**\n", "   - All bounding boxes will be cleared from the image display area and the sidebar."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Saving and Persisting Labels\n", "\n", "**Automatic Saving:**\n", "\n", "- **When to Save:**\n", "  - Labels are automatically saved when you navigate away from an image (e.g., clicking \"Next Image\" or \"Previous Image\").\n", "  - Labels are also saved immediately after creating, changing, or deleting bounding boxes.\n", "\n", "- **JSON Label Files:**\n", "  - Each image has a corresponding `.json` file in the `P_DET_LABELS` folder.\n", "  - The JSON file follows the YOLO format, storing bounding box coordinates and labels.\n", "\n", "**Ensuring Data Integrity:**\n", "\n", "- **Prompt on Exit:**\n", "  - When closing the application, you will be prompted to **save changes** to ensure that all annotations are preserved.\n", "\n", "- **Consistent Formatting:**\n", "  - The application maintains the YOLO format for all label files, ensuring compatibility with YOLOv8 training models."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Troubleshooting\n", "\n", "**Common Issues and Solutions:**\n", "\n", "1. **PyQt5 Not Installed Properly:**\n", "    - **Symptom:**\n", "      - Error messages related to missing PyQt5 modules when running the script.\n", "    - **Solution:**\n", "      - Reinstall PyQt5 using `pip`:\n", "        ```bash\n", "        pip install PyQt5\n", "        ```\n", "      - Ensure that you're using the correct Python environment where PyQt5 is installed.\n", "\n", "2. **No Images Loaded After Selecting Directory:**\n", "    - **Symptom:**\n", "      - The application doesn't display any images after selecting the data directory.\n", "    - **Solution:**\n", "      - Verify that the `P_DET_IMAGES` folder contains supported image formats (`.png`, `.jpg`, `.jpeg`, `.webp`).\n", "      - Ensure that the `P_DET_LABELS` folder exists, even if it's empty.\n", "\n", "3. **Labels Not Saving Correctly:**\n", "    - **Symptom:**\n", "      - Bounding boxes appear but don't persist after closing or navigating images.\n", "    - **Solution:**\n", "      - Check write permissions for the `P_DET_LABELS` folder.\n", "      - Ensure that the application has access to create and modify JSON files within this folder.\n", "\n", "4. **Application Crashes or Freezes:**\n", "    - **Symptom:**\n", "      - Unexpected closure or unresponsiveness of the application.\n", "    - **Solution:**\n", "      - Ensure that your system meets the prerequisites.\n", "      - Check for any error messages in the terminal or command prompt where you ran the script for more details.\n", "      - Restart the application and try again.\n", "\n", "5. **Incorrect Bounding Box Coordinates:**\n", "    - **Symptom:**\n", "      - Bounding boxes appear misplaced or incorrectly sized.\n", "    - **Solution:**\n", "      - Ensure that images are correctly loaded and displayed.\n", "      - Verify that the script correctly converts YOLO format coordinates to pixel values."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Best Practices\n", "\n", "1. **Consistent Labeling:**\n", "    - Use uniform naming conventions for labels to maintain consistency across your dataset (e.g., always use \"Car\" instead of alternating between \"Car\" and \"vehicle\").\n", "\n", "2. **Regular Saving:**\n", "    - Although the application saves changes automatically, it's good practice to periodically verify that your labels are being saved correctly, especially after making significant changes.\n", "\n", "3. **Backup Label Files:**\n", "    - Keep backups of your `P_DET_LABELS` folder to prevent data loss in case of accidental deletions or corruption.\n", "\n", "4. **Quality Control:**\n", "    - Regularly review your labeled images to ensure accuracy and consistency, making corrections as needed.\n", "\n", "5. **Optimizing Image Sizes:**\n", "    - Use images with appropriate resolutions to facilitate precise bounding box placement without unnecessary pixelation or blurriness."]}, {"cell_type": "markdown", "metadata": {}, "source": ["## Conclusion\n", "\n", "The **Image Labeling Tool** is a powerful and user-friendly application designed to streamline the process of creating bounding box annotations for images. By following this guide, you can efficiently label your datasets, ensuring that your machine learning models are trained with accurate and consistent data.\n", "\n", "**Happy Labeling!**\n", "\n", "If you encounter any further issues or have suggestions for improvements, feel free to reach out or consult the troubleshooting section above."]}], "metadata": {"kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"name": "python", "version": "3.8.5"}}, "nbformat": 4, "nbformat_minor": 5}

================================================
File: /holypipette/deepLearning/pipetteModelTrainer/Dataset/P_DET_LABELS/10116_1723491320.424536.json
================================================
{"bounding_boxes": []}

================================================
File: /holypipette/deepLearning/pipetteModelTrainer/Dataset/P_DET_LABELS/10120_1723491320.488632.json
================================================
{"bounding_boxes": []}

================================================
File: /holypipette/deepLearning/pipetteModelTrainer/Dataset/P_DET_LABELS/10118_1723491320.455496.json
================================================
{"bounding_boxes": []}

================================================
File: /holypipette/deepLearning/pipetteModelTrainer/Dataset/P_DET_LABELS/10114_1723491320.392975.json
================================================
{"bounding_boxes": []}

================================================
File: /holypipette/deepLearning/pipetteFocuser.py
================================================
import onnxruntime as ort
import numpy as np
import cv2
import time
from pathlib import Path
from enum import Enum
import random
import os

class FocusLevels(Enum):
    IN_FOCUS = 0
    OUT_OF_FOCUS_UP = 1
    OUT_OF_FOCUS_DOWN = 2
    NO_PIPETTE = 3

class PipetteFocuser:
    def __init__(self):
        curFile = Path(__file__).parent.absolute()
        model_path = os.path.join(curFile, 'pipetteModel', 'pipetteFocusNet3.onnx')
        
        # Initialize ONNX Runtime session
        self.session = ort.InferenceSession(model_path)

        # Get input and output names
        self.input_name = self.session.get_inputs()[0].name
        self.output_names = [output.name for output in self.session.get_outputs()]

        self.imgSize = 640

        # Reduced classes
        self.focusedClasses = [0]  # classes where we can consider the cell "focused"
        self.outOfFocusUp = [1, 2, 3]  # pipette is below focal plane -- move up
        self.outOfFocusDown = [4, 5, 6]  # pipette is above focal plane -- move down
        self.noPipette = [7]

    def get_pipette_focus(self, img):
        '''Return a predicted focus level for the pipette in the image.'''
        # Resize image to imgSize
        img_resized = cv2.resize(img, (self.imgSize, self.imgSize))

        # Normalize image to [0, 1]
        img_normalized = img_resized.astype(np.float32) / 255.0

        # Convert image to CHW format (channels first)
        img_transposed = np.transpose(img_normalized, (2, 0, 1))  # HWC to CHW

        # Add batch dimension
        img_batch = np.expand_dims(img_transposed, axis=0)  # 1, C, H, W

        # Convert to contiguous array
        img_input = np.ascontiguousarray(img_batch)

        # Run inference
        start_time = time.time()
        outputs = self.session.run(self.output_names, {self.input_name: img_input})
        elapsed_time = time.time() - start_time
        print(f'Inference time: {elapsed_time:.4f} seconds')

        # Assuming outputs[0] contains class scores
        classes = outputs[0]
        print(f'Output shape: {classes.shape}')  # Debug statement

        # Handle different output shapes
        if classes.ndim == 2 and classes.shape[0] == 1:
            # Single prediction
            bestClass = np.argmax(classes, axis=1)[0]
        elif classes.ndim == 1:
            # Direct class scores
            bestClass = np.argmax(classes)
        else:
            # Multiple predictions; aggregate as needed
            bestClass = np.argmax(classes, axis=1)  # This will still be an array

        print(f'best class: {bestClass}')  # Debug statement

        # Ensure bestClass is a scalar integer
        if isinstance(bestClass, np.ndarray):
            if bestClass.size == 1:
                bestClass = int(bestClass[0])
            else:
                # Aggregate multiple predictions, e.g., majority vote
                unique, counts = np.unique(bestClass, return_counts=True)
                bestClass = unique[np.argmax(counts)]
                print(f'Aggregated best class: {bestClass}')

        if bestClass in self.focusedClasses:
            return FocusLevels.IN_FOCUS
        elif bestClass in self.outOfFocusUp:
            return FocusLevels.OUT_OF_FOCUS_UP
        elif bestClass in self.outOfFocusDown:
            return FocusLevels.OUT_OF_FOCUS_DOWN
        elif bestClass in self.noPipette:
            return FocusLevels.NO_PIPETTE
        else:
            print(f'ERROR: invalid class {bestClass}')
            return FocusLevels.NO_PIPETTE

if __name__ == '__main__':
    focuser = PipetteFocuser()
    dataPath = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\deepLearning\pipetteModelTrainer\focus_dataset\focus_training_set\images"
    if not os.path.isdir(dataPath):
        print(f"The data path '{dataPath}' does not exist.")
        exit(1)

    files = os.listdir(dataPath)
    pngFiles = [f for f in files if f.lower().endswith(('.jpg', '.png', '.jpeg', '.webp'))]
    
    if not pngFiles:
        print("No image files found in the specified directory.")
        exit(1)

    # Grab a random image in the data folder
    randomPng = random.choice(pngFiles)
    print(f'random png: {randomPng}')
    
    # Correctly join the path
    imgPath = os.path.join(dataPath, randomPng)
    img = cv2.imread(imgPath)

    if img is None:
        print(f"Failed to read image: {imgPath}. Exiting.")
        exit(1)

    # Find pipette focus level
    focusLevel = focuser.get_pipette_focus(img)
    print(f'Focus level: {focusLevel}')

    # Optionally, annotate the image with focus level
    label = f'Focus: {focusLevel.name}'
    cv2.putText(img, label, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 
                1, (0, 255, 0), 2, cv2.LINE_AA)

    # Show img
    cv2.imshow("pipette finding test", img)
    key = cv2.waitKey(0) & 0xFF
    if key == ord('q'):
        print("Exiting loop.")
    cv2.destroyAllWindows()


================================================
File: /holypipette/deepLearning/__init__.py
================================================
from __future__ import absolute_import
from .pipetteFinder import PipetteFinder

================================================
File: /holypipette/deepLearning/cellSegmentor.py
================================================
import os
import numpy as np
import torch
import matplotlib.pyplot as plt
import cv2
import sys
import yaml

from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

class cellSegmentor:
    def __init__(self, sam_checkpoint, model_cfg, device=None):
        # Enable MPS fallback for unsupported operations
        os.environ["PYTORCH_ENABLE_MPS_FALLBACK"] = "1"

        # Determine device
        if device is None:
            if torch.cuda.is_available():
                self.device = torch.device("cuda")
            elif torch.backends.mps.is_available():
                self.device = torch.device("mps")
            else:
                self.device = torch.device("cpu")
        else:
            self.device = torch.device(device)

        # Warnings for non-CUDA devices
        if self.device.type == "mps":
            print(
                "\nWarning: SAM2 is optimized for CUDA devices. "
                "Using MPS may result in degraded performance or numerically different results."
            )
        elif self.device.type == "cpu":
            print("\nWarning: Running on CPU may significantly impact performance.")

        self.sam_checkpoint = sam_checkpoint
        self.model_cfg = model_cfg
        self.sam = None
        self.predictor = None
        self.image = None

        # Load the SAM2 model
        self._load_model()

    def _load_model(self):
        # Configure for CUDA optimizations
        if self.device.type == "cuda":
            torch.autocast("cuda", dtype=torch.bfloat16).__enter__()
            if torch.cuda.get_device_properties(0).major >= 8:
                torch.backends.cuda.matmul.allow_tf32 = True
                torch.backends.cudnn.allow_tf32 = True

        # Load SAM2 model with error handling
        try:
            # Explicitly load the config
            with open(self.model_cfg, 'r') as f:
                config = yaml.safe_load(f)

            # Load SAM2 model
            self.sam = build_sam2(self.model_cfg, self.sam_checkpoint, device=self.device)
        except Exception as e:
            print(f"Error loading SAM2 model: {e}")
            raise

        # Initialize predictor
        self.predictor = SAM2ImagePredictor(self.sam)

    def load_image(self, image_path):
        # Load and convert the image to RGB
        image = cv2.imread(image_path)
        if image is None:
            raise FileNotFoundError(f"Error: Could not load image from {image_path}. Please check the file path and ensure the file exists.")
        self.image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    def set_image(self):
        # Set image to SAM2 model for embedding
        if self.image is not None:
            self.predictor.set_image(self.image)
        else:
            raise ValueError("No image loaded. Please load an image first.")

    def predict_mask(self, input_point, input_label, multimask_output=True):
        # Predict masks using the input point and label
        if self.image is None:
            raise ValueError("Image has not been set. Please call set_image() before predicting.")

        masks, scores, logits = self.predictor.predict(
            point_coords=input_point,
            point_labels=input_label,
            multimask_output=multimask_output,
        )
        return masks, scores

    def predict_mask_box(self, input_box, multimask_output=True):
        # Predict masks using the input box
        if self.image is None:
            raise ValueError("Image has not been set. Please call set_image() before predicting.")

        masks, scores, logits = self.predictor.predict(
            point_coords=None,
            point_labels=None,
            box=input_box[None, :],
            multimask_output=multimask_output,
        )
        return masks, scores

    def single_prediction(self, input_point, input_label, multimask_output=False):
        # Get a single prediction using the input point and label
        if self.image is None:
            raise ValueError("Image has not been set. Please call set_image() before predicting.")

        masks, scores = self.predict_mask(input_point, input_label, multimask_output)
        return masks[0]  # Return the first mask

    def show_image(self):
        # Show the loaded image
        if self.image is not None:
            plt.figure(figsize=(10, 10))
            plt.imshow(self.image)
            plt.axis('on')
            plt.show()
        else:
            raise ValueError("No image loaded. Please load an image first.")

    def show_mask(self, mask, ax, random_color=False, borders=True):
        # Utility method to visualize mask on image
        if random_color:
            color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)
        else:
            color = np.array([30 / 255, 144 / 255, 255 / 255, 0.6])
        h, w = mask.shape[-2:]
        mask = mask.astype(np.uint8)
        mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1)

        if borders:
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
            contours = [cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours]
            mask_image = cv2.drawContours(mask_image, contours, -1, (1, 1, 1, 0.5), thickness=2)

        ax.imshow(mask_image)

    def show_points(self, coords, labels, ax, marker_size=375):
        # Utility method to visualize input points
        pos_points = coords[labels == 1]
        neg_points = coords[labels == 0]
        ax.scatter(pos_points[:, 0], pos_points[:, 1], color='green', marker='*', s=marker_size,
                   edgecolor='white', linewidth=1.25)
        ax.scatter(neg_points[:, 0], neg_points[:, 1], color='red', marker='*', s=marker_size,
                   edgecolor='white', linewidth=1.25)

    def show_box(self, box, ax):
        # Utility method to visualize bounding box
        x0, y0 = box[0], box[1]
        w, h = box[2] - box[0], box[3] - box[1]
        ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0, 0, 0, 0), lw=2))

    def visualize_prediction(self, input_point=None, input_label=None, input_box=None, multimask_output=False, borders=True):
        # Visualize masks with the given input point or box
        if input_point is None and input_box is None:
            raise ValueError("Please provide either input_point or input_box.")
        if input_point is not None and input_box is not None:
            raise ValueError("Please provide only one of input_point or input_box.")

        if input_point is not None:
            masks, scores = self.predict_mask(input_point, input_label, multimask_output)
            for i, (mask, score) in enumerate(zip(masks, scores)):
                plt.figure(figsize=(10, 10))
                plt.imshow(self.image)
                self.show_mask(mask, plt.gca(), borders=borders)
                self.show_points(input_point, input_label, plt.gca())
                plt.title(f"Mask {i + 1}, Score: {score:.3f}", fontsize=18)
                plt.axis('off')
                plt.show()
        else:
            masks, scores = self.predict_mask_box(input_box, multimask_output)
            for i, (mask, score) in enumerate(zip(masks, scores)):
                plt.figure(figsize=(10, 10))
                plt.imshow(self.image)
                self.show_mask(mask, plt.gca(), borders=borders)
                self.show_box(input_box, plt.gca())
                plt.title(f"Mask {i + 1}, Score: {score:.3f}", fontsize=18)
                plt.axis('off')
                plt.show()

if __name__ == "__main__":
    # Example usage
    sys.path.append(r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\deepLearning\cellModel\sam2")
    
    # Adjust paths to ensure they are correct
    sam_checkpoint = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\deepLearning\cellModel\sam2\checkpoints\sam2.1_hiera_tiny.pt" 
    model_cfg = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\deepLearning\cellModel\sam2\sam2\configs\sam2.1\sam2.1_hiera_t.yaml"
    
    # Create object segmentation instance
    obj_seg = cellSegmentor(sam_checkpoint, model_cfg)

    # Load an example image
    # image_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\deepLearning\cellModel\sam2\notebooks\images\truck.jpg"
    # image_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_12_10-15_17\camera_frames\178605_1733864203.246073.webp" # pipette
    image_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\deepLearning\cellModel\example pictures\before.tiff" # cell
    obj_seg.load_image(image_path)
    obj_seg.set_image()

    # Predict using a single point
    input_point = np.array([[500, 375]]) # cell or truck
    # input_point = np.array([[400, 900]]) # pipette
    input_point = np.array([[600, 550]]) # cell

    input_label = np.array([1])
    obj_seg.visualize_prediction(input_point=input_point, input_label=input_label)

    # Predict using a bounding box
    input_box = np.array([425, 600, 700, 875])
    obj_seg.visualize_prediction(input_box=input_box)

    # test single prediction speed
    import time
    start_time = time.time()
    obj_seg.single_prediction(input_point, input_label)
    elapsed_time = time.time() - start_time
    elapsed_time_ms = elapsed_time * 1000
    # print(f'Single prediction time: {elapsed_time:.4f} seconds')
    print(f'Single prediction time: {elapsed_time_ms:.4f} ms')

================================================
File: /holypipette/deepLearning/pipetteFinder.py
================================================
import cv2
import numpy as np
import time
from pathlib import Path

class PipetteFinder():

	def __init__(self):
		curFile = str(Path(__file__).parent.absolute())
		self.yoloNet = cv2.dnn.readNetFromONNX(curFile + '/pipetteModel/pipetteFinderNetnano2.onnx')

		layer_names = self.yoloNet.getLayerNames()
		self.output_layers = [layer_names[i-1] for i in self.yoloNet.getUnconnectedOutLayers()]

		self.pipette_class = 0

	def find_pipette(self, img):
		''' return the x and y position (in pixels) of the pipette in the given image using a YOLO object detection model
			or None if there is no detected pipette in the image
		'''

		if len(img.shape) == 2:
			#neural net expects color image, convert to color
			img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)

		height, width, _ = img.shape #color image

		#run the image through the model
		blob = cv2.dnn.blobFromImage(img, 1 / 255.0, (640, 640), swapRB=True, crop=False)
		self.yoloNet.setInput(blob)
		outs = self.yoloNet.forward(self.output_layers)

		confidences = []
		boxes = []
		for out in outs:
			for detection in out:
				idx = np.argmax(detection[4, :])
				detection = detection[:, idx]
				x, y, width, height, objectness = tuple(detection)
				if objectness < 0.20:
					continue

				center_x = x
				center_y = y
				boxes.append([center_x, center_y])
				confidences.append(float(objectness))

		if len(boxes) == 0:
			return None #no pipette detected
		
		confidences = np.array(confidences)
		best_x, best_y = boxes[confidences.argmax()]
		if best_x is np.nan or best_y is np.nan:
			return None #no pipette detected

		#model outputs pos for a 640x640 img.  rescale x,y to input image size
		best_x = (best_x / 640) * img.shape[1]
		best_y = (best_y / 640) * img.shape[0]

		#convert to int (for opencv drawing functions)
		best_x = int(best_x) #+ 45 #shift left a bit to center on pipette tip
		best_y = int(best_y) #- 90  #shift up a bit to center on pipette tip

		return best_x, best_y
	
if __name__ == '__main__':
	finder = PipetteFinder()
	# path = r"C:\Users\sa-forest\GaTech Dropbox\Benjamin Magondu\YOLOretrainingdata\Pipette CNN Training Data\20191016\3654098890.png"
	# path = r"c:\Users\sa-forest\GaTech Dropbox\Benjamin Magondu\YOLOretrainingdata\classified_images\below\P_DET_IMAGES\10454_1726847645.853619.jpg"
	# path  = r"C:\Users\sa-forest\GaTech Dropbox\Benjamin Magondu\YOLOretrainingdata\Pipette CNN Training Data\20191016\3654099464.png"
	path =  r"C:\Users\sa-forest\GaTech Dropbox\Benjamin Magondu\YOLOretrainingdata\Pipette CNN Training Data\20191016\3654098923.png"
	img = cv2.imread(path)

	#find pipette, draw location to img
	start = time.time()
	x,y = finder.find_pipette(img)

	print(f'framerate: {1 / (time.time() - start)}')
	cv2.circle(img, (x,y), 3, (0, 255, 0))

	#show img
	cv2.imshow("pipette finding test", img)
	cv2.waitKey(0)


		

				

================================================
File: /holypipette/utils/filelock.py
================================================
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org>

"""
A platform independent file lock that supports the with-statement.
"""


# Modules
# ------------------------------------------------
import logging
import os
import threading
import time
try:
    import warnings
except ImportError:
    warnings = None

try:
    import msvcrt
except ImportError:
    msvcrt = None

try:
    import fcntl
except ImportError:
    fcntl = None


# Backward compatibility
# ------------------------------------------------
try:
    TimeoutError
except NameError:
    TimeoutError = OSError


# Data
# ------------------------------------------------
__all__ = [
    "Timeout",
    "BaseFileLock",
    "WindowsFileLock",
    "UnixFileLock",
    "SoftFileLock",
    "FileLock"
]

__version__ = "3.0.12"


_logger = None
def logger():
    """Returns the logger instance used in this module."""
    global _logger
    _logger = _logger or logging.getLogger(__name__)
    return _logger


# Exceptions
# ------------------------------------------------
class Timeout(TimeoutError):
    """
    Raised when the lock could not be acquired in *timeout*
    seconds.
    """

    def __init__(self, lock_file):
        """
        """
        #: The path of the file lock.
        self.lock_file = lock_file
        return None

    def __str__(self):
        temp = "The file lock '{}' could not be acquired."\
               .format(self.lock_file)
        return temp


# Classes
# ------------------------------------------------

# This is a helper class which is returned by :meth:`BaseFileLock.acquire`
# and wraps the lock to make sure __enter__ is not called twice when entering
# the with statement.
# If we would simply return *self*, the lock would be acquired again
# in the *__enter__* method of the BaseFileLock, but not released again
# automatically.
#
# :seealso: issue #37 (memory leak)
class _Acquire_ReturnProxy(object):

    def __init__(self, lock):
        self.lock = lock
        return None

    def __enter__(self):
        return self.lock

    def __exit__(self, exc_type, exc_value, traceback):
        self.lock.release()
        return None


class BaseFileLock(object):
    """
    Implements the base class of a file lock.
    """

    def __init__(self, lock_file, timeout = -1):
        """
        """
        # The path to the lock file.
        self._lock_file = lock_file

        # The file descriptor for the *_lock_file* as it is returned by the
        # os.open() function.
        # This file lock is only NOT None, if the object currently holds the
        # lock.
        self._lock_file_fd = None

        # The default timeout value.
        self.timeout = timeout

        # We use this lock primarily for the lock counter.
        self._thread_lock = threading.Lock()

        # The lock counter is used for implementing the nested locking
        # mechanism. Whenever the lock is acquired, the counter is increased and
        # the lock is only released, when this value is 0 again.
        self._lock_counter = 0
        return None

    @property
    def lock_file(self):
        """
        The path to the lock file.
        """
        return self._lock_file

    @property
    def timeout(self):
        """
        You can set a default timeout for the filelock. It will be used as
        fallback value in the acquire method, if no timeout value (*None*) is
        given.

        If you want to disable the timeout, set it to a negative value.

        A timeout of 0 means, that there is exactly one attempt to acquire the
        file lock.

        .. versionadded:: 2.0.0
        """
        return self._timeout

    @timeout.setter
    def timeout(self, value):
        """
        """
        self._timeout = float(value)
        return None

    # Platform dependent locking
    # --------------------------------------------

    def _acquire(self):
        """
        Platform dependent. If the file lock could be
        acquired, self._lock_file_fd holds the file descriptor
        of the lock file.
        """
        raise NotImplementedError()

    def _release(self):
        """
        Releases the lock and sets self._lock_file_fd to None.
        """
        raise NotImplementedError()

    # Platform independent methods
    # --------------------------------------------

    @property
    def is_locked(self):
        """
        True, if the object holds the file lock.

        .. versionchanged:: 2.0.0

            This was previously a method and is now a property.
        """
        return self._lock_file_fd is not None

    def acquire(self, timeout=None, poll_intervall=0.05):
        """
        Acquires the file lock or fails with a :exc:`Timeout` error.

        .. code-block:: python

            # You can use this method in the context manager (recommended)
            with lock.acquire():
                pass

            # Or use an equivalent try-finally construct:
            lock.acquire()
            try:
                pass
            finally:
                lock.release()

        :arg float timeout:
            The maximum time waited for the file lock.
            If ``timeout < 0``, there is no timeout and this method will
            block until the lock could be acquired.
            If ``timeout`` is None, the default :attr:`~timeout` is used.

        :arg float poll_intervall:
            We check once in *poll_intervall* seconds if we can acquire the
            file lock.

        :raises Timeout:
            if the lock could not be acquired in *timeout* seconds.

        .. versionchanged:: 2.0.0

            This method returns now a *proxy* object instead of *self*,
            so that it can be used in a with statement without side effects.
        """
        # Use the default timeout, if no timeout is provided.
        if timeout is None:
            timeout = self.timeout

        # Increment the number right at the beginning.
        # We can still undo it, if something fails.
        with self._thread_lock:
            self._lock_counter += 1

        lock_id = id(self)
        lock_filename = self._lock_file
        start_time = time.time()
        try:
            while True:
                with self._thread_lock:
                    if not self.is_locked:
                        #logger().debug('Attempting to acquire lock %s on %s', lock_id, lock_filename)
                        self._acquire()

                if self.is_locked:
                    #logger().info('Lock %s acquired on %s', lock_id, lock_filename)
                    break
                elif timeout >= 0 and time.time() - start_time > timeout:
                    logger().debug('Timeout on acquiring lock %s on %s', lock_id, lock_filename)
                    raise Timeout(self._lock_file)
                else:
                    #logger().debug(
                    #    'Lock %s not acquired on %s, waiting %s seconds ...',
                    #    lock_id, lock_filename, poll_intervall
                    #)
                    time.sleep(poll_intervall)
        except:
            # Something did go wrong, so decrement the counter.
            with self._thread_lock:
                self._lock_counter = max(0, self._lock_counter - 1)

            raise
        return _Acquire_ReturnProxy(lock = self)

    def release(self, force = False):
        """
        Releases the file lock.

        Please note, that the lock is only completly released, if the lock
        counter is 0.

        Also note, that the lock file itself is not automatically deleted.

        :arg bool force:
            If true, the lock counter is ignored and the lock is released in
            every case.
        """
        with self._thread_lock:

            if self.is_locked:
                self._lock_counter -= 1

                if self._lock_counter == 0 or force:
                    lock_id = id(self)
                    lock_filename = self._lock_file

                    #logger().debug('Attempting to release lock %s on %s', lock_id, lock_filename)
                    self._release()
                    self._lock_counter = 0
                    #logger().info('Lock %s released on %s', lock_id, lock_filename)

        return None

    def __enter__(self):
        self.acquire()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.release()
        return None

    def __del__(self):
        self.release(force = True)
        return None


# Windows locking mechanism
# ~~~~~~~~~~~~~~~~~~~~~~~~~

class WindowsFileLock(BaseFileLock):
    """
    Uses the :func:`msvcrt.locking` function to hard lock the lock file on
    windows systems.
    """

    def _acquire(self):
        open_mode = os.O_RDWR | os.O_CREAT | os.O_TRUNC

        try:
            fd = os.open(self._lock_file, open_mode)
        except OSError:
            pass
        else:
            try:
                msvcrt.locking(fd, msvcrt.LK_NBLCK, 1)
            except (IOError, OSError):
                os.close(fd)
            else:
                self._lock_file_fd = fd
        return None

    def _release(self):
        fd = self._lock_file_fd
        self._lock_file_fd = None
        msvcrt.locking(fd, msvcrt.LK_UNLCK, 1)
        os.close(fd)

        try:
            os.remove(self._lock_file)
        # Probably another instance of the application
        # that acquired the file lock.
        except OSError:
            pass
        return None

# Unix locking mechanism
# ~~~~~~~~~~~~~~~~~~~~~~

class UnixFileLock(BaseFileLock):
    """
    Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.
    """

    def _acquire(self):
        open_mode = os.O_RDWR | os.O_CREAT | os.O_TRUNC
        fd = os.open(self._lock_file, open_mode)

        try:
            fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except (IOError, OSError):
            os.close(fd)
        else:
            self._lock_file_fd = fd
        return None

    def _release(self):
        # Do not remove the lockfile:
        #
        #   https://github.com/benediktschmitt/py-filelock/issues/31
        #   https://stackoverflow.com/questions/17708885/flock-removing-locked-file-without-race-condition
        fd = self._lock_file_fd
        self._lock_file_fd = None
        fcntl.flock(fd, fcntl.LOCK_UN)
        os.close(fd)
        return None

# Soft lock
# ~~~~~~~~~

class SoftFileLock(BaseFileLock):
    """
    Simply watches the existence of the lock file.
    """

    def _acquire(self):
        open_mode = os.O_WRONLY | os.O_CREAT | os.O_EXCL | os.O_TRUNC
        try:
            fd = os.open(self._lock_file, open_mode)
        except (IOError, OSError):
            pass
        else:
            self._lock_file_fd = fd
        return None

    def _release(self):
        os.close(self._lock_file_fd)
        self._lock_file_fd = None

        try:
            os.remove(self._lock_file)
        # The file is already deleted and that's what we want.
        except OSError:
            pass
        return None


# Platform filelock
# ~~~~~~~~~~~~~~~~~

#: Alias for the lock, which should be used for the current platform. On
#: Windows, this is an alias for :class:`WindowsFileLock`, on Unix for
#: :class:`UnixFileLock` and otherwise for :class:`SoftFileLock`.
FileLock = None

if msvcrt:
    FileLock = WindowsFileLock
elif fcntl:
    FileLock = UnixFileLock
else:
    FileLock = SoftFileLock

    if warnings is not None:
        warnings.warn("only soft file lock is available")

================================================
File: /holypipette/utils/__init__.py
================================================
from .FileLogger import FileLogger
from .EPhysLogger import EPhysLogger
from .RecordingStateManager import RecordingStateManager

================================================
File: /holypipette/utils/EPhysLogger.py
================================================
import logging
from datetime import datetime
import threading
import os
from PyQt5 import QtGui

class EPhysLogger(threading.Thread):
    def __init__(self, recording_state_manager, folder_path="experiments/Data/patch_clamp_data/", ephys_filename="ephys"):
        super().__init__()
        self.recording_state_manager = recording_state_manager
        self.time_truth = datetime.now()
        testMode = False
        if testMode:
            folder_path = folder_path.replace("Data/", "Data/TEST_")
        self.folder_path = folder_path + self.time_truth.strftime("%Y_%m_%d-%H_%M") + "/" + f"{ephys_filename}" + "/"
        self.filename = self.folder_path + f"{ephys_filename}"
        self.file = None

        self.folder_created = False
        self.write_event = threading.Event()

        # Dictionary to track unique index and color combinations
        self.index_color_dict = {}
        # Lock for thread-safe access to the dictionary
        self.index_color_lock = threading.Lock()

    def create_folder(self):
        if not self.folder_created:
            try:
                os.makedirs(os.path.dirname(self.folder_path), exist_ok=True)
                self.folder_created = True
                logging.info(f"Created folder at: {self.folder_path}")
            except OSError as exc:
                logging.error("Error creating folder for recording: %s", exc)
        else:
            logging.info("Folder already created. Skipping creation.")

    def _write_to_file(self, index, timeData, readData, respData, color):
        # Check if "CurrentProtocol" is in filename
        if "CurrentProtocol" in self.filename:
            with self.index_color_lock:
                if index not in self.index_color_dict:
                    # Index is unique, create a new entry with an empty list for colors
                    self.index_color_dict[index] = []

                # Proceed only if the color is unique for the given index
                if color not in self.index_color_dict[index]:
                    # Append the color to the list for this index
                    self.index_color_dict[index].append(color)
                else:
                    # Color is not unique for this index, skip writing
                    logging.debug("Skipping write: Index %s and color %s are not unique", index, color)
                    return

        # If "CurrentProtocol" is not in filename, proceed as the original method
        lines = [f"{timeData[i]} {readData[i]} {respData[i]}\n" for i in range(len(timeData))]
        # Open the file in append mode and write the formatted strings
        logging.debug("Writing to file %s", self.filename)
        with open(f"{self.filename}_{index}_{color}.csv", 'a+') as file:
            file.writelines(lines)
        self.write_event.set()  # Signal that writing is done

    def write_ephys_data(self, index, timeData, readData, respData, color):
        self.create_folder()  # Ensure folder is created if it hasn't been
        self.write_event.clear()
        threading.Thread(target=self._write_to_file, args=(index, timeData, readData, respData, color)).start()

    def save_ephys_plot(self, index, plot):
        self.create_folder()  # Ensure folder is created if it hasn't been

        image_path = f"{self.filename}_{index}.png"
        exporter = QtGui.QImage(plot.width(), plot.height(), QtGui.QImage.Format_ARGB32)
        painter = QtGui.QPainter(exporter)
        plot.render(painter)
        painter.end()

        if exporter.save(image_path):
            logging.info("Saved plot to %s", image_path)
        else:
            logging.error("Failed to save plot to %s", image_path)

    def close(self):
        if self.file is not None:
            logging.info("CLOSING FILE: %s", self.filename)
            self.write_event.wait()  # Wait for the last task to complete
            self.file.close()
            self.file = None
        logging.info("Closing csv recorder writing thread")


================================================
File: /holypipette/utils/FileLogger.py
================================================
import logging
from datetime import datetime
import threading
from collections import deque
import imageio
import os
import logging



class FileLogger(threading.Thread):
    def __init__(self, recording_state_manager, folder_path="experiments/Data/", recorder_filename="recording", filetype="csv", isVideo=False, frame_batch_size=500):
        super().__init__()
        self.recording_state_manager = recording_state_manager
        self.time_truth = datetime.now()

        self.image_type  = "webp"

        testMode = False
        if testMode:
            folder_path = folder_path.replace("Data/", "Data/TEST_")

        self.folder_path = folder_path + self.time_truth.strftime("%Y_%m_%d-%H_%M") + "/"
        self.camera_folder_path = self.folder_path + "camera_frames/"
        self.filename = self.folder_path + recorder_filename + "." + filetype
        self.file = None
        self.last_frameno = 0
        self.frame_batch_size = frame_batch_size
        self.frame_batch_limit = int(frame_batch_size * 0.8)

        self.batch_mode_movements = False
        self.batch_mode_graph = False

        self.write_event = threading.Event()
        self.is_video = isVideo
        self.write_frame = threading.Event() if isVideo else None

        self.batch_frames = deque(maxlen=frame_batch_size)
        # self.graph_contents = deque(maxlen=frame_batch_size)
        self.movement_contents = deque(maxlen=frame_batch_size)

        self.last_movement_time = None
        self.last_graph_time = None
        self.folder_created = False  # Flag to track folder creation

        logging.info(f"FileLogger initialized. Folder path set to: {self.folder_path}")

    def create_folder(self):
        # Check if the recording is enabled before creating the folder
        if self.recording_state_manager.is_recording_enabled() and not self.folder_created:
            try:
                os.makedirs(self.camera_folder_path, exist_ok=True)
                self.folder_created = True  # Set the flag to True once folder is created
                print(f"Created folder at: {self.folder_path}")
            except OSError as exc:
                logging.error("Error creating folder for recording: %s", exc)


    def open(self):
        self.file = open(self.filename, 'a+')
        print(f"Opened file at: {self.filename}")

    def _write_to_file(self, contents):
        if self.file is None:
            self.open()
        self.file.write(contents)
        self.file.flush()
        self.write_event.set()  # Signal that writing is done
        # print("Wrote file contents at path: ", self.filename)

    def _write_to_file_batch(self, contents):
        if self.file is None:
            self.open()
        self.file.writelines(contents)
        self.file.flush()
        self.write_event.set()  # Signal that writing is done
        # print("Wrote file contents at path: ", self.filename)

    def write_graph_data(self, time_value, pressure: float, resistance: float, current, voltage):
    # ? time_current is probably not necessary, will remove in a future commit when confirmed.
    # def write_graph_data(self, time_value, pressure: float, resistance: float, time_current, current):
        if not self.recording_state_manager.is_recording_enabled():
            return
        if time_value == self.last_graph_time:
            return
        self.last_graph_time = time_value
        self.create_folder()  # Create the folder if recording is enabled and it's the first time
        # content = f"timestamp:{time_value}  pressure:{pressure}  resistance:{resistance}  / current:{current}\n"
        content = f"timestamp:{time_value}  pressure:{pressure}  resistance:{resistance}  current:{current} voltage:{voltage}\n"
        self.write_event.clear()
        threading.Thread(target=self._write_to_file, args=(content,)).start()

    def write_movement_data_batch(self, time_value, stage_x, stage_y, stage_z, pipette_x, pipette_y, pipette_z):
        if not self.recording_state_manager.is_recording_enabled():
            return
        if time_value == self.last_movement_time:
            return
        self.last_movement_time = time_value
        self.create_folder()  # Create the folder if recording is enabled and it's the first time
        content = f"timestamp:{time_value}  st_x:{stage_x}  st_y:{stage_y}  st_z:{stage_z}  pi_x:{pipette_x} pi_y:{pipette_y} pi_z:{pipette_z}\n"

        self.movement_contents.append(content)
        if len(self.movement_contents) >= self.frame_batch_limit:
            # logging.info(f"Batch size reached for MOVEMENT. Writing to disk at {datetime.now() - self.time_truth} seconds after start")
            self._flush_contents(self.movement_contents)

    def _flush_contents(self, data):
        if data:
            contents = data.copy()
            data.clear()
            self.write_event.clear()
            threading.Thread(target=self._write_to_file_batch, args=(contents,)).start()

    def _save_image(self, frame, path):
        self.batch_frames.append((frame, path))
        if len(self.batch_frames) >= self.frame_batch_limit:
            # logging.info(f"Batch size reached for FRAMES. Writing to disk at {datetime.now() - self.time_truth} seconds after start")
            self.write_frame.clear()
            threading.Thread(target=self._write_batch_to_disk).start()
    
    def _save_image_sleep(self):
        if self.batch_frames:
            self.write_frame.clear()
            threading.Thread(target=self._write_batch_to_disk).start()

    def _write_batch_to_disk(self):
        while self.batch_frames:
            frame, path = self.batch_frames.popleft()
            # imwrite(path, frame)
            imageio.imwrite(path, frame, format=self.image_type)
            # qoi.write(path, frame)
        self.write_frame.set()  # Signal that image saving is done

    def write_camera_frames(self, time_value, frame, frameno):
        if not self.recording_state_manager.is_recording_enabled():
            self._save_image_sleep()
            return

        # * Add this back in if you change where this function is called within the update_image function in the LiveFeedQT class. 
        # if frameno is None:
        #     logging.info("No frame number detected. Closing the camera recorder")
        #     self.close()
        #     return

        if frameno <= self.last_frameno:
            return
        self.create_folder()  # Create the folder if recording is enabled and it's the first time
        image_path = self.camera_folder_path + str(frameno) + '_' + str(time_value) + "." + self.image_type
        self._save_image(frame, image_path)
        self.last_frameno = frameno

    def setBatchGraph(self, value=True):
        self.batch_mode_graph = value
    def setBatchMoves(self, value=True):
        self.batch_mode_movements = value

    def close(self):
        if self.file is not None:
            logging.info("Closing file: %s", self.filename)
            # if self.batch_mode_graph and self.graph_contents:
            #     self._flush_contents(self.graph_contents)
            if self.batch_mode_movements and self.movement_contents:
                self._flush_contents(self.movement_contents)
            self.write_event.wait()  # Wait for the last task to complete

            self.file.close()
            self.file = None

        self.write_frame.wait()
        logging.info("Closing CSV recorder writing thread")
        if self.batch_frames:
            self._write_batch_to_disk()
        if self.is_video:
            logging.info("Closing frame saving thread")


================================================
File: /holypipette/utils/RecordingStateManager.py
================================================
import threading


class RecordingStateManager:
    def __init__(self):
        self._recording_enabled = False
        self._lock = threading.Lock()
        self.sample_number = 0
    
    def increment_sample_number(self):
        with self._lock:
            self.sample_number += 1
            print("Sample number incremented to:", self.sample_number)

    def toggle_recording(self):
        with self._lock:
            self._recording_enabled = not self._recording_enabled
            # print("Recording state toggled to:", self._recording_enabled)
            return self._recording_enabled

    def set_recording(self, state: bool) -> None:
        with self._lock:
            self._recording_enabled = state
            # print("Recording state set to:", self._recording_enabled)

    def is_recording_enabled(self) -> bool:
        with self._lock:
            return self._recording_enabled


