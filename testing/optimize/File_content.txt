
================================================
File: /testing/niDAQ/DAQTest.py
================================================
import nidaqmx.system
import nidaqmx
from nidaqmx.types import CtrTime
import numpy as np
import matplotlib.pyplot as plt

ampRead = 'cDAQ1Mod1'
ampCmd = 'cDAQ1Mod4'

#list all daq devices connected
system = nidaqmx.system.System.local()
devices = system.devices
for device in system.devices:
    print(f'Device name: {device.name}')
    print('AI channels:', device.ai_physical_chans.channel_names)
    print('AO channels:', device.ao_physical_chans.channel_names)
    print('DI lines:', device.di_lines)
    print('DO lines:', device.do_lines)
# print("Devices:")
# print([d for d in devices])


ampReadDev = devices[ampRead]
ampCmdDev = devices[ampCmd]


def readAnalogInput(device, channel):
    with nidaqmx.Task() as task:
        task.ai_channels.add_ai_voltage_chan(f'{device}/{channel}')
        data = task.read(number_of_samples_per_channel=1000)
        return data

#continuously send square wave to channel 
def sendSquareWave(device, channel, wave_freq, samplesPerSec, dutyCycle):
    task = nidaqmx.Task()
    task.ao_channels.add_ao_voltage_chan(f'{device}/{channel}')
    task.timing.cfg_samp_clk_timing(samplesPerSec, sample_mode=nidaqmx.constants.AcquisitionType.CONTINUOUS)
    
    #create a wave_freq Hz square wave
    data = np.zeros(samplesPerSec)
    onTime = 1 / wave_freq * dutyCycle * samplesPerSec
    offTime = 1 / wave_freq * (1-dutyCycle) * samplesPerSec

    #calc period
    period = onTime + offTime

    #convert to int
    onTime = int(onTime)
    offTime = int(offTime)
    period = int(period)

    wavesPerSec = samplesPerSec // period

    print(onTime, offTime, wavesPerSec, samplesPerSec, wave_freq, period)

    for i in range(wavesPerSec):
        data[i * period : i * period + onTime] = 5

    
    # print(data)
    task.write(data)
    
    task.start()
    
    return task

#continuous read and plot with matplotlib
def readAnalogInputContinuous(device, channel):
    with nidaqmx.Task() as task:
        task.ai_channels.add_ai_voltage_chan(f'{device}/{channel}', max_val=10, min_val=0)
        task.timing.cfg_samp_clk_timing(10000, sample_mode=nidaqmx.constants.AcquisitionType.FINITE, samps_per_chan=1000)
        task.triggers.reference_trigger.cfg_anlg_edge_ref_trig(f'{device}/{channel}', pretrigger_samples = 10, trigger_slope=nidaqmx.constants.Slope.RISING, trigger_level = 2 )
        # task.triggers.reference_trigger.cfg_anlg_edge_ref_trig("Dev1/ai0", pretrigger_samples = 10, trigger_slope=nidaqmx.constants.Slope.FALLING, trigger_level = 5)
        squareWave = sendSquareWave(ampCmd, 'ao0', 100, 1000, 0.5)


        while True:
            task.start()
            data = task.read(number_of_samples_per_channel=1000)
            plt.plot(data)
            #fix scale between -0.1 and 0.1
            plt.ylim(-10, 10)
            plt.draw()
            #break on escape key
            if plt.waitforbuttonpress(0.001):
                break
            plt.pause(0.05)
            plt.clf()
            task.stop()

        
        #stop task
        task.stop()
        squareWave.stop()
        squareWave.close()
        print('done')
    
if __name__ == '__main__':
    import time

    print('starting continuous read')
    readAnalogInputContinuous(ampRead, 'ai1')
    # squareWave = sendSquareWave(ampCmd, 'ao1', 100, 1000, 0.5)
    # time.sleep(60)
    # squareWave.stop()

================================================
File: /testing/niDAQ/DAQTest2.py
================================================
import nidaqmx
import nidaqmx.system
import nidaqmx.constants

import numpy as np
import pandas as pd
import scipy.optimize
import scipy.signal as signal
import time
import threading
import logging
import matplotlib.pyplot as plt

from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QSlider, QPushButton, QToolButton, QDesktopWidget, QApplication
from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import Qt
from pyqtgraph import PlotWidget

from collections import deque
from datetime import datetime

__all__ = ["DAQtest", "EPhysGraph"]

class DAQtest:
    def __init__(self, readDev, readChannel, cmdDev, cmdChannel, respDev, respChannel):
        self.readDev = readDev
        self.cmdDev = cmdDev
        self.respDev = respDev
        self.readChannel = readChannel
        self.cmdChannel = cmdChannel
        self.respChannel = respChannel
        self.latestAccessResistance = None
        self.totalResistance = None
        self.latestMembraneResistance = None
        self.latestMembraneCapacitance = None

        self.isRunningProtocol = False
        self.isRunningVoltageProtocol = False
        self._deviceLock = threading.Lock()

        self.latest_protocol_data = None
        self.current_protocol_data = None
        self.voltage_protocol_data = None
        self.holding_protocol_data = None

        self.cellMode = False

        logging.info(f'Using {self.readDev}/{self.readChannel} for reading the output of {self.cmdDev}/{self.cmdChannel} and {self.respDev}/{self.respChannel} for response.')

    def _readAnalogInput(self, samplesPerSec, recordingTime):
        numSamples = int(samplesPerSec * recordingTime)
        with nidaqmx.Task() as task:
            task.ai_channels.add_ai_voltage_chan(f'{self.readDev}/{self.readChannel}', max_val=10, min_val=0, terminal_config=nidaqmx.constants.TerminalConfiguration.DIFF)
            task.ai_channels.add_ai_voltage_chan(f'{self.respDev}/{self.respChannel}', max_val=10, min_val=0, terminal_config=nidaqmx.constants.TerminalConfiguration.DIFF)
            task.timing.cfg_samp_clk_timing(samplesPerSec, sample_mode=nidaqmx.constants.AcquisitionType.FINITE, samps_per_chan=numSamples)
            data = task.read(number_of_samples_per_channel=numSamples, timeout=10)
            data = np.array(data, dtype=float)
            task.stop()

        if data is None or np.where(data == None)[0].size > 0:
            data = np.zeros((2, numSamples))
            
        return data
    
    def _sendSquareWave(self, wave_freq, samplesPerSec, dutyCycle, amplitude, recordingTime):
        task = nidaqmx.Task()
        task.ao_channels.add_ao_voltage_chan(f'{self.cmdDev}/{self.cmdChannel}')
        task.timing.cfg_samp_clk_timing(samplesPerSec, sample_mode=nidaqmx.constants.AcquisitionType.CONTINUOUS)
        
        numSamples = int(samplesPerSec * recordingTime)
        data = np.zeros(numSamples)
        
        period = int(samplesPerSec / wave_freq)
        onTime = int(period * dutyCycle)

        for i in range(0, numSamples, period):
            data[i:i+onTime] = amplitude
            data[i+onTime:i+period] = 0

        task.write(data)
        
        return task, data

    def setCellMode(self, mode: bool) -> None:
        self.cellMode = mode

    def getDataFromSquareWave(self, wave_freq, samplesPerSec: int, dutyCycle, amplitude, recordingTime) -> tuple:
        self._deviceLock.acquire()
        sendTask, cmdData = self._sendSquareWave(wave_freq, samplesPerSec, dutyCycle, amplitude, recordingTime)
        sendTask.start()
        data = self._readAnalogInput(samplesPerSec, recordingTime)
        sendTask.stop()
        sendTask.close()
        self._deviceLock.release()
        
        triggeredSamples = data.shape[1]
        xdata = np.linspace(0, triggeredSamples / samplesPerSec, triggeredSamples, dtype = float)

        # Gradient
        gradientData = np.gradient(data[0], xdata)
        max_index = np.argmax(gradientData)
        # Find the index of the minimum value after the maximum value
        min_index = np.argmin(gradientData[max_index:]) + max_index


        respData = data[0]
        readData = data[1]
        
        # #Truncate the array
        # # left_bound = 10
        # # right_bound = 150
        # # * bound is arbitrary, just to make it look good on the graph
        # # respData = data[0][max_index - left_bound:min_index + right_bound]
        # # readData = data[1][max_index - left_bound:min_index + right_bound]
        # xdata = xdata[max_index - left_bound:min_index + right_bound]

        respData *= 1e-9
        readData *= 1e-9
        amplitude *= 1e-2

        self.latestAccessResistance, self.latestMembraneResistance, self.latestMembraneCapacitance = self._getParamsfromCurrent(respData, xdata, amplitude)
        self.totalResistance = self._getResistancefromCurrent(respData, amplitude)

        return np.array([xdata, respData]),np.array([xdata, readData]), self.totalResistance, self.latestAccessResistance, self.latestMembraneResistance, self.latestMembraneCapacitance
    
    def _getParamsfromCurrent(self, data, xdata, cmdVoltage) -> tuple:
        R_a_MOhms, R_m_MOhms, C_m_pF = None, None, None

        try:
            df = pd.DataFrame({'X': xdata, 'Y': data})
            df['X_ms'] = df['X'] * 1000
            df['Y_pA'] = df['Y']
            filtered_data, pre_filtered_data, post_filtered_data, plot_params, I_prev_pA, I_post_pA = self.filter_data(df)
            peak_time, peak_index, min_time, min_index = plot_params
            m, t, b = self.optimizer(filtered_data)
            if m is not None and t is not None and b is not None:
                tau = 1 / t
                I_peak_pA = df.loc[peak_index, 'Y_pA']
                R_a_MOhms, R_m_MOhms, C_m_pF = self.calc_param(tau, cmdVoltage, I_peak_pA, I_prev_pA, I_post_pA)
        except Exception as e:
            return None, None, None

        return R_a_MOhms, R_m_MOhms, C_m_pF
    
    def _getResistancefromCurrent(self, data, cmdVoltage) -> float | None:
        try:
            mean = np.mean(data)
            lowAvg = np.mean(data[data < mean])
            highAvg = np.mean(data[data > mean])

            resistance = cmdVoltage / (highAvg - lowAvg)

            return resistance
            
        except Exception as e:
            return None


class EPhysGraph(QWidget):
    def __init__(self, daq):
        super().__init__()

        self.daq = daq
        self.cellMode = self.daq.cellMode

        self.setWindowTitle("Electrophysiology")

    
        self.cmdPlot = PlotWidget()
        self.respPlot = PlotWidget()
        self.resistancePlot = PlotWidget()

        for plot in [self.cmdPlot, self.respPlot, self.resistancePlot]:
            plot.setBackground("w")
            plot.getAxis("left").setPen("k")
            plot.getAxis("bottom").setPen("k")

        self.cmdPlot.setLabel("left", "Command Voltage", units="V")
        self.cmdPlot.setLabel("bottom", "Time", units="s")
        self.respPlot.setLabel("left", "Current (resp)", units="A")
        self.respPlot.setLabel("bottom", "Time", units="s")
        self.resistancePlot.setLabel("left", "Resistance", units="Ohms")
        self.resistancePlot.setLabel("bottom", "Samples", units="")


        self.latestReadData = None
        self.latestRespData = None
        self.resistanceDeque = deque(maxlen=100)  # Initialize the resistance deque

        layout = QVBoxLayout()
        layout.addWidget(self.cmdPlot)
        layout.addWidget(self.respPlot)
        layout.addWidget(self.resistancePlot)
        self.setLayout(layout)
        
        self.updateTimer = QtCore.QTimer()
        self.updateDt = 20
        self.updateTimer.timeout.connect(self.update_plot)
        self.updateTimer.start(self.updateDt)

        self.daqUpdateThread = threading.Thread(target=self.updateDAQDataAsync, daemon=True)
        self.daqUpdateThread.start()
    
    def close(self):
        logging.info("closing graph")
        super(EPhysGraph, self).hide()

    def updateDAQDataAsync(self):
        while True:
            if self.daq.isRunningProtocol:
                continue
            self.latestReadData, self.latestRespData, totalResistance, accessResistance, membraneResistance, membraneCapacitance = self.daq.getDataFromSquareWave(wave_freq = 50, samplesPerSec = 50000, dutyCycle = 0.5, amplitude = 0.5, recordingTime= 0.05)
            if totalResistance is not None:
                self.resistanceDeque.append(totalResistance)

    def update_plot(self):
        if  self.latestReadData is not None and self.latestRespData is not None:
            self.cmdPlot.clear()
            self.cmdPlot.plot(self.latestReadData[0, :], self.latestReadData[1, :])
            self.respPlot.clear()
            self.respPlot.plot(self.latestRespData[0, :], self.latestRespData[1, :])
            self.latestReadData = None
            self.latestRespData = None

        if len(self.resistanceDeque) > 0:
            self.resistancePlot.clear()
            displayDequeY = list(self.resistanceDeque)
            displayDequeX = list(range(len(displayDequeY)))
            self.resistancePlot.plot(displayDequeX, displayDequeY, pen="k")


if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)

    readDev = "cDAQ1Mod1"
    readChannel = "ai0"
    cmdDev = "cDAQ1Mod4"
    cmdChannel = "ao0"
    respDev = "cDAQ1Mod1"
    respChannel = "ai3"

    daq = DAQtest(readDev, readChannel, cmdDev, cmdChannel, respDev, respChannel)
    graph = EPhysGraph(daq)
    graph.show()

    sys.exit(app.exec_())



================================================
File: /testing/niDAQ/vclamptestplot.py
================================================
#test plot of voltage clamp data

import numpy as np
import matplotlib.pyplot as plt
import random

# open a file with voltage clamp data
with open('testvclampdata.csv', 'r') as f:
    data = f.readlines()
    real_numbers = [float(line.strip()) for line in data]

def plot_numbers(numbers):
    plt.figure(figsize=(10, 5))
    plt.plot(numbers, marker='o')  # 'o' creates a circle marker at each data point
    plt.title('Plot of Random Numbers')
    plt.xlabel('Index')
    plt.ylabel('Value')
    plt.grid(True)
    plt.show()

 # Using the function to plot the random numbers
plot_numbers(real_numbers)

================================================
File: /testing/pressure/Pressure/PressureRR/PressureRR.ino
================================================
const int numReadings = 25;  // number of readings to average
float readings[numReadings];   // the readings from the analog input
int readIndex = 0;           // the index of the current reading
float total = 0;               // the running total
float average = 0;             // the average

// So how do we calculate M and B? Victor plotted set values vs the truth (digital nanometer) vs the sensor value, and fit a line
// Nanometer: 0.9559x + 38.237
// Sensor: 0.3923x + 517
// M = 1 / 0.3942 = 2.53678336

// float M = 5.824;
float M = 0.3923;
// float M = 2.559;

void setup() {
  Serial.begin(9600);  // initialize serial communication
  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0;  // initialize all readings to 0
  }
}

void loop() {
  if (Serial.available() > 0) {  // check if data is available to read
    char command = Serial.read();  // read the incoming command
    if (command == 'R') {  // if the command is 'R'
      // read the input on analog pin 0:
      int sensorValue = analogRead(A10);

      // subtract the last reading:
      total = total - readings[readIndex];
      // read from the sensor:
      readings[readIndex] = sensorValue;
      // add the reading to the total:
      total = total + readings[readIndex];
      // advance to the next position in the array:
      readIndex = readIndex + 1;

      // if we're at the end of the array:
      if (readIndex >= numReadings) {
        // wrap around to the beginning:
        readIndex = 0;
      }

      // calculate the average:
      average = total / numReadings;
      
      // compute the adjusted value
      // float Y = M * (average - 513.62);
      float Y = (M*average)+520.48;
      
      // send the result
      Serial.print("S");
      Serial.print(average);
      Serial.println("E");
    }
  }
}


================================================
File: /testing/pressure/Pressure/Pressure.ino
================================================
/*
  AnalogReadSerial

  Reads an analog input on pin 0, prints the result to the Serial Monitor.
  Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu).
  Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground.

  This example code is in the public domain.

  https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogReadSerial
*/

// USB3-7 port is COM 8 for arduino but 9 for seeed?

// ! NOTE: Sending air to the BOTTON valve DECREASES analog pressure reading
// ! NOTE: Sending air to the TOP valve INCREASES analog pressure reading

const int numReadings = 25;  // number of readings to average
float readings[numReadings];   // the readings from the analog input
int readIndex = 0;           // the index of the current reading
float total = 0;               // the running total
float average = 0;             // the average

// the setup routine runs once when you press reset:
void setup() {
  // initialize serial communication at 9600 bits per second:
  Serial.begin(9600);
  
  // initialize all the readings to 0:
  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0;
  }
}

float M = 2.559;
// the loop routine runs over and over again forever:
void loop() {
  // read the input on analog pin 0:
  int sensorValue = analogRead(A0);

  // subtract the last reading:
  total = total - readings[readIndex];
  // read from the sensor:
  readings[readIndex] = sensorValue;
  // add the reading to the total:
  total = total + readings[readIndex];
  // advance to the next position in the array:
  readIndex = readIndex + 1;

  // if we're at the end of the array:
  if (readIndex >= numReadings) {
    // wrap around to the beginning:
    readIndex = 0;
  }

  // calculate the average:
  average = total / numReadings;
  
  // compute the adjusted value
  float Y = M * (average - 512);
  
  // print out the value you read:
  // Serial.println(Y);
  Serial.print("S");
  Serial.print(Y);
  Serial.println("E");

  // THIS DELAY IS CRUCIAL, ANYTHING LESS THAN 33ms WILL CAUSE THE GRAPH TO NOT UPDATE
  // FAST ENOUGH. Think about trying to compress 100fps video in 60fps. You can't.
  // this is because of what is in graph.py, updateDt (set to 33ms)
  delay(16);  // delay in between reads for stability
}


================================================
File: /testing/pressure/PressureControllerTest.py
================================================
'''
GUI to test the pressure controller
'''
import sys
import threading
import serial
from PyQt5.QtWidgets import QApplication, QMainWindow
from PyQt5.QtCore import pyqtSignal, QObject
import pyqtgraph as pg
from datetime import datetime

class SerialReader(QObject):
    data_received = pyqtSignal(float, datetime)

    def __init__(self, port, baud_rate):
        super().__init__()
        self.port = port
        self.baud_rate = baud_rate
        self.serial = serial.Serial(port=self.port, baudrate=self.baud_rate, timeout=1)
        self.running = True

    def start(self):
        thread = threading.Thread(target=self.run)
        thread.start()

    def run(self):
        while self.running:
            if self.serial.in_waiting > 0:
                line = self.serial.readline().decode('utf-8').strip()
                try:
                    number = float(line)
                    timestamp = datetime.now()
                    self.data_received.emit(number, timestamp)
                except ValueError:
                    print("Received non-numeric data:", line)
                except KeyboardInterrupt:
                    print("STOPPING")
                    return

    def stop(self):
        self.running = False
        self.serial.close()

class SerialGrapher(QMainWindow):
    def __init__(self, com_port):
        super().__init__()

        # Graph setup
        self.graphWidget = pg.PlotWidget()
        self.setCentralWidget(self.graphWidget)
        self.graphWidget.setBackground('w')
        self.data_line = self.graphWidget.plot([], [], pen=pg.mkPen('b', width=2))
        self.data = []
        self.timestamps = []

        # Configure plot to show time on x-axis
        self.graphWidget.getPlotItem().setAxisItems({'bottom': pg.DateAxisItem()})

        # Setup serial reader
        self.reader = SerialReader(com_port, 9600)
        self.reader.data_received.connect(self.update_plot)
        self.reader.start()

    def update_plot(self, value, timestamp):
        self.data.append(value)
        self.timestamps.append(timestamp.timestamp())  # Convert datetime to timestamp
        if len(self.data) > 100:
            self.data.pop(0)
            self.timestamps.pop(0)
        self.data_line.setData(self.timestamps, self.data)

    def closeEvent(self, event):
        self.reader.stop()
        super().closeEvent(event)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    com_port = 'COM8'  # Set your COM port here
    main = SerialGrapher(com_port)
    main.show()
    sys.exit(app.exec_())


================================================
File: /testing/pressure/pressureRecorder.py
================================================
from holypipette.devices.pressurecontroller import IBBPressureController
from serial import Serial
import time
from threading import Thread
import io
import numpy as np
import matplotlib.pyplot as plt

csv_path = 'pressureRecording.csv'
serial_device = '/dev/cu.usbmodem144201'
record_time = 90 #seconds

#setup pressure reading
readerSerial = Serial(port=serial_device, baudrate=115200, timeout=1000)
readerSerial.read_all() #clear buffer

isRunning = True
pressure_readings = []

def recordPressure():
    ''' Continuously records pressure readings from the pressure controller
        and appends them to the pressure_readings list. (Meant to be run in a seperate thread.)
    '''
    startTime = time.time()
    print('starting pressure recording...')
    while time.time() - startTime < record_time:
        #read until newline
        try:
            pressure_reading = readerSerial.read_until(b'\r\n', size=100)
            pressure_reading = pressure_reading.decode('ascii').strip()
        except:
            print('error reading pressure')
            continue

        if pressure_reading != '':
            #check if pressure_reading is a float
            pressure = -1
            pressure = float(pressure_reading)
            pressure_readings.append([time.time() - startTime, pressure])

recorderThread = Thread(target = recordPressure)
recorderThread.start()   
recorderThread.join() #wait for thread to finish

#clear file
with open(csv_path, 'w') as f:
    f.write('')

#write pressure readings to file
with open(csv_path, 'w') as f:
    for reading in pressure_readings:
        readTime = reading[0]
        readPressure = reading[1]

        f.write('{},{},\r'.format(readTime, readPressure))

#plot pressure_readings with matplotlib
pressure_readings = np.array(pressure_readings)

#plot pressure readings
plt.plot(pressure_readings[:,0], pressure_readings[:,1], 'b-')

# plt.plot(set_times[:,0], set_times[:,1], 'r-')
plt.xlabel('Time (s)')
plt.ylabel('Pressure (mbar)')
plt.title('Pressure Profile')
plt.legend(['Pressure Readings', 'Setpoints'])

plt.show()

================================================
File: /testing/pressure/pressureSender.py
================================================
from holypipette.devices.pressurecontroller import IBBPressureController
from serial import Serial
import time
from threading import Thread
import io
import numpy as np
import matplotlib.pyplot as plt

pressureBoxSerialPort = '/dev/cu.usbserial-AC012G83'
pressureReaderSerialPort = '/dev/cu.usbmodem141301'

pressureSerial = Serial(port=pressureBoxSerialPort, baudrate=9600, timeout=0)
pressure = IBBPressureController(channel=1, arduinoSerial=pressureSerial)
pressure_readings = []
freq = 15 #Hz

#setup pressure reading
readerSerial = Serial(port=pressureReaderSerialPort, baudrate=115200, timeout=1000)
readerSerial.read_all() #clear buffer

input_path = 'emulateProfile.csv'
isRunning = True

#load input profile from csv
input_profile = np.genfromtxt(input_path, delimiter=',')
raw_times = input_profile[:, 0]
raw_setpoints = input_profile[:, 1]

#make sure times start at 0
raw_times -= raw_times[0]

#we only care about setpoints at 10 Hz
lastTime = raw_times[-1]
dt = 1/freq
times = np.arange(0, lastTime, dt)

#replace last time with lastTime (so we get to proper endpoint)
times[-1] = lastTime

#interpolate setpoints at given times to get setpoints at 10 Hz
setpoints = np.interp(times, raw_times, raw_setpoints, left=raw_setpoints[0], right=raw_setpoints[-1])

#plot raw setpoints and interpolated setpoints in a new window
plt.figure()
plt.plot(raw_times, raw_setpoints, '-', label='raw setpoints')
plt.plot(times, setpoints, 'o', label='interpolated setpoints')
plt.legend()

#add title of input file
plt.title(f'input profile: {input_path}')
plt.show()

def recordPressure():
    while isRunning:
        #read until newline
        try:
            pressure_reading = readerSerial.read_until(b'\r\n', size=100)
            pressure_reading = pressure_reading.decode('ascii').strip()
        except:
            print('error reading pressure')
            continue

        if pressure_reading != '':
            #check if pressure_reading is a float
            pressure = -1
            pressure = float(pressure_reading)
            pressure_readings.append([time.time(), pressure])

T = Thread(target = recordPressure)
T.start()          

#wait for pressure box to initialize
time.sleep(1)
pressure.set_ATM(False)
print('pressure set to 0')
pressure.set_pressure(0)
time.sleep(0.5)

#send setpoints to pressure box at 10 Hz
phase_lag = 0
setpoint_info = []
for setpoint in setpoints:
    print(f'pressure set to {setpoint}')
    pressure.set_pressure(setpoint)
    setpoint_info.append([time.time() + phase_lag, setpoint])
    time.sleep(1 / freq)
setpoint_info = np.array(setpoint_info)

time.sleep(0.5)
print('pressure set to 0')
pressure.set_pressure(0)
time.sleep(0.5)

isRunning = False
pressure_readings = np.array(pressure_readings)

#shift raw setpoint time to match pressure readings
print(setpoint_info.shape, pressure_readings.shape)
raw_times += (setpoint_info[0, 0] - pressure_readings[0, 0])

#pressure readings should start at 0
setpoint_info[:, 0] -= pressure_readings[0, 0]
pressure_readings[:, 0] -= pressure_readings[0, 0]

# plot pressure readings and setpoints in a new window
plt.figure()
plt.plot(setpoint_info[:, 0], setpoint_info[:, 1], 'o', color='tab:orange', label='setpoints')
plt.plot(raw_times, raw_setpoints, '--', color='tab:red', label='original recording')
plt.plot(pressure_readings[:, 0], pressure_readings[:, 1], '-', color='tab:blue', label='pressure reading')
plt.legend()

#add x and y labels
plt.xlabel('time (s)')
plt.ylabel('pressure (mbar)')
plt.title(f'pressure readings from: {input_path} (lag = {phase_lag}s, freq={freq}Hz)')
plt.show()


================================================
File: /testing/pressure/pressurereader2.py
================================================
import sys
import serial
import serial.tools.list_ports
import csv
import os
from PyQt5.QtWidgets import (
    QApplication, QWidget, QPushButton, QVBoxLayout, QHBoxLayout, QLabel, 
    QComboBox, QMessageBox, QTextEdit, QGroupBox, QDialog, QLineEdit, QFileDialog
)
from PyQt5.QtGui import QFont
from PyQt5.QtCore import Qt, QDateTime, QTimer, QThread, pyqtSignal
import numpy as np
import pyqtgraph as pg
import time

class SerialReaderThread(QThread):
    data_received = pyqtSignal(float, float)  # Signal to emit timestamp and value
    error_occurred = pyqtSignal(str)          # Signal to emit error messages

    def __init__(self, serial_port, parent=None):
        super().__init__(parent)
        self.serial_port = serial_port
        self.is_running = True

    def run(self):
        while self.is_running and self.serial_port and self.serial_port.is_open:
            try:
                if self.serial_port.in_waiting > 0:
                    line = self.serial_port.readline().decode('utf-8').strip()
                    if line.startswith('S') and line.endswith('E'):
                        numeric_part = line[1:-1]
                        try:
                            value = float(numeric_part)
                            # value = (value - 520.72) / 0.3923  # Adjusted conversion for pressure sensor
                            # value = (value - 521)/0.213  # Adjusted conversion for pressure sensor
                            timestamp = time.time()
                            self.data_received.emit(timestamp, value)
                        except ValueError:
                            self.error_occurred.emit("Received invalid data format.")
                else:
                    self.msleep(10)  # Sleep briefly to prevent CPU overuse
            except Exception as e:
                self.error_occurred.emit(f"Error reading data: {e}")
                break

    def stop(self):
        self.is_running = False
        self.wait()

class SerialWriterThread(QThread):
    error_occurred = pyqtSignal(str)  # Signal to emit error messages

    def __init__(self, serial_port, parent=None):
        super().__init__(parent)
        self.serial_port = serial_port
        self.is_running = True

    def run(self):
        while self.is_running and self.serial_port and self.serial_port.is_open:
            try:
                self.serial_port.write(b'R')
                self.msleep(int(1000/30))  # Approximately 33 ms
            except Exception as e:
                self.error_occurred.emit(f"Error sending command: {e}")
                break

    def stop(self):
        self.is_running = False
        self.wait()

class PressureReaderApp(QWidget):
    def __init__(self):
        super().__init__()
        self.serial_port = None
        self.is_connected = False
        self.is_reading = False
        self.is_recording = False  # Initialize the recording flag
        self.csv_file = None
        self.csv_writer = None
        self.recording_count = 0  # Counter to track the number of recording sessions
        self.reader_thread = None
        self.writer_thread = None
        self.initUI()

        # Variables for plotting
        self.plot_data = np.zeros(100)  # Buffer for last 100 data points

    def initUI(self):
        self.setFixedSize(700, 500)  # Updated window size
        layout = QHBoxLayout()

        # Left side - Logo and Display
        self.left_layout = QVBoxLayout()

        # PressureReader Logo
        self.logo_label = QLabel("PressureReader", self)
        self.logo_label.setFont(QFont("Comic Sans MS", 32))  # Adjusted font size to make logo smaller
        self.logo_label.setAlignment(Qt.AlignCenter)
        self.left_layout.addWidget(self.logo_label)

        # Initialize and add plot_widget here (before data_display)
        self.init_plot()

        # Data Display (Hidden when plot is shown)
        self.data_display = QTextEdit(self)
        self.data_display.setReadOnly(True)
        self.data_display.setFixedHeight(60)  # Set height for the dialog box
        self.left_layout.addWidget(self.data_display)

        layout.addLayout(self.left_layout)

        # Right side - Buttons and Setup
        right_layout = QVBoxLayout()

        # Communication Box
        communication_box = self.create_communication_box()
        right_layout.addWidget(communication_box)

        # Data Acquisition Box
        acquisition_box = self.create_acquisition_box()
        right_layout.addWidget(acquisition_box)

        layout.addLayout(right_layout)

        self.setLayout(layout)
        self.setWindowTitle('Pressure Reader Control')

    def create_communication_box(self):
        """ Create communication box with COM port selection """
        com_box = QGroupBox("Communication")
        com_layout = QVBoxLayout()

        # COM Port dropdown
        self.com_selector = QComboBox(self)
        self.refresh_com_ports()
        com_layout.addWidget(self.com_selector)

        # Open COM Port Button
        self.open_com_button = QPushButton("Open COM Port", self)
        self.open_com_button.clicked.connect(self.open_com_port)
        com_layout.addWidget(self.open_com_button)

        com_box.setLayout(com_layout)
        return com_box

    def create_acquisition_box(self):
        """ Create data acquisition box with Start Read and Start Record buttons """
        acquisition_box = QGroupBox("Data Acquisition")
        acquisition_layout = QVBoxLayout()

        # Start Read / Stop Read Button
        self.read_button = QPushButton("Start Read", self)
        self.read_button.setCheckable(True)
        self.read_button.setEnabled(False)  # Initially disabled
        self.read_button.toggled.connect(self.toggle_read)
        acquisition_layout.addWidget(self.read_button)

        # Start Record / Stop Record Button
        self.record_button = QPushButton("Start Record", self)
        self.record_button.setCheckable(True)
        self.record_button.setEnabled(False)  # Disabled until reading starts
        self.record_button.toggled.connect(self.toggle_record)
        acquisition_layout.addWidget(self.record_button)

        acquisition_box.setLayout(acquisition_layout)
        return acquisition_box

    def refresh_com_ports(self):
        """ Refresh the list of available COM ports and set default """
        ports = serial.tools.list_ports.comports()
        self.com_selector.clear()
        default_port = "COM8"  # Adjust default port as needed
        available_ports = [port.device for port in ports]
        if default_port in available_ports:
            # set default port if available
            self.com_selector.addItem(default_port)
            # add all other available ports to the dropdown
            self.com_selector.addItems([port for port in available_ports if port != default_port])
        else:
            self.data_display.append(f"Default port {default_port} not available.")
            self.com_selector.addItems(available_ports)

    def open_com_port(self):
        """ Open the selected COM port for communication """
        selected_port = self.com_selector.currentText()
        if selected_port:
            try:
                self.serial_port = serial.Serial(selected_port, 9600, timeout=0.05)  # Adjusted baud rate and shorter timeout
                self.is_connected = True
                self.read_button.setEnabled(True)  # Enable read button when connected
                QMessageBox.information(self, "Success", f"Connected to {selected_port}")
            except serial.SerialException as e:
                QMessageBox.critical(self, "Error", f"Failed to open {selected_port}: {e}")
        else:
            QMessageBox.warning(self, "Warning", "Please select a valid COM port")

    def toggle_read(self, checked):
        """ Start or stop reading data from the pressure sensor """
        if checked:
            self.read_button.setText("Stop Read")
            self.is_reading = True

            # Start the reader thread
            self.reader_thread = SerialReaderThread(self.serial_port)
            self.reader_thread.data_received.connect(self.handle_new_data)
            self.reader_thread.error_occurred.connect(self.handle_error)
            self.reader_thread.start()

            # Start the writer thread to send 'R' commands at ~30 FPS
            self.writer_thread = SerialWriterThread(self.serial_port)
            self.writer_thread.error_occurred.connect(self.handle_error)
            self.writer_thread.start()

            # Enable recording button
            self.record_button.setEnabled(True)

            # Switch to plot view
            self.show_plot()
        else:
            self.read_button.setText("Start Read")
            self.is_reading = False

            # Stop reader thread
            if self.reader_thread and self.reader_thread.isRunning():
                self.reader_thread.stop()

            # Stop writer thread
            if self.writer_thread and self.writer_thread.isRunning():
                self.writer_thread.stop()

            # Disable recording button
            self.record_button.setEnabled(False)

            # Switch back to logo view
            self.hide_plot()

    def toggle_record(self, checked):
        """ Start or stop recording the data to a CSV file """
        if checked:
            self.record_button.setText("Stop Recording")
            self.is_recording = True  # Set recording flag to True
            directory = QFileDialog.getExistingDirectory(self, "Select Directory")
            if directory:
                self.create_csv_file(directory)
            else:
                QMessageBox.warning(self, "Warning", "No directory selected for recording.")
                self.record_button.setChecked(False)
                self.is_recording = False  # Reset recording flag
        else:
            self.record_button.setText("Start Record")
            self.is_recording = False  # Set recording flag to False
            self.close_csv_file()

    def create_csv_file(self, directory):
        """ Create a new CSV file in the selected directory with an incrementer """
        self.recording_count += 1  # Increment the recording counter
        date_str = QDateTime.currentDateTime().toString("MM_dd_yyyy")
        filename = f"PressureReaderRec_{date_str}_{self.recording_count}.csv"  # Append recording count
        filepath = os.path.join(directory, filename)
        try:
            self.csv_file = open(filepath, 'w', newline='')
            self.csv_writer = csv.writer(self.csv_file)
            self.csv_writer.writerow(["Timestamp", "Pressure (mbar)"])  # Write header (adjusted for pressure sensor)
            self.data_display.append(f"Recording started: {filename}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to create CSV file: {e}")
            self.record_button.setChecked(False)
            self.is_recording = False

    def close_csv_file(self):
        """ Close the CSV file """
        if self.csv_file:
            try:
                self.csv_file.close()
                self.data_display.append("Recording stopped.")
            except Exception as e:
                QMessageBox.warning(self, "Warning", f"Failed to close CSV file: {e}")
            finally:
                self.csv_file = None
                self.csv_writer = None

    def handle_new_data(self, timestamp, value):
        """ Handle new data received from the serial port """
        # Display data
        self.data_display.append(f"time: {timestamp:.2f}s, pressure: {value:.2f}mbar")

        # Update plot data buffer
        self.plot_data[:-1] = self.plot_data[1:]
        self.plot_data[-1] = value

        # If recording, write to CSV
        if self.is_recording and self.csv_writer:
            self.csv_writer.writerow([timestamp, value])

    def handle_error(self, message):
        """ Handle errors emitted from threads """
        self.data_display.append(message)
        QMessageBox.critical(self, "Error", message)
        # Optionally, stop reading if a critical error occurs
        self.toggle_read(False)

    def init_plot(self):
        """ Initialize the PyQtGraph plot widget but keep it hidden initially """
        self.plot_widget = pg.PlotWidget(title="Pressure Sensor Data")
        # Make plot background white
        self.plot_widget.setBackground('w')
        self.plot_curve = self.plot_widget.plot(pen='k')
        self.plot_widget.hide()  # Hidden initially
        self.left_layout.addWidget(self.plot_widget)

    def update_plot(self):
        """ Update the plot with the latest data """
        if self.plot_widget.isVisible():
            self.plot_curve.setData(self.plot_data)

    def show_plot(self):
        """ Show the plot and hide the logo """
        self.logo_label.hide()
        self.plot_widget.show()

    def hide_plot(self):
        """ Hide the plot and show the logo """
        self.plot_widget.hide()
        self.logo_label.show()

    def closeEvent(self, event):
        """ Handle application exit """
        self.is_reading = False
        # Stop reader thread
        if self.reader_thread and self.reader_thread.isRunning():
            self.reader_thread.stop()
        # Stop writer thread
        if self.writer_thread and self.writer_thread.isRunning():
            self.writer_thread.stop()
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()
        if self.csv_file:
            self.close_csv_file()
        event.accept()

    def showEvent(self, event):
        """ Initialize the plot timer when the window is shown """
        super().showEvent(event)
        # Initialize plot timer after the window is shown
        self.plot_timer = QTimer()
        self.plot_timer.timeout.connect(self.update_plot)
        self.plot_timer.start(33)  # Update plot every 50 ms

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = PressureReaderApp()
    ex.show()
    sys.exit(app.exec_())


================================================
File: /testing/arduinoDAQ/DAQreaderv0_004.py
================================================


import serial
import time



def send_command(recordingTime, wave_freq, amplitude, samplesPerSec, dutyCycle, scaling):
    # Define the command to send
     signalDurationMicros = int(recordingTime * 1e6)  # Duration in microseconds
     waveFrequencyMicros = int(1e6 / wave_freq)  # Wave period in microseconds
     waveAmplitude = int(amplitude * scaling)  # Amplitude scaled to 10-bit DAC
     sampleIntervalMicros = int(1e6 / samplesPerSec)  # Sampling interval in microseconds
     dutyCyclePercent = int(dutyCycle * 100)  # Duty cycle in percentage
     numSamples = int(recordingTime * samplesPerSec)  # Number of samples to record
     print(f"number of samples: {numSamples}")
     command = f"a {signalDurationMicros} {waveFrequencyMicros} {waveAmplitude} {sampleIntervalMicros} {dutyCyclePercent}\n"
     serial_port.write(command.encode('utf-8'))
     print(f"Sent command: {command.strip()}")

def read_serial_data():
    collecting_data = False
    command = []
    response = []
    # Continuously read data from the Arduino
    while True:
        if serial_port.in_waiting > 0:  # Check if data is available
            line = serial_port.readline().decode('utf-8').strip()
            
            if line == "start":
                collecting_data = True
                print("Data collection started")
            elif line == "end":
                print("Data collection ended")
                break
            elif collecting_data:
                # Split the line by comma to get command and response values
                values = line.split(',')
                if len(values) == 2:
                    command_value, response_value = values
                    command.append(command_value)
                    response.append(response_value)
                    print(f"Received: Command={command_value}, Response={response_value}")
                else:
                    print(f"Unexpected data format: {line}")
            # Print the command and response data lengths
            print(f"Command data length: {len(command)}")
            print(f"Response data length: {len(response)}")

if __name__ == '__main__':
    # Send the command
        # Set up the serial connection (adjust COM port as needed)
    serial_port = serial.Serial('COM11', 500000, timeout=1)  # Set timeout to 1 second
    recordingTime = 0.04  # Duration of signal in seconds
    wave_freq = 25  # Frequency of the wave in Hz
    amplitude = 0.66 # Amplitude of the wave in decimal of maximum value
    samplesPerSec = 10000 # Sampling rate in Hz
    dutyCycle = 0.5 # Duty cycle of the square wave
    scaling = 1023   # Scaling factor for 10-bit DAC
    send_command(recordingTime, wave_freq, amplitude, samplesPerSec, dutyCycle, scaling)
    
    # Give the Arduino a moment to process and start sending data
    time.sleep(0.1)
    
    # Read and print incoming serial data
    print("Waiting for data from Arduino:")
    read_serial_data()
    
    # Close the serial port
    serial_port.close()


================================================
File: /testing/arduinoDAQ/arduinoDAQ_sinetest/arduinoDAQ_sinetest.ino
================================================
#define DAC_PIN A0 // Make code a bit more legible

float x = 0; // Value to take the sin of
float increment = 0.02;  // Value to increment x by each time
int frequency = 440; // Frequency of sine wave

void setup() 
{
  analogWriteResolution(10); // Set analog out resolution to max, 10-bits
  analogReadResolution(12); // Set analog input resolution to max, 12-bits

  Serial.begin(9600);
}

void loop() 
{
  // Generate a voltage value between 0 and 1023. 
  // Let's scale a sin wave between those values:
  // Offset by 511.5, then multiply sin by 511.5.
  int dacVoltage = (int)(511.5 + 511.5 * sin(x));
  x += increment; // Increase value of x

  // Generate a voltage between 0 and 3.3V.
  // 0= 0V, 1023=3.3V, 512=1.65V, etc.
  analogWrite(DAC_PIN, dacVoltage);

  // Now read A1 (connected to A0), and convert that
  // 12-bit ADC value to a voltage between 0 and 3.3.
  float voltage = analogRead(A1) * 3.3 / 4096.0;
  Serial.println(voltage); // Print the voltage.
  delay(1); // Delay 1ms
}

================================================
File: /testing/arduinoDAQ/arduinoDAQ_v0_004/arduinoDAQ_v0_004.ino
================================================
// Define the baud rate
const unsigned long BAUD_RATE = 500000; 
// Set up analog DAC out
const int DAC_PIN = A0;
// Set up analog ADC in
const int ADC_PIN1 = A1;
const int ADC_PIN2 = A2;

// Define a struct to hold parsed command values
struct CommandParameters {
  int signalDurationMicros;
  int waveFrequencyMicros;
  int waveAmplitude;
  int sampleIntervalMicros;
  int dutyCycle;
};

// Global struct instance to hold parsed values
volatile CommandParameters commandParams = {0, 0, 0, 0, 0};

// Global variables for readData and respData
int* readData;
int* respData;

void setup() {
  analogWriteResolution(10); // Set analog out resolution to max, 10-bits (if supported by board)
  analogReadResolution(12);  // Set analog input resolution to max, 12-bits (if supported by board)

  Serial.begin(BAUD_RATE);
  Serial.println("Arduino is ready and listening for commands...");
}

void loop() {
  if (Serial.available() > 0) {
    char command[50]; // Buffer to hold incoming command
    int len = Serial.readBytesUntil('\n', command, sizeof(command) - 1);
    command[len] = '\0'; // Null-terminate the string

    parseCommand(command); // Parse the command
    generateData(const_cast<CommandParameters&>(commandParams)); // Generate wave and capture readings

    // Print the captured response data
    Serial.println("start");
    int numSamples = commandParams.signalDurationMicros / commandParams.sampleIntervalMicros;
    for (int i = 0; i < numSamples; i++) {
      Serial.print(readData[i]);
      Serial.print(",");
      Serial.println(respData[i]);
    }
    Serial.println("end"); // Fixed missing semicolon

    // Free readData and respData after use
    free(readData);
    readData = nullptr; // Optional: Set pointer to nullptr to avoid accidental access
    free(respData);
    respData = nullptr;
  }
}

void parseCommand(const char* command) {
  // Parse values into struct fields using sscanf
  if (sscanf(command, "a %d %d %d %d %d", &commandParams.signalDurationMicros, &commandParams.waveFrequencyMicros, 
             &commandParams.waveAmplitude, &commandParams.sampleIntervalMicros, &commandParams.dutyCycle) != 5) {
    Serial.println("Error: Incorrect command format.");
  }
}

void generateData(CommandParameters& params) {
  // Calculate the required parameters
  int numSamples = params.signalDurationMicros / params.sampleIntervalMicros;
  int period = params.waveFrequencyMicros / params.sampleIntervalMicros;
  int onTime = (period * params.dutyCycle) / 100;

  // Allocate memory for wave and read data arrays
  int* waveData = (int*)malloc(numSamples * sizeof(int));
  readData = (int*)malloc(numSamples * sizeof(int)); // Allocate readData
  respData = (int*)malloc(numSamples * sizeof(int)); // Allocate respData

  if (waveData == nullptr || readData == nullptr || respData == nullptr) {
    Serial.println("Error: Memory allocation failed.");
    free(waveData); // Ensure all allocated memory is freed if allocation fails
    free(readData);
    free(respData);
    return;
  }

  // Generate square wave pattern in waveData array
  for (int i = 0; i < numSamples; i += period) {
    // Set 'on' values for the duty cycle period
    for (int j = 0; j < onTime && (i + j) < numSamples; ++j) {
      waveData[i + j] = params.waveAmplitude;
    }
    // Set 'off' values for the remainder of the period
    for (int j = onTime; j < period && (i + j) < numSamples; ++j) {
      waveData[i + j] = 0;
    }
  }

  // Write wave to DAC and read response to ADC
  for (int i = 0; i < numSamples; i++) {
    analogWrite(DAC_PIN, waveData[i]);           // Write each sample to analog pin
    readData[i] = analogRead(ADC_PIN1);          // Read command from analog input 1
    respData[i] = analogRead(ADC_PIN2);          // Read response from analog input 2
    delayMicroseconds(params.sampleIntervalMicros); // Wait for sample interval
  }

  // Free dynamically allocated memory for waveData
  free(waveData);
}


================================================
File: /testing/arduinoDAQ/DAQreaderv0_003.py
================================================


import serial
import time



def send_command(recordingTime, wave_freq, amplitude, samplesPerSec, dutyCycle, scaling):
    # Define the command to send
     signalDurationMicros = int(recordingTime * 1e6)  # Duration in microseconds
     waveFrequencyMicros = int(1e6 / wave_freq)  # Wave period in microseconds
     waveAmplitude = int(amplitude * scaling)  # Amplitude scaled to 10-bit DAC
     sampleIntervalMicros = int(1e6 / samplesPerSec)  # Sampling interval in microseconds
     dutyCyclePercent = int(dutyCycle * 100)  # Duty cycle in percentage
     command = f"a {signalDurationMicros} {waveFrequencyMicros} {waveAmplitude} {sampleIntervalMicros} {dutyCyclePercent}\n"
     serial_port.write(command.encode('utf-8'))
     print(f"Sent command: {command.strip()}")

def read_serial_data():
    collecting_data = False
    
    # Continuously read data from the Arduino
    while True:
        if serial_port.in_waiting > 0:  # Check if data is available
            line = serial_port.readline().decode('utf-8').strip()
            
            if line == "start":
                collecting_data = True
                print("Data collection started")
            elif line == "end":
                print("Data collection ended")
                break
            elif collecting_data:
                # Split the line by comma to get command and response values
                values = line.split(',')
                if len(values) == 2:
                    command_value, response_value = values
                    print(f"Received: Command={command_value}, Response={response_value}")
                else:
                    print(f"Unexpected data format: {line}")


if __name__ == '__main__':
    # Send the command
        # Set up the serial connection (adjust COM port as needed)
    serial_port = serial.Serial('COM11', 115200, timeout=1)  # Set timeout to 1 second
    recordingTime = 0.04  # Duration of signal in seconds
    wave_freq = 250  # Frequency of the wave in Hz
    amplitude = 0.66 # Amplitude of the wave in decimal of maximum value
    samplesPerSec = 10000 # Sampling rate in Hz
    dutyCycle = 0.5 # Duty cycle of the square wave
    scaling = 1023   # Scaling factor for 10-bit DAC
    send_command(recordingTime, wave_freq, amplitude, samplesPerSec, dutyCycle, scaling)
    
    # Give the Arduino a moment to process and start sending data
    time.sleep(0.1)
    
    # Read and print incoming serial data
    print("Waiting for data from Arduino:")
    read_serial_data()
    
    # Close the serial port
    serial_port.close()


================================================
File: /testing/arduinoDAQ/arduinoDAQ_v0_003/arduinoDAQ_v0_003.ino
================================================
// Define the baud rate
const unsigned long BAUD_RATE = 115200;
// Set up analog DAC out
const int DAC_PIN = A0;
// Set up analog ADC in
const int ADC_PIN1 = A1;

// Define a struct to hold parsed command values
struct CommandParameters {
  int signalDurationMicros;
  int waveFrequencyMicros;
  int waveAmplitude;
  int sampleIntervalMicros;
  int dutyCycle;
};

// Global struct instance to hold parsed values
volatile CommandParameters commandParams = {0, 0, 0, 0, 0};

// Global variable for readData
int* readData;

void setup() {
  analogWriteResolution(10); // Set analog out resolution to max, 10-bits (if supported by board)
  analogReadResolution(12);  // Set analog input resolution to max, 12-bits (if supported by board)

  Serial.begin(BAUD_RATE);
  Serial.println("Arduino is ready and listening for commands...");
}

void loop() {
  if (Serial.available() > 0) {
    char command[50]; // Buffer to hold incoming command
    int len = Serial.readBytesUntil('\n', command, sizeof(command) - 1);
    command[len] = '\0'; // Null-terminate the string

    parseCommand(command); // Parse the command
    generateData(const_cast<CommandParameters&>(commandParams)); // Generate wave and capture readings

    // Print the captured response data
    Serial.println("start");
    int numSamples = commandParams.signalDurationMicros / commandParams.sampleIntervalMicros;
    for (int i = 0; i < numSamples; i++) {
      Serial.println(readData[i]);
    }
    Serial.println("end"); // Fixed missing semicolon

    // Free readData after use
    free(readData);
    readData = nullptr; // Optional: Set pointer to nullptr to avoid accidental access
  }
}


void generateData(CommandParameters& params) {
  // Calculate the required parameters
  int numSamples = params.signalDurationMicros / params.sampleIntervalMicros;
  int period = params.waveFrequencyMicros / params.sampleIntervalMicros;
  int onTime = (period * params.dutyCycle) / 100;

  // Allocate memory for wave and read data arrays
  int* waveData = (int*)malloc(numSamples * sizeof(int));
  readData = (int*)malloc(numSamples * sizeof(int)); // Allocate readData

  if (waveData == nullptr || readData == nullptr) {
    Serial.println("Error: Memory allocation failed.");
    return; // Exit if allocation fails
  }

  // Generate square wave pattern in waveData array
  for (int i = 0; i < numSamples; i += period) {
    // Set 'on' values for the duty cycle period
    for (int j = 0; j < onTime && (i + j) < numSamples; ++j) {
      waveData[i + j] = params.waveAmplitude;
    }
    // Set 'off' values for the remainder of the period
    for (int j = onTime; j < period && (i + j) < numSamples; ++j) {
      waveData[i + j] = 0;
    }
  }

  // Write wave to DAC and read response to ADC
  for (int i = 0; i < numSamples; i++) {
    analogWrite(DAC_PIN, waveData[i]);           // Write each sample to analog pin
    readData[i] = analogRead(ADC_PIN1);           // Read response from analog input
    delayMicroseconds(params.sampleIntervalMicros); // Wait for sample interval
  }

  // Free dynamically allocated memory
  free(waveData);
  // No free for readData here, as it’s used outside of generateData
}


================================================
File: /requirements.txt
================================================
av==14.0.1
beautifulsoup4==4.12.3
dataclasses_json==0.6.7
decord==0.6.0
Flask==3.1.0
flask_cors==5.0.0
huggingface_hub==0.27.0
hydra-core==1.3.2
imageio==2.34.2
imagesize==1.4.1
iopath==0.1.10
matplotlib==3.7.1
nidaqmx==1.0.2
numpy==2.2.0
omegaconf==2.3.0
onnxruntime_gpu==1.19.2
opencv_python==4.10.0.84
opencv_python_headless==4.10.0.84
pandas==2.2.3
param==1.13.0
pco==0.1.3
Pillow==11.0.0
pycocotools==2.0.8
pymmcore==11.1.1.71.0
PyQt5==5.15.11
PyQt5_sip==12.15.0
pyqtgraph==0.13.7
pyserial==3.5
PyYAML==6.0.2
QtAwesome==1.2.3
Requests==2.32.3
scipy==1.14.1
sensapex==1.400.0
setuptools==68.2.2





================================================
File: /patch_gui.py
================================================
# patch_gui.py
import faulthandler
faulthandler.enable()
faulthandler.dump_traceback_later(5)

import sys
from PyQt5.QtWidgets import QApplication
import traceback
from holypipette.exception_handler import set_global_exception_hook

# Set the global exception hook
set_global_exception_hook()


from holypipette.log_utils import setup_logging
from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.interface import AutoPatchInterface
from holypipette.interface.pipettes import PipetteInterface
from holypipette.gui.graph import EPhysGraph, CurrentProtocolGraph, VoltageProtocolGraph, HoldingProtocolGraph
from holypipette.gui.patch import PatchGui


from setup.setup_Moscow_rig import *


setup_logging()  # Log to the standard console as well

def main():
    app = QApplication(sys.argv)

    recording_state_manager = RecordingStateManager()

    pipette_controller = PipetteInterface(stage, microscope, camera, unit, cellSorterManip, cellSorterController)
    patch_controller = AutoPatchInterface(amplifier, daq, pressure, pipette_controller)
    gui = PatchGui(camera, pipette_controller, patch_controller, recording_state_manager)
    graphs = EPhysGraph(daq, pressure, recording_state_manager)
    # graphs.location_on_the_screen()
    graphs.show()

    currentProtocolGraph = CurrentProtocolGraph(daq, recording_state_manager)
    voltageProtocolGraph = VoltageProtocolGraph(daq, recording_state_manager)
    holdingProtocolGraph = HoldingProtocolGraph(daq, recording_state_manager)

    gui.initialize()
    # gui.location_on_the_screen()
    gui.show()
    ret = app.exec_()
    sys.exit(ret)

if __name__ == "__main__":
    main()

================================================
File: /experiments/Data/Pressure_reader_data/PressureReaderRec_10_21_2024_1.csv
================================================
Timestamp,Pressure (mbar)
1729538130.9219143,2.14121845526362
1729538130.9838603,2.039255671679721
1729538131.0389585,2.14121845526362
1729538131.1090975,2.243181238847809
1729538131.1692288,2.243181238847809
1729538131.2293265,2.243181238847809
1729538131.2894726,2.14121845526362
1729538131.355705,2.039255671679721
1729538131.418043,2.039255671679721
1729538131.4788306,2.039255671679721
1729538131.5397022,2.14121845526362
1729538131.5998778,2.3451440224317084
1729538131.6625133,2.3451440224317084
1729538131.7297037,2.243181238847809
1729538131.7893844,2.3451440224317084
1729538131.8595374,2.243181238847809
1729538131.9162166,2.3451440224317084
1729538131.9831748,2.3451440224317084
1729538132.0427892,2.4471068060156074
1729538132.1027167,2.3451440224317084
1729538132.1654565,2.3451440224317084
1729538132.2264223,2.3451440224317084
1729538132.2882755,2.243181238847809
1729538132.3514378,2.3451440224317084
1729538132.4148045,2.4471068060156074
1729538132.4758098,2.4471068060156074
1729538132.5374348,2.5490695895997963
1729538132.6154716,2.5490695895997963
1729538132.6801708,2.5490695895997963
1729538132.7550044,2.5490695895997963
1729538132.818096,2.6510323731836953
1729538132.8810077,2.6510323731836953
1729538132.9452653,2.7529951567675943


================================================
File: /experiments/Data/log_data/logs_2024_09_23.csv
================================================
Time(HH:MM:SS),Time(ms),Level,Message,Logger Name,Thread ID
2024-09-23 12:44:31,550,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:44:31,555,DEBUG,Adding config GUI for Calibration,root,42980
2024-09-23 12:44:31,557,WARNING,Use method 'params' via param namespace ,param.CalibrationConfig,42980
2024-09-23 12:44:31,563,DEBUG,Config GUI added,root,42980
2024-09-23 12:44:31,563,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:44:31,565,DEBUG,Adding config GUI for Patch,root,42980
2024-09-23 12:44:31,566,WARNING,Use method 'params' via param namespace ,param.PatchConfig,42980
2024-09-23 12:44:31,569,DEBUG,Config GUI added,root,42980
2024-09-23 12:44:31,569,DEBUG,Added config GUI.,root,42980
2024-09-23 12:44:31,569,DEBUG,Added 'Auto Patching' tab.,root,42980
2024-09-23 12:44:31,570,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:44:31,571,INFO,Setting pressure to 19.758327890267797 mbar (raw: 2017),root,42980
2024-09-23 12:44:31,572,INFO,"Sending command: set 1 2017
",root,42980
2024-09-23 12:44:31,573,INFO,"SenT command: set 1 2017
",root,42980
2024-09-23 12:44:31,610,WARNING,No data received from pressure sensor,root,42980
2024-09-23 12:44:31,611,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:46:03,552,INFO,closing GUI,root,42980
2024-09-23 12:46:04,362,ERROR,Uncaught exception,root,"42980
Traceback (most recent call last):
  File ""c:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\gui\graph.py""", line 442," in closeEvent
    self.recorder.close()
  File ""c:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\utils\FileLogger.py""", line 169," in close
    self.write_frame.wait()
    ^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'wait'"
Time(HH:MM:SS),Time(ms),Level,Message,Logger Name,Thread ID
2024-09-23 12:44:28,484,INFO,Program Started,root,42980
2024-09-23 12:44:29,288,DEBUG,matplotlib data path: C:\Users\sa-forest\.conda\envs\moscow3\Lib\site-packages\matplotlib\mpl-data,matplotlib,42980
2024-09-23 12:44:29,291,DEBUG,CONFIGDIR=C:\Users\sa-forest\.matplotlib,matplotlib,42980
2024-09-23 12:44:29,292,DEBUG,interactive is False,matplotlib,42980
2024-09-23 12:44:29,292,DEBUG,platform is win32,matplotlib,42980
2024-09-23 12:44:29,318,DEBUG,CACHEDIR=C:\Users\sa-forest\.matplotlib,matplotlib,42980
2024-09-23 12:44:29,320,DEBUG,Using fontManager instance from C:\Users\sa-forest\.matplotlib\fontlist-v330.json,matplotlib.font_manager,42980
2024-09-23 12:44:29,428,INFO,PatchConfig initialized successfully.,root,42980
2024-09-23 12:44:30,126,INFO,Using cDAQ1Mod1/ai0 for reading the output of cDaq1Mod4/ao0 and cDaq1Mod1/ai3 for response.,root,42980
2024-09-23 12:44:31,141,INFO,Found a MultiClamp 700B (Serial number: b'00832526'  Channel: 1),root,42980
2024-09-23 12:44:31,141,INFO,Found a MultiClamp 700B (Serial number: b'00832526'  Channel: 2),root,42980
2024-09-23 12:44:31,158,INFO,Switching to Pressure,root,42980
2024-09-23 12:44:31,158,INFO,Setting pressure to 0.0 mbar (raw: 1962),root,42980
2024-09-23 12:44:31,158,INFO,"Sending command: set 1 1962
",root,42980
2024-09-23 12:44:31,165,INFO,"SenT command: set 1 1962
",root,42980
2024-09-23 12:44:31,550,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:44:31,555,DEBUG,Adding config GUI for Calibration,root,42980
2024-09-23 12:44:31,557,WARNING,Use method 'params' via param namespace ,param.CalibrationConfig,42980
2024-09-23 12:44:31,563,DEBUG,Config GUI added,root,42980
2024-09-23 12:44:31,563,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:44:31,565,DEBUG,Adding config GUI for Patch,root,42980
2024-09-23 12:44:31,566,WARNING,Use method 'params' via param namespace ,param.PatchConfig,42980
2024-09-23 12:44:31,569,DEBUG,Config GUI added,root,42980
2024-09-23 12:44:31,569,DEBUG,Added config GUI.,root,42980
2024-09-23 12:44:31,569,DEBUG,Added 'Auto Patching' tab.,root,42980
2024-09-23 12:44:31,570,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:44:31,571,INFO,Setting pressure to 19.758327890267797 mbar (raw: 2017),root,42980
2024-09-23 12:44:31,572,INFO,"Sending command: set 1 2017
",root,42980
2024-09-23 12:44:31,573,INFO,"SenT command: set 1 2017
",root,42980
2024-09-23 12:44:31,610,WARNING,No data received from pressure sensor,root,42980
2024-09-23 12:44:31,611,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_44/,root,42980
2024-09-23 12:46:03,552,INFO,closing GUI,root,42980
2024-09-23 12:46:04,362,ERROR,Uncaught exception,root,"42980
Traceback (most recent call last):
  File ""c:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\gui\graph.py""", line 442," in closeEvent
    self.recorder.close()
  File ""c:\Users\sa-forest\Documents\GitHub\holypipette-pbl\holypipette\utils\FileLogger.py""", line 169," in close
    self.write_frame.wait()
    ^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'wait'"
2024-09-23 12:52:41,813,INFO,Program Started,root,15916
2024-09-23 12:52:42,608,DEBUG,matplotlib data path: C:\Users\sa-forest\.conda\envs\moscow3\Lib\site-packages\matplotlib\mpl-data,matplotlib,15916
2024-09-23 12:52:42,608,DEBUG,CONFIGDIR=C:\Users\sa-forest\.matplotlib,matplotlib,15916
2024-09-23 12:52:42,608,DEBUG,interactive is False,matplotlib,15916
2024-09-23 12:52:42,608,DEBUG,platform is win32,matplotlib,15916
2024-09-23 12:52:42,640,DEBUG,CACHEDIR=C:\Users\sa-forest\.matplotlib,matplotlib,15916
2024-09-23 12:52:42,642,DEBUG,Using fontManager instance from C:\Users\sa-forest\.matplotlib\fontlist-v330.json,matplotlib.font_manager,15916
2024-09-23 12:52:42,748,INFO,PatchConfig initialized successfully.,root,15916
2024-09-23 12:52:43,432,INFO,Using cDAQ1Mod1/ai0 for reading the output of cDaq1Mod4/ao0 and cDaq1Mod1/ai3 for response.,root,15916
2024-09-23 12:52:44,435,INFO,Found a MultiClamp 700B (Serial number: b'00832526'  Channel: 1),root,15916
2024-09-23 12:52:44,435,INFO,Found a MultiClamp 700B (Serial number: b'00832526'  Channel: 2),root,15916
2024-09-23 12:52:44,445,INFO,Switching to Pressure,root,15916
2024-09-23 12:52:44,445,INFO,Setting pressure to 0.0 mbar (raw: 1962),root,15916
2024-09-23 12:52:44,445,INFO,"Sending command: set 1 1962
",root,15916
2024-09-23 12:52:44,459,INFO,"SenT command: set 1 1962
",root,15916
2024-09-23 12:52:44,848,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:52:44,848,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:52:44,853,DEBUG,Adding config GUI for Calibration,root,15916
2024-09-23 12:52:44,853,DEBUG,Adding config GUI for Calibration,root,15916
2024-09-23 12:52:44,856,WARNING,Use method 'params' via param namespace ,param.CalibrationConfig,15916
2024-09-23 12:52:44,856,WARNING,Use method 'params' via param namespace ,param.CalibrationConfig,15916
2024-09-23 12:52:44,862,DEBUG,Config GUI added,root,15916
2024-09-23 12:52:44,862,DEBUG,Config GUI added,root,15916
2024-09-23 12:52:44,863,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:52:44,863,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:52:44,864,DEBUG,Adding config GUI for Patch,root,15916
2024-09-23 12:52:44,864,DEBUG,Adding config GUI for Patch,root,15916
2024-09-23 12:52:44,865,WARNING,Use method 'params' via param namespace ,param.PatchConfig,15916
2024-09-23 12:52:44,865,WARNING,Use method 'params' via param namespace ,param.PatchConfig,15916
2024-09-23 12:52:44,870,DEBUG,Config GUI added,root,15916
2024-09-23 12:52:44,870,DEBUG,Config GUI added,root,15916
2024-09-23 12:52:44,871,DEBUG,Added config GUI.,root,15916
2024-09-23 12:52:44,871,DEBUG,Added config GUI.,root,15916
2024-09-23 12:52:44,871,DEBUG,Added 'Auto Patching' tab.,root,15916
2024-09-23 12:52:44,871,DEBUG,Added 'Auto Patching' tab.,root,15916
2024-09-23 12:52:44,872,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:52:44,872,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:52:44,873,INFO,Setting pressure to 19.758327890267797 mbar (raw: 2017),root,15916
2024-09-23 12:52:44,873,INFO,Setting pressure to 19.758327890267797 mbar (raw: 2017),root,15916
2024-09-23 12:52:44,873,INFO,"Sending command: set 1 2017
",root,15916
2024-09-23 12:52:44,873,INFO,"Sending command: set 1 2017
",root,15916
2024-09-23 12:52:44,874,INFO,"SenT command: set 1 2017
",root,15916
2024-09-23 12:52:44,874,INFO,"SenT command: set 1 2017
",root,15916
2024-09-23 12:52:44,914,WARNING,No data received from pressure sensor,root,15916
2024-09-23 12:52:44,914,WARNING,No data received from pressure sensor,root,15916
2024-09-23 12:52:44,915,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:52:44,915,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_52/,root,15916
2024-09-23 12:53:01,290,INFO,Program Started,root,35664
2024-09-23 12:53:02,026,DEBUG,matplotlib data path: C:\Users\sa-forest\.conda\envs\moscow3\Lib\site-packages\matplotlib\mpl-data,matplotlib,35664
2024-09-23 12:53:02,029,DEBUG,CONFIGDIR=C:\Users\sa-forest\.matplotlib,matplotlib,35664
2024-09-23 12:53:02,029,DEBUG,interactive is False,matplotlib,35664
2024-09-23 12:53:02,030,DEBUG,platform is win32,matplotlib,35664
2024-09-23 12:53:02,056,DEBUG,CACHEDIR=C:\Users\sa-forest\.matplotlib,matplotlib,35664
2024-09-23 12:53:02,058,DEBUG,Using fontManager instance from C:\Users\sa-forest\.matplotlib\fontlist-v330.json,matplotlib.font_manager,35664
2024-09-23 12:53:02,167,INFO,PatchConfig initialized successfully.,root,35664
2024-09-23 12:53:02,818,INFO,Using cDAQ1Mod1/ai0 for reading the output of cDaq1Mod4/ao0 and cDaq1Mod1/ai3 for response.,root,35664
2024-09-23 12:53:03,841,INFO,Found a MultiClamp 700B (Serial number: b'00832526'  Channel: 1),root,35664
2024-09-23 12:53:03,841,INFO,Found a MultiClamp 700B (Serial number: b'00832526'  Channel: 2),root,35664
2024-09-23 12:53:03,857,INFO,Switching to Pressure,root,35664
2024-09-23 12:53:03,858,INFO,Setting pressure to 0.0 mbar (raw: 1962),root,35664
2024-09-23 12:53:03,858,INFO,"Sending command: set 1 1962
",root,35664
2024-09-23 12:53:03,866,INFO,"SenT command: set 1 1962
",root,35664
2024-09-23 12:53:04,315,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664
2024-09-23 12:53:04,315,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664
2024-09-23 12:53:04,321,DEBUG,Adding config GUI for Calibration,root,35664
2024-09-23 12:53:04,321,DEBUG,Adding config GUI for Calibration,root,35664
2024-09-23 12:53:04,322,WARNING,Use method 'params' via param namespace ,param.CalibrationConfig,35664
2024-09-23 12:53:04,322,WARNING,Use method 'params' via param namespace ,param.CalibrationConfig,35664
2024-09-23 12:53:04,330,DEBUG,Config GUI added,root,35664
2024-09-23 12:53:04,330,DEBUG,Config GUI added,root,35664
2024-09-23 12:53:04,330,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664
2024-09-23 12:53:04,330,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664
2024-09-23 12:53:04,332,DEBUG,Adding config GUI for Patch,root,35664
2024-09-23 12:53:04,332,DEBUG,Adding config GUI for Patch,root,35664
2024-09-23 12:53:04,333,WARNING,Use method 'params' via param namespace ,param.PatchConfig,35664
2024-09-23 12:53:04,333,WARNING,Use method 'params' via param namespace ,param.PatchConfig,35664
2024-09-23 12:53:04,336,DEBUG,Config GUI added,root,35664
2024-09-23 12:53:04,336,DEBUG,Config GUI added,root,35664
2024-09-23 12:53:04,337,DEBUG,Added config GUI.,root,35664
2024-09-23 12:53:04,337,DEBUG,Added config GUI.,root,35664
2024-09-23 12:53:04,337,DEBUG,Added 'Auto Patching' tab.,root,35664
2024-09-23 12:53:04,337,DEBUG,Added 'Auto Patching' tab.,root,35664
2024-09-23 12:53:04,339,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664
2024-09-23 12:53:04,339,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664
2024-09-23 12:53:04,340,INFO,Setting pressure to 19.758327890267797 mbar (raw: 2017),root,35664
2024-09-23 12:53:04,340,INFO,Setting pressure to 19.758327890267797 mbar (raw: 2017),root,35664
2024-09-23 12:53:04,341,INFO,"Sending command: set 1 2017
",root,35664
2024-09-23 12:53:04,341,INFO,"Sending command: set 1 2017
",root,35664
2024-09-23 12:53:04,341,INFO,"SenT command: set 1 2017
",root,35664
2024-09-23 12:53:04,341,INFO,"SenT command: set 1 2017
",root,35664
2024-09-23 12:53:04,385,WARNING,No data received from pressure sensor,root,35664
2024-09-23 12:53:04,385,WARNING,No data received from pressure sensor,root,35664
2024-09-23 12:53:04,387,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664
2024-09-23 12:53:04,387,INFO,FileLogger initialized. Folder path set to: experiments/Data/rig_recorder_data/2024_09_23-12_53/,root,35664


================================================
File: /experiments/reference/scraper.py
================================================
# used to grab images from Dr. Matt Gaidica website, assistant professor in the Department of Neuroscience at Washington University in St. Louis
# https://labs.gaidi.ca/mouse-brain-atlas/
import requests
from bs4 import BeautifulSoup
import os
import numpy as np
import itertools
from urllib.parse import urljoin

# Base URL of the website
base_url = "https://labs.gaidi.ca/mouse-brain-atlas/"

# Define the folder path
folder_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\reference\images"

# Create a directory to save the images
os.makedirs(folder_path, exist_ok=True)

# Generate combinations of coordinates with increments of 0.12
ml_values = np.arange(-8, 4.12, 0.12)
ap_values = np.arange(0.12, 3.12, 0.12)
coordinate_combinations = itertools.product(ml_values, ap_values)

def download_image(img_url, ml, ap, view):
    img_data = requests.get(img_url).content
    img_name = os.path.join(folder_path, f"ML_{ml}_AP_{ap}_{view}.jpg")
    with open(img_name, 'wb') as handler:
        handler.write(img_data)
    print(f"Downloaded {img_name}")

def process_page(url, ml, ap):
    response = requests.get(url)
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, 'html.parser')
        img_tags = soup.find_all('img')
        
        if len(img_tags) >= 2:
            coronal_img_url = urljoin(base_url, img_tags[0]['src'])
            sagittal_img_url = urljoin(base_url, img_tags[1]['src'])
            download_image(coronal_img_url, ml, ap, 'coronal')
            download_image(sagittal_img_url, ml, ap, 'sagittal')
        else:
            print(f"Not enough images found for ML={ml}, AP={ap}")
    else:
        print(f"Failed to load page for ML={ml}, AP={ap} - Status Code: {response.status_code}")

for ml, ap in coordinate_combinations:
    ml_str = f"{ml:.2f}"
    ap_str = f"{ap:.2f}"
    page_url = f"{base_url}?ml={ml_str}&ap={ap_str}"
    process_page(page_url, ml_str, ap_str)

print("All images have been downloaded.")


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/file_size_checker.py
================================================



import os
import pandas as pd

def get_dir_size(directory):
    """ Calculate the total size of files in a directory in megabytes. """
    if not os.path.exists(directory):
        print(f"Directory not found: {directory}")
        return 0
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(directory):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            if not os.path.islink(fp):
                total_size += os.path.getsize(fp)
    return total_size / (1024 * 1024)  # Convert bytes to megabytes

def add_folder_sizes(base_directory, csv_file_path):
    """ Add folder sizes to the CSV data. """
    data = pd.read_csv(csv_file_path, delimiter='\t')
    folder_sizes = []
    
    for index, row in data.iterrows():
        # Construct the directory path using both package and format
        dir_name = f"{row['Package']}_{row['Format']}"
        dir_path = os.path.join(base_directory, dir_name)
        # Get the directory size
        try:
            size_mb = get_dir_size(dir_path)
        except Exception as e:
            print(f"Error accessing {dir_path}: {e}")
            size_mb = 0  # Assume size is 0 if any error occurs
        folder_sizes.append(size_mb)
    
    # Add the folder sizes as a new column
    data['FolderSize (MB)'] = folder_sizes
    # Save the modified DataFrame to a new CSV file
    new_csv_path = csv_file_path.replace('.csv', '_SIMD_with_sizes.csv')
    data.to_csv(new_csv_path, index=False, sep='\t')
    print(f"Updated CSV saved to {new_csv_path}")

# Usage example:
save_folder = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Analysis\Rig_Recorder\Reconstruct\image_saver_test"

csv_file_path = save_folder + r"\average_durations.csv"
add_folder_sizes(save_folder, csv_file_path)



================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/video.py
================================================
import os
import pandas as pd
import matplotlib.pyplot as plt
import cv2
from datetime import datetime
import re
import concurrent.futures

image_format = 'webp'

def find_latest_camera_frames_dir(parent_dir):
    latest_time = None
    latest_dir = None

    for root, dirs, files in os.walk(parent_dir):
        if 'camera_frames' in dirs:
            dir_path = os.path.join(root, 'camera_frames')
            parent_dir_name = os.path.basename(root)

            try:
                dir_time = datetime.strptime(parent_dir_name, '%Y_%m_%d-%H_%M')
                if latest_time is None or dir_time > latest_time:
                    latest_time = dir_time
                    latest_dir = dir_path
            except ValueError:
                continue
    # print(f"Latest camera frames directory found: {latest_dir}")
    # print(f"Latest camera frames directory time: {latest_time}")
    # print(f"parent directory:{parent_dir_name}")
    # print(f"intended save directory:{root}")
    output_dir = latest_dir.split('camera_frames')[0] + 'output_videos'
    print(f"output directory:{output_dir}")
    return latest_dir, output_dir

def load_image(file):
    return cv2.imread(file)

def create_videos_from_directory(parent_directory):
    # Create output directory if it doesn't exist
    input_dir, output_dir = find_latest_camera_frames_dir(parent_directory)
    os.makedirs(output_dir, exist_ok=True)

    # Define the pattern to extract frame index and timestamp from file names
    pattern = re.compile(r'(\d+)_(\d+\.\d+)\.' + re.escape(image_format))

    # Find all tiff files in the directory and extract frame info
    frames = []
    image_files = []
    for filename in os.listdir(input_dir):
        match = pattern.match(filename)
        if match:
            frame_index = int(match.group(1))
            timestamp = float(match.group(2))
            frames.append((frame_index, timestamp, filename))

    # Sort frames and image files by timestamp
    frames.sort(key=lambda x: x[1])
    image_files = [os.path.join(input_dir, frame[2]) for frame in frames]
    print("Image files collected")

    # Load the images using multi-threading for faster performance
    with concurrent.futures.ThreadPoolExecutor() as executor:
        images = list(executor.map(load_image, image_files))
    print("Images loaded")

    # Define video names (initially without frame counts)
    video_name_variable_fps = os.path.join(output_dir, "output_video_variable_fps_temp.mp4")
    video_name_constant_fps = os.path.join(output_dir, "output_video_constant_fps_temp.mp4")

    # Base frame rate for the constant FPS video
    base_frame_rate = 30

    # Define the video writer
    height, width, _ = images[0].shape
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    print("Starting to write videos")

    print("starting to write variable fps video")
    # Video writer for variable FPS
    video_variable_fps = cv2.VideoWriter(video_name_variable_fps, fourcc, base_frame_rate, (width, height))

    # Determine the duration each frame should be displayed for variable FPS video
    durations = []
    previous_time = 0
    for frame in frames:
        current_time = frame[1]
        durations.append(current_time - previous_time)
        previous_time = current_time

    # Add frames to the variable FPS video
    variable_frame_count = 0
    for img, duration in zip(images, durations):
        frame_count = int(duration * base_frame_rate)
        if frame_count == 0:
            frame_count = 1  # Ensure at least one frame is written
        for _ in range(frame_count):
            video_variable_fps.write(img)
            variable_frame_count += 1

    # Release the video writer for variable FPS
    video_variable_fps.release()
    print(f"Variable FPS video saved with {variable_frame_count} frames")
    print("starting to write constant fps video")
    # Video writer for constant FPS
    video_constant_fps = cv2.VideoWriter(video_name_constant_fps, fourcc, base_frame_rate, (width, height))

    # Add frames to the constant FPS video (each frame is displayed for the same duration)
    constant_frame_count = len(images)
    for img in images:
        video_constant_fps.write(img)

    # Release the video writer for constant FPS
    video_constant_fps.release()
    print(f"Constant FPS video saved with {constant_frame_count} frames")

    # Define final video names with frame counts
    final_video_name_variable_fps = os.path.join(output_dir, f"output_video_variable_fps_{variable_frame_count}_frames.mp4")
    final_video_name_constant_fps = os.path.join(output_dir, f"output_video_constant_fps_{constant_frame_count}_frames.mp4")

    # Rename temporary files to final names
    os.rename(video_name_variable_fps, final_video_name_variable_fps)
    os.rename(video_name_constant_fps, final_video_name_constant_fps)

    print("Videos saved at:")
    print(final_video_name_variable_fps)
    print(final_video_name_constant_fps)

def process_images_and_plot(parent_directory, output_filename='framerate_plot_1.png'):
    input_dir, output_dir = find_latest_camera_frames_dir(parent_directory)
    os.makedirs(output_dir, exist_ok=True)
    # Use a generator to avoid loading all filenames into memory at once
    def get_file_names(directory):
        for filename in os.listdir(directory):
            if filename.endswith(f'.{image_format}'):
                yield filename
    
    # Extract frame numbers and timestamps from filenames using the generator
    frames_timestamps = [
        (int(name.split('_')[0]), float(name.split('_')[1].split(f'.{image_format}')[0]))
        for name in get_file_names(input_dir)
    ]
    
    # Convert to a DataFrame
    df = pd.DataFrame(frames_timestamps, columns=['frame', 'timestamp'])
    
    # Sort by frame number to ensure correct order
    df = df.sort_values(by='frame').reset_index(drop=True)
    
    # Calculate time intervals (differences between consecutive timestamps)
    df['time_interval'] = df['timestamp'].diff()
    
    # Calculate framerate (frames per second)
    df['framerate'] = 1 / df['time_interval']
    
    # Remove the first row as it will have NaN for time_interval and framerate
    df = df.dropna()
    
    # Calculate the average framerate
    average_framerate = df['framerate'].mean()

    # Calculate the running average of the framerate
    window_size = 20  # You can adjust the window size for the running average
    df['running_avg_framerate'] = df['framerate'].rolling(window=window_size).mean()

    # Calculate the cumulative average framerate
    df['cumulative_avg_framerate'] = df['framerate'].expanding().mean()

    # Plot framerate over cumulative time with horizontal lines at 60fps and 30fps
    plt.figure(figsize=(10, 6))
    plt.plot(df['timestamp'], df['framerate'], marker='o', label='Framerate')
    plt.plot(df['timestamp'], df['running_avg_framerate'], color='orange', linestyle='-', label='Running Average Framerate')
    plt.plot(df['timestamp'], df['cumulative_avg_framerate'], color='purple', linestyle='-', label='Cumulative Average Framerate')
    plt.axhline(y=60, color='r', linestyle='--', label='60 fps')
    plt.axhline(y=30, color='g', linestyle='--', label='30 fps')
    plt.axhline(y=average_framerate, color='b', linestyle='--', label=f'Overall Average Framerate: {average_framerate:.2f} fps')
    plt.title('Framerate Over Time with Horizontal Lines at 60fps, 30fps, and Average Framerates')
    plt.xlabel('Timestamp (s)')
    plt.ylabel('Framerate (frames per second)')
    plt.legend()
    plt.grid(True)
    
    # Save the plot to the output directory
    output_path = os.path.join(output_dir, output_filename)
    plt.savefig(output_path)
    plt.close()

    # Print the average framerate
    print(f'Overall Average Framerate: {average_framerate:.2f} fps')


# Example usage
input_directory = r'C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\TEST_rig_recorder_data'
# create_videos_from_directory(input_directory)
process_images_and_plot(input_directory)


# import os
# import pandas as pd
# import subprocess

# # # # # Directory containing the .tiff images
# # image_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\movement_frames"
# # image_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\camera_frames"
# # image_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\current_frames"
# image_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\resistance_frames"
# # image_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\pressure_frames"


# # Output video file directory
# # output_video_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\output_videos"
# # output_video_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\output_movement_videos"
# # output_video_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\output_current_videos"
# output_video_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\output_resistance_videos"
# # output_video_directory = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\output_pressure_videos"
# os.makedirs(output_video_directory, exist_ok=True)

# # # # # # Output video file
# # output_video = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\output_videos\output_video_variable_frame_rate.mp4"

# # Extract order numbers and timestamps from filenames, including the fractional part of the timestamp
# def get_order_number(filename):
#     return int(filename.split('_')[0])

# # Get all .tiff files in the directory and sort them by the order number
# uploaded_files = sorted([f for f in os.listdir(image_directory) if f.endswith('.tiff')],
#                         key=get_order_number)

# file_info = [{'filename': f, 'timestamp': float(f.split('_')[1].replace('.tiff', ''))} for f in uploaded_files]

# # Convert to DataFrame for easier manipulation
# df_files = pd.DataFrame(file_info)

# # Calculate time intervals between consecutive frames
# df_files['interval'] = df_files['timestamp'].diff().fillna(0)  # First frame interval set to 0

# # Calculate the number of frames and total duration
# num_frames = len(df_files)
# total_duration = df_files['interval'].sum()

# # Create the output filename with the number of frames and total duration
# output_filename = f"output_resistance_{num_frames}frames_{total_duration:.2f}seconds.mp4"
# output_video = os.path.join(output_video_directory, output_filename)

# # Define a minimum duration in seconds
# MIN_DURATION = 0.032

# # Write the image sequence with durations to a text file for FFmpeg
# input_list_path = os.path.join(image_directory, 'input_images.txt')
# with open(input_list_path, 'w') as f:
#     for idx, row in df_files.iterrows():
#         image_path = os.path.join(image_directory, row['filename'])
#         # Ensure the duration is at least the minimum duration
#         duration = max(row['interval'], MIN_DURATION)
#         # Format the duration to avoid scientific notation
#         formatted_duration = f"{duration:.5f}"
#         f.write(f"file '{image_path}'\n")
#         f.write(f"duration {formatted_duration}\n")

# # Add the last image again for FFmpeg to process it correctly
# last_image_path = os.path.join(image_directory, df_files.iloc[-1]['filename'])
# with open(input_list_path, 'a') as f:
#     f.write(f"file '{last_image_path}'\n")

# # Construct the ffmpeg command to create the variable fps video
# ffmpeg_command = [
#     'C:\\ffmpeg\\bin\\ffmpeg.exe', '-f', 'concat', '-safe', '0', '-i', input_list_path,
#     '-vsync', 'vfr', '-pix_fmt', 'yuv420p', output_video
# ]

# # Execute the ffmpeg command
# subprocess.run(ffmpeg_command)

# print(f"Variable FPS video created: {output_video}")


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/rig_viewer3D.py
================================================
import sys
import os
import csv
from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtWidgets import (
    QApplication, QLabel, QVBoxLayout, QWidget, QPushButton,
    QFileDialog, QShortcut, QHBoxLayout, QFrame, QSlider, QMessageBox, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QColor, QKeySequence
from PyQt5.QtCore import Qt, QTimer
import pyqtgraph as pg
import pyqtgraph.opengl as gl
import numpy as np
from collections import deque


def create_cylinder_mesh(radius=0.5, height=5.0, sectors=32):
    """
    Create vertices and faces for a cylinder.

    :param radius: Radius of the cylinder in cm.
    :param height: Height of the cylinder in cm.
    :param sectors: Number of sectors to approximate the circle.
    :return: vertices, faces
    """
    vertices = []
    faces = []

    # Bottom circle
    for i in range(sectors):
        angle = 2 * np.pi * i / sectors
        x = radius * np.cos(angle)
        y = radius * np.sin(angle)
        z = 0
        vertices.append([x, y, z])

    # Top circle
    for i in range(sectors):
        angle = 2 * np.pi * i / sectors
        x = radius * np.cos(angle)
        y = radius * np.sin(angle)
        z = height
        vertices.append([x, y, z])

    # Center points
    vertices.append([0, 0, 0])      # Bottom center
    vertices.append([0, 0, height]) # Top center

    bottom_center = len(vertices) - 2
    top_center = len(vertices) - 1

    # Side faces
    for i in range(sectors):
        next_i = (i + 1) % sectors
        # Bottom to top
        faces.append([i, next_i, sectors + next_i])
        faces.append([i, sectors + next_i, sectors + i])

    # Bottom faces
    for i in range(sectors):
        next_i = (i + 1) % sectors
        faces.append([bottom_center, next_i, i])

    # Top faces
    for i in range(sectors):
        next_i = (i + 1) % sectors
        faces.append([top_center, sectors + i, sectors + next_i])

    vertices = np.array(vertices)
    faces = np.array(faces)

    return vertices, faces


def create_box_mesh(width=5.0, depth=10.0, height=0.5):
    """
    Create vertices and faces for a rectangular prism.

    :param width: Width along the X-axis in cm.
    :param depth: Depth along the Y-axis in cm.
    :param height: Height along the Z-axis in cm.
    :return: vertices, faces
    """
    w = width / 2
    d = depth / 2
    h = height

    vertices = np.array([
        [-w, -d, 0],  # 0: Bottom Front Left
        [w, -d, 0],   # 1: Bottom Front Right
        [w, d, 0],    # 2: Bottom Back Right
        [-w, d, 0],   # 3: Bottom Back Left
        [-w, -d, h],  # 4: Top Front Left
        [w, -d, h],   # 5: Top Front Right
        [w, d, h],    # 6: Top Back Right
        [-w, d, h],   # 7: Top Back Left
    ])

    faces = np.array([
        [0, 1, 2], [0, 2, 3],  # Bottom
        [4, 5, 6], [4, 6, 7],  # Top
        [0, 1, 5], [0, 5, 4],  # Front
        [1, 2, 6], [1, 6, 5],  # Right
        [2, 3, 7], [2, 7, 6],  # Back
        [3, 0, 4], [3, 4, 7],  # Left
    ])

    return vertices, faces


def create_sphere_mesh(radius=0.5, sectors=32, stacks=16):
    """
    Create vertices and faces for a sphere.

    :param radius: Radius of the sphere in cm.
    :param sectors: Number of sectors (longitude divisions).
    :param stacks: Number of stacks (latitude divisions).
    :return: vertices, faces
    """
    vertices = []
    faces = []

    for stack in range(stacks + 1):
        phi = np.pi / 2 - stack * np.pi / stacks  # from pi/2 to -pi/2
        y = radius * np.sin(phi)
        r = radius * np.cos(phi)

        for sector in range(sectors + 1):
            theta = 2 * np.pi * sector / sectors
            x = r * np.cos(theta)
            z = r * np.sin(theta)
            vertices.append([x, y, z])

    for stack in range(stacks):
        for sector in range(sectors):
            first = stack * (sectors + 1) + sector
            second = first + sectors + 1

            faces.append([first, second, first + 1])
            faces.append([second, second + 1, first + 1])

    vertices = np.array(vertices)
    faces = np.array(faces)

    return vertices, faces


class GLViewWidgetWithGrid(gl.GLViewWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setBackgroundColor('k')  # Set background to black

        # Set initial isometric view
        self.restore_isometric_view()

        # Add grid to XY plane
        self.add_grid()

        # Add XYZ axes
        self.add_axes()

        # Initialize objects
        self.init_objects()

    def add_grid(self):
        # Create grid lines on the XY plane with millimeter squares
        grid_size = 100  # Define the extent of the grid (100 mm in each direction)
        step = 1  # 1 mm squares

        # Create lines parallel to X-axis
        for y in np.arange(-grid_size, grid_size + step, step):
            pts = np.array([[-grid_size, y, 0], [grid_size, y, 0]])
            plt = gl.GLLinePlotItem(pos=pts, color=(1, 1, 1, 1), width=1, antialias=True)
            self.addItem(plt)

        # Create lines parallel to Y-axis
        for x in np.arange(-grid_size, grid_size + step, step):
            pts = np.array([[x, -grid_size, 0], [x, grid_size, 0]])
            plt = gl.GLLinePlotItem(pos=pts, color=(1, 1, 1, 1), width=1, antialias=True)
            self.addItem(plt)

    def add_axes(self):
        # Define axis length
        axis_length = 50  # 50 mm

        # X-axis (Red)
        x_axis = gl.GLLinePlotItem(pos=np.array([[0, 0, 0], [axis_length, 0, 0]]),
                                   color=(1, 0, 0, 1), width=2, antialias=True)
        self.addItem(x_axis)

        # Y-axis (Green)
        y_axis = gl.GLLinePlotItem(pos=np.array([[0, 0, 0], [0, axis_length, 0]]),
                                   color=(0, 1, 0, 1), width=2, antialias=True)
        self.addItem(y_axis)

        # Z-axis (Blue)
        z_axis = gl.GLLinePlotItem(pos=np.array([[0, 0, 0], [0, 0, axis_length]]),
                                   color=(0, 0, 1, 1), width=2, antialias=True)
        self.addItem(z_axis)

    def restore_isometric_view(self):
        # Set camera elevation and azimuth for isometric view
        self.opts['azimuth'] = 45  # Rotate 45 degrees around Z-axis
        self.opts['elevation'] = 30  # Tilt 30 degrees from horizontal
        self.update()

    def init_objects(self):
        # Create Microscope as a cylinder
        cyl_vertices, cyl_faces = create_cylinder_mesh(radius=0.5, height=5.0, sectors=32)
        self.microscope_mesh = gl.GLMeshItem(vertexes=cyl_vertices, faces=cyl_faces,
                                            smooth=True, color=(1, 0, 0, 1), shader='shaded', drawEdges=False)
        self.addItem(self.microscope_mesh)

        # Create Stage as a box (rectangular prism)
        box_vertices, box_faces = create_box_mesh(width=5.0, depth=10.0, height=0.5)
        self.stage_mesh = gl.GLMeshItem(vertexes=box_vertices, faces=box_faces,
                                       smooth=False, color=(0, 1, 0, 1), shader='shaded', drawEdges=False)
        self.addItem(self.stage_mesh)

        # Create Pipette as a sphere
        sphere_vertices, sphere_faces = create_sphere_mesh(radius=0.5, sectors=32, stacks=16)
        self.pipette_mesh = gl.GLMeshItem(vertexes=sphere_vertices, faces=sphere_faces,
                                         smooth=True, color=(0, 0, 1, 1), shader='shaded', drawEdges=False)
        self.addItem(self.pipette_mesh)

    def update_objects(self, microscope_z, stage_pos, pipette_pos):
        """
        Update the positions of Stage and Pipette.

        :param microscope_z: Z-coordinate for Microscope (fixed X and Y at 0).
        :param stage_pos: (x, y) position for Stage in the XY-plane.
        :param pipette_pos: (x, y, z) position for Pipette.
        """
        # Update Microscope position (fixed X and Y, variable Z)
        self.microscope_mesh.resetTransform()
        self.microscope_mesh.translate(0, 0, microscope_z)

        # Update Stage position (only in XY-plane, Z is fixed at 0)
        self.stage_mesh.resetTransform()
        self.stage_mesh.translate(stage_pos[0], stage_pos[1], 0)

        # Update Pipette position (in XYZ)
        self.pipette_mesh.resetTransform()
        self.pipette_mesh.translate(pipette_pos[0], pipette_pos[1], pipette_pos[2])


class MainWindow(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('3D Movement Data Visualization')
        self.resize(1200, 900)  # Adjusted size for better visibility

        # Define scaling factor (micrometers to millimeters)
        self.scaling_factor = 1 / 1000  # 1 mm = 1,000 µm

        # Create main layout
        main_layout = QtWidgets.QVBoxLayout()
        self.setLayout(main_layout)

        # Create OpenGL view widget
        self.view = GLViewWidgetWithGrid()
        main_layout.addWidget(self.view, stretch=8)  # Allocate most space to 3D view

        # Create control panel layout
        control_panel = QFrame()
        control_panel.setFrameShape(QFrame.StyledPanel)
        control_panel.setFrameShadow(QFrame.Sunken)
        control_panel.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        control_layout = QVBoxLayout()
        control_layout.setContentsMargins(10, 10, 10, 10)
        control_layout.setSpacing(10)
        control_panel.setLayout(control_layout)
        main_layout.addWidget(control_panel, stretch=2)  # Allocate less space

        # Information Pane
        self.info = QLabel("No data loaded.")
        self.info.setStyleSheet("color: white;")
        self.info.setWordWrap(True)
        self.info.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        control_layout.addWidget(self.info)

        # Timeline Slider
        self.slider = QSlider(Qt.Horizontal)
        self.slider.setMaximumHeight(30)
        self.slider.setTickPosition(QSlider.NoTicks)
        self.slider.valueChanged.connect(self.slider_changed)
        self.slider.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        control_layout.addWidget(self.slider)

        # Buttons Layout
        buttons_layout = QHBoxLayout()
        control_layout.addLayout(buttons_layout)

        # Load Data Button
        self.load_data_button = QPushButton("Load Movement Data")
        self.load_data_button.clicked.connect(self.load_movement_data)
        buttons_layout.addWidget(self.load_data_button)

        # Previous Button
        self.prev_button = QPushButton("Previous")
        self.prev_button.clicked.connect(self.show_previous_timepoint)
        buttons_layout.addWidget(self.prev_button)

        # Play/Pause Button
        self.play_button = QPushButton("Play")
        self.play_button.clicked.connect(self.toggle_playback)
        buttons_layout.addWidget(self.play_button)

        # Next Button
        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.show_next_timepoint)
        buttons_layout.addWidget(self.next_button)

        # Restore View Button
        self.restore_view_button = QPushButton("Restore Isometric View")
        self.restore_view_button.clicked.connect(self.view.restore_isometric_view)
        buttons_layout.addWidget(self.restore_view_button)

        # Spacer to push buttons to the left
        buttons_layout.addStretch()

        # Set background color for control panel
        control_panel.setStyleSheet("""
            QFrame {
                background-color: #2e2e2e;
            }
            QPushButton {
                background-color: #4a4a4a;
                color: white;
                border: 1px solid #5a5a5a;
                padding: 5px 10px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
            QSlider::groove:horizontal {
                height: 8px;
                background: #4a4a4a;
                border: 1px solid #5a5a5a;
                border-radius: 4px;
            }
            QSlider::handle:horizontal {
                background: #ffffff;
                border: 1px solid #5a5a5a;
                width: 14px;
                margin: -3px 0;
                border-radius: 7px;
            }
        """)

        # Set overall background to dark gray
        self.setStyleSheet("""
            QWidget {
                background-color: #2e2e2e;
                color: white;
            }
        """)

        # Initialize variables
        self.movement_data = []
        self.current_index = 0
        self.timer = QTimer()
        self.timer.setInterval(33)  # ~30 FPS
        self.timer.timeout.connect(self.advance_timepoint)
        self.is_playing = False

        # Keyboard Shortcuts
        self.shortcut_prev = QShortcut(QKeySequence(Qt.Key_Left), self)
        self.shortcut_prev.activated.connect(self.show_previous_timepoint)

        self.shortcut_next = QShortcut(QKeySequence(Qt.Key_Right), self)
        self.shortcut_next.activated.connect(self.show_next_timepoint)

    def load_movement_data(self):
        # Open file dialog to select CSV file
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Movement Data CSV", "",
                                                   "CSV Files (*.csv);;All Files (*)", options=options)
        if file_path:
            try:
                with open(file_path, mode='r') as file:
                    reader = csv.reader(file, delimiter=' ')
                    self.movement_data = []
                    for line in reader:
                        # Split by spaces and filter out empty strings
                        parts = [part for part in line if part]

                        if len(parts) < 7:
                            continue  # Skip invalid lines

                        try:
                            time_value = float(parts[0].split(':')[1])
                            st_x = float(parts[1].split(':')[1]) * self.scaling_factor
                            st_y = float(parts[2].split(':')[1]) * self.scaling_factor
                            st_z = float(parts[3].split(':')[1]) * self.scaling_factor  # Microscope Z
                            pi_x = float(parts[4].split(':')[1]) * self.scaling_factor
                            pi_y = float(parts[5].split(':')[1]) * self.scaling_factor
                            pi_z = float(parts[6].split(':')[1]) * self.scaling_factor

                            self.movement_data.append({
                                'time': time_value,
                                'microscope_z': -(st_z),       # Correctly map to microscope_z
                                'stage': (-st_x, -st_y),      # Only X and Y for stage
                                'pipette': (-pi_x, -pi_y, -(pi_z - 1.365))
                            })
                        except (IndexError, ValueError):
                            continue  # Skip lines with parsing errors

                if not self.movement_data:
                    QMessageBox.warning(self, "No Data", "No valid movement data found in the selected file.")
                    return

                # Zero the time by subtracting the first timestamp
                initial_time = self.movement_data[0]['time']
                for entry in self.movement_data:
                    entry['time'] -= initial_time

                self.current_index = 0
                self.slider.setMinimum(0)
                self.slider.setMaximum(len(self.movement_data) - 1)
                self.slider.setValue(self.current_index)

                self.update_view()

                self.info.setText(f"Loaded {len(self.movement_data)} movement entries.")

            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to load movement data:\n{e}")

    def show_previous_timepoint(self):
        if not self.movement_data:
            QMessageBox.warning(self, "No Data", "Please load movement data first.")
            return

        if self.current_index > 0:
            self.current_index -= 1
            self.slider.setValue(self.current_index)
            self.update_view()

    def show_next_timepoint(self):
        if not self.movement_data:
            QMessageBox.warning(self, "No Data", "Please load movement data first.")
            return

        if self.current_index < len(self.movement_data) - 1:
            self.current_index += 1
            self.slider.setValue(self.current_index)
            self.update_view()

    def toggle_playback(self):
        if not self.movement_data:
            QMessageBox.warning(self, "No Data", "Please load movement data first.")
            return

        if self.is_playing:
            self.timer.stop()
            self.play_button.setText("Play")
            self.is_playing = False
        else:
            self.timer.start()
            self.play_button.setText("Pause")
            self.is_playing = True

    def advance_timepoint(self):
        if not self.movement_data:
            return

        current_time = self.movement_data[self.current_index]['time']
        new_time = current_time + self.timer.interval() / 1000.0  # Convert ms to seconds

        # Find the next index with time >= new_time
        new_index = self.current_index
        while new_index < len(self.movement_data) and self.movement_data[new_index]['time'] < new_time:
            new_index += 1

        if new_index < len(self.movement_data):
            self.current_index = new_index
            self.slider.setValue(self.current_index)
            self.update_view()
        else:
            self.timer.stop()
            self.play_button.setText("Play")
            self.is_playing = False

    def slider_changed(self, value):
        if not self.movement_data:
            return

        self.current_index = value
        self.update_view()

    def update_view(self):
        if not self.movement_data:
            return

        data = self.movement_data[self.current_index]
        time = data['time']
        microscope_z = data['microscope_z']
        stage_x, stage_y = data['stage']
        pi_x, pi_y, pi_z = data['pipette']

        # Stage moves only in XY plane; Z is fixed at 0
        stage_pos = (stage_x, stage_y)

        # Pipette moves freely in XYZ
        pipette_pos = (pi_x, pi_y, pi_z)

        # Update objects in the 3D viewer
        self.view.update_objects(microscope_z, stage_pos, pipette_pos)

        # Update information pane with both millimeters and micrometers
        time_text = f"Time: {time:.2f} s"
        stage_mm = stage_pos
        pipette_mm = pipette_pos
        stage_um = tuple([coord * 1000 for coord in stage_mm])  # mm to µm
        pipette_um = tuple([coord * 1000 for coord in pipette_mm])  # mm to µm

        stage_text = f"Stage Position: (X: {stage_mm[0]:.3f} mm / {stage_um[0]:.2f} µm, " \
                     f"Y: {stage_mm[1]:.3f} mm / {stage_um[1]:.2f} µm, " \
                     f"Z: 0.000 mm / 0.00 µm)"
        pipette_text = f"Pipette Position: (X: {pipette_mm[0]:.3f} mm / {pipette_um[0]:.2f} µm, " \
                       f"Y: {pipette_mm[1]:.3f} mm / {pipette_um[1]:.2f} µm, " \
                       f"Z: {pipette_mm[2]:.3f} mm / {pipette_um[2]:.2f} µm)"
        self.info.setText(f"{time_text}\n{stage_text}\n{pipette_text}")


def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    main()


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/movement.py
================================================

import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import os

def extract_data_and_plot(file_path, output_path):
    #create output path if it doesn't exist
    if not os.path.exists(output_path):
            os.makedirs(output_path)
    print("Writing to:", output_path)

    
    # Load and preprocess the data
    with open(file_path, 'r') as file:
        lines = file.readlines()
    
    data = []
    for line in lines:
        line_data = {}
        try:
            parts = line.split()
            line_data['timestamp'] = float(parts[0].split(":")[1])
            line_data['st_x'] = float(parts[1].split(":")[1])
            line_data['st_y'] = float(parts[2].split(":")[1])
            line_data['st_z'] = float(parts[3].split(":")[1])
            line_data['pi_x'] = float(parts[4].split(":")[1])
            line_data['pi_y'] = float(parts[5].split(":")[1])
            line_data['pi_z'] = float(parts[6].split(":")[1])
            data.append(line_data)
        except (ValueError, IndexError) as e:
            print(f"Error parsing line: {line} - {e}")

    df = pd.DataFrame(data)
    
    # Determine axis limits and ensure they are not identical
    def adjust_limits(min_val, max_val, epsilon=1e-6):
        if min_val == max_val:
            min_val -= epsilon
            max_val += epsilon
        return min_val, max_val

    x_min, x_max = adjust_limits(df['st_x'].min(), df['st_x'].max())
    y_min, y_max = adjust_limits(df['st_y'].min(), df['st_y'].max())
    z_min, z_max = adjust_limits(df['st_z'].min(), df['st_z'].max())
    pi_x_min, pi_x_max = adjust_limits(df['pi_x'].min(), df['pi_x'].max())
    pi_y_min, pi_y_max = adjust_limits(df['pi_y'].min(), df['pi_y'].max())
    pi_z_min, pi_z_max = adjust_limits(df['pi_z'].min(), df['pi_z'].max())

    x_min, x_max = min(x_min, pi_x_min), max(x_max, pi_x_max)
    y_min, y_max = min(y_min, pi_y_min), max(y_max, pi_y_max)
    z_min, z_max = min(z_min, pi_z_min), max(z_max, pi_z_max)

    # Prepare plots in batches
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_xlim(x_min, x_max)
    ax.set_ylim(y_min, y_max)
    ax.set_zlim(z_min, z_max)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')

    print("Second pass to plot data")
    prev_timestamp = None

    for i, row in df.iterrows():
        timestamp = row['timestamp']
        if prev_timestamp and (timestamp - prev_timestamp) < 0.032:
            continue
        
        ax.cla()  # Clear the previous scatter points but keep axis limits and labels
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)
        ax.set_zlim(z_min, z_max)
        
        ax.scatter(row['st_x'], row['st_y'], row['st_z'], c='r', label='ST')  # Red for ST
        ax.scatter(row['pi_x'], row['pi_y'], row['pi_z'], c='b', label='PI')  # Blue for PI
        
        ax.set_title(f'Position Plot at {timestamp}')
        ax.legend()
        
        filename = f'{i}_{timestamp}.webp'
        #create output path if it doesn't exist
        if not os.path.exists(output_path):
            os.makedirs(output_path)

        plt.savefig(f'{output_path}/{filename}')
        
        prev_timestamp = timestamp

    plt.close(fig)
    print("Done writing to:", output_path)


# Example usage:
file_path =r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\movement_recording.csv"
output_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\movement_frames"
extract_data_and_plot(file_path, output_path)


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/rig_replay3D.ipynb
================================================
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "823d0e59",
   "metadata": {},
   "source": [
    "# RigReplay Application Overview\n",
    "\n",
    "This application allows users to load data from a directory containing images and movement/graph data. The UI is built with PyQt and integrates both 2D graphs and 3D visualizations of movement data. Users can navigate through timepoints using a slider, view image frames alongside the graphs, and switch between 2D and 3D views."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "853b4e95",
   "metadata": {},
   "source": [
    "# Table of Contents\n",
    "\n",
    "1. [Loading Data into the Application](#Loading-Data-into-the-Application)\n",
    "2. [Navigating Through Timepoints](#Navigating-Through-Timepoints)\n",
    "3. [Understanding 2D Graphs](#Understanding-2D-Graphs)\n",
    "4. [Switching Between 2D and 3D Views](#Switching-Between-2D-and-3D-Views)\n",
    "5. [Using Playback Controls](#Using-Playback-Controls)\n",
    "6. [Displaying Images in the UI](#Displaying-Images-in-the-UI)\n",
    "7. [Required Packages and Environment Setup](#Required-Packages-and-Environment-Setup)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c7b53fb9",
   "metadata": {},
   "source": [
    "## 1. Loading Data into the Application\n",
    "\n",
    "To load a dataset, follow these steps:\n",
    "1. Open the application.\n",
    "2. Click the `Select Data Directory` button located in the control panel at the bottom of the UI.\n",
    "3. Choose a directory that contains the following files:\n",
    "   - `camera_frames` folder with images (in `.webp` format).\n",
    "   - `movement_recording.csv` file for movement data.\n",
    "   - `graph_recording.csv` file for graph data.\n",
    "\n",
    "Once the directory is selected, the application will automatically load the data, initialize the timeline, and display the first image frame."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "29378413",
   "metadata": {},
   "source": [
    "## 2. Navigating Through Timepoints\n",
    "\n",
    "The timeline slider at the bottom of the UI allows you to move through different timepoints:\n",
    "1. Move the slider left or right to adjust the current timepoint.\n",
    "2. Use the `Previous Timepoint` and `Next Timepoint` buttons to step backward or forward through the data.\n",
    "3. Press the `Play` button to automatically advance through timepoints at a 30fps playback rate.\n",
    "\n",
    "The information panel updates with the current stage and pipette positions, as well as the current image frame."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "49bd3258",
   "metadata": {},
   "source": [
    "## 3. Understanding 2D Graphs\n",
    "\n",
    "The application displays 2D graphs representing data such as Voltage, Current, Pressure, and Resistance:\n",
    "- **Voltage Plot**: Shows voltage data over time (in volts).\n",
    "- **Current Plot**: Displays current data (in amperes).\n",
    "- **Pressure Plot**: Graphs the pressure (in mBAR).\n",
    "- **Resistance Plot**: Plots resistance (in Ohms).\n",
    "\n",
    "The graphs automatically update as you move through timepoints with the slider or play/pause functionality."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "403c89ac",
   "metadata": {},
   "source": [
    "## 4. Switching Between 2D and 3D Views\n",
    "\n",
    "The application includes a 3D visualization of the stage, microscope, and pipette movements. To switch between 2D and 3D views:\n",
    "1. Click the `Switch to 3D View` button to toggle between the graphs and the 3D visualization.\n",
    "2. In the 3D view, the stage, microscope, and pipette movements are displayed based on the loaded movement data.\n",
    "\n",
    "You can switch back to the 2D graphs by clicking the same button."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "df1b8a5f",
   "metadata": {},
   "source": [
    "## 5. Using Playback Controls\n",
    "\n",
    "The playback controls allow for automated timepoint navigation:\n",
    "1. **Play/Pause**: Toggles between playing through timepoints and pausing. While playing, the slider moves automatically.\n",
    "2. **Previous/Next Timepoint**: Manually step backward or forward through the timeline.\n",
    "\n",
    "These controls help visualize the data frame by frame or in real-time."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7ba2a65d",
   "metadata": {},
   "source": [
    "## 6. Displaying Images in the UI\n",
    "\n",
    "Once the data is loaded, the images are displayed in the left pane of the UI. The images are from the `camera_frames` folder and are updated as the slider or timepoint changes."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "621cfe74",
   "metadata": {},
   "source": [
    "## 7. Required Packages and Environment Setup\n",
    "\n",
    "To run the `IntegratedTimeline` application, you need to ensure that the required packages are installed. Below is a guide for setting up a `conda` environment with Python 3.11.\n",
    "\n",
    "### Step 1: Conda Environment Setup\n",
    "\n",
    "1. **Install Anaconda or Miniconda** (if not already installed).\n",
    "   - You can download Anaconda from [here](https://www.anaconda.com/products/distribution).\n",
    "   - Alternatively, Miniconda is a lightweight version that you can download [here](https://docs.conda.io/en/latest/miniconda.html).\n",
    "\n",
    "2. **Create a Conda Environment**:\n",
    "   Open a terminal or command prompt and create a new environment using the following command:\n",
    "   ```bash\n",
    "   conda create -n IntegratedTimeline python=3.11\n",
    "   ```\n",
    "\n",
    "3. **Activate the Environment**:\n",
    "   After the environment is created, activate it:\n",
    "   ```bash\n",
    "   conda activate IntegratedTimeline\n",
    "   ```\n",
    "\n",
    "### Step 2: Installing Required Packages\n",
    "\n",
    "Once the environment is activated, you need to install the required Python packages. Here’s the list of required packages for this project:\n",
    "\n",
    "- `pyqtgraph`\n",
    "- `PyQt5`\n",
    "- `PyOpenGL`\n",
    "- `numpy`\n",
    "\n",
    "To install these, use the following commands:\n",
    "\n",
    "```bash\n",
    "# Install PyQt5 and pyqtgraph for the UI and plotting\n",
    "conda install pyqt=5 pyqtgraph\n",
    "\n",
    "# Install PyOpenGL for 3D visualization\n",
    "pip install PyOpenGL PyOpenGL_accelerate\n",
    "\n",
    "# Install NumPy for array manipulation\n",
    "conda install numpy\n",
    "```\n",
    "\n",
    "### Step 3: Install Any Additional Dependencies\n",
    "\n",
    "If you encounter any issues, ensure that the following packages are installed as well:\n",
    "\n",
    "```bash\n",
    "conda install pillow  # For handling image files\n",
    "conda install matplotlib  # For additional plotting options\n",
    "```\n",
    "\n",
    "### Step 4: YAML File for Reproducibility\n",
    "\n",
    "For ease of setup, you can also create the environment from a `YAML` file. Here’s an example `environment.yaml`:\n",
    "\n",
    "```yaml\n",
    "name: IntegratedTimeline\n",
    "channels:\n",
    "  - defaults\n",
    "dependencies:\n",
    "  - python=3.11\n",
    "  - pyqt=5\n",
    "  - pyqtgraph\n",
    "  - numpy\n",
    "  - pip\n",
    "  - pip:\n",
    "    - PyOpenGL\n",
    "    - PyOpenGL_accelerate\n",
    "```\n",
    "\n",
    "To create an environment from this file, save it as `environment.yaml` and run:\n",
    "```bash\n",
    "conda env create -f environment.yaml\n",
    "```\n",
    "\n",
    "### Step 5: Running the Application\n",
    "\n",
    "Once the environment is set up and the required packages are installed, you can run the application by executing the Python script:\n",
    "```bash\n",
    "python rig_replay3D.py\n",
    "```"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/pressure.py
================================================

import csv
import matplotlib.pyplot as plt
from collections import deque
from datetime import datetime
import os

def extract_data_and_plot(file_path, output_path):
    if not os.path.exists(output_path):
            os.makedirs(output_path)
    print("Writing to:", output_path)
    i = 0
    previous_timestamp = None
    pressure_vals = deque(maxlen=100)

    with open(file_path, newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            joined_row = ''.join(row)
            timestamp_str = joined_row.split("pressure:")[0].replace("timestamp:", "").strip()
            joined_row = joined_row.split('pressure:')[1]
            pressure_val = joined_row.split('resistance', 1)[0]
            
            # Convert timestamp to float (UNIX timestamp)
            current_timestamp = float(timestamp_str)
            
            # Check if the difference between timestamps is less than 0.032 seconds
            if previous_timestamp and (current_timestamp - previous_timestamp) < 0.032:
                continue

            pressure_vals.append(float(pressure_val))
            indices = list(range(len(pressure_vals)))
            filename = f'{i}_{timestamp_str}.webp'
            
            # Plotting
            plt.figure()
            plt.plot(indices, list(pressure_vals))
            plt.xlabel('Index')
            plt.ylabel('Pressure')
            plt.title('Pressure Plot')
            plt.savefig(f'{output_path}/{filename}')
            plt.close()
            
            # Update the previous timestamp
            previous_timestamp = current_timestamp
            i += 1

    print("Done writing to:", output_path)

file_path =r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\graph_recording.csv"
output_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\pressure_frames"
extract_data_and_plot(file_path, output_path)








================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/rig_replay.py
================================================
import sys
import os
import csv
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget, QPushButton,
    QFileDialog, QShortcut, QHBoxLayout, QFrame, QSlider, QMessageBox, QSizePolicy, QSpacerItem
)
from PyQt5.QtGui import QPixmap, QColor
from PyQt5.QtCore import Qt, QTimer
import pyqtgraph as pg
from collections import deque

class Timeline(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Timeline")
        self.setGeometry(50, 50, 1600, 800)  # Initial size; will be resizable

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)

        self.main_layout = QVBoxLayout(self.central_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)  # Add some padding
        self.main_layout.setSpacing(10)  # Add spacing between elements

        # Horizontal layout for image and graph
        self.top_layout = QHBoxLayout()
        self.top_layout.setSpacing(10)  # Spacing between image and graph

        # Set up the image label and frame
        self.image = QLabel("No Image loaded yet!")
        self.image.setAlignment(Qt.AlignCenter)
        self.image.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Allow expanding

        self.image_frame = QFrame()
        frame_layout = QVBoxLayout(self.image_frame)
        frame_layout.addWidget(self.image)
        self.image_frame.setFrameShape(QFrame.StyledPanel)
        self.image_frame.setFrameShadow(QFrame.Sunken)
        self.image_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Allow expanding

        # Configure pyqtgraph
        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')

        # Add graph frame next to the image with 2x2 grid of graphs
        self.graph_frame = QFrame()
        self.graph_frame.setFrameShape(QFrame.StyledPanel)
        self.graph_frame.setFrameShadow(QFrame.Sunken)
        self.graph_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Allow expanding
        self.graph_frame.setMinimumSize(600, 400)  # Set minimum size for graph_frame

        # Create a layout to hold the 2x2 graphs
        self.graph_layout = QVBoxLayout(self.graph_frame)
        self.graph_layout.setContentsMargins(5, 5, 5, 5)
        self.graph_layout.setSpacing(5)

        # Create the GraphicsLayoutWidget for plotting
        self.graphics_layout = pg.GraphicsLayoutWidget()
        self.graphics_layout.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.graph_layout.addWidget(self.graphics_layout)

        # Create 2x2 grid of plots
        self.plots = [
            self.graphics_layout.addPlot(row=0, col=0),
            self.graphics_layout.addPlot(row=0, col=1),
            self.graphics_layout.addPlot(row=1, col=0),
            self.graphics_layout.addPlot(row=1, col=1)
        ]
        self.plots[0].setTitle("Voltage 1")
        self.plots[0].setLabels(left='Voltage (V)', bottom='Time (s)')
        self.plots[1].setTitle("Current 2")
        self.plots[1].setLabels(left='Current (A)', bottom='Time (s)')
        self.plots[2].setTitle("Pressure 3")
        self.plots[2].setLabels(left='Pressure (mBAR)', bottom='Time (s)')
        self.plots[3].setTitle("Resistance 4")
        self.plots[3].setLabels(left='Resistance (Ohm)', bottom='Time (s)')

        # Add image and graph frames to the top layout with stretch factors
        self.top_layout.addWidget(self.image_frame, stretch=1)  # Image takes 1 part
        self.top_layout.addWidget(self.graph_frame, stretch=1)  # Graphs take 1 part

        # Add the top layout to the main layout
        self.main_layout.addLayout(self.top_layout, stretch=8)  # Allocate most space to top_layout

        # Set up Timeline Scrubber
        self.slider = QSlider(Qt.Horizontal)
        self.slider.setMaximumHeight(30)  # Slightly increased height for better visibility
        self.slider.setTickPosition(QSlider.NoTicks)  # Remove tick marks
        self.slider.valueChanged.connect(self.slider_changed)
        self.slider.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)  # Expand horizontally

        self.slider_frame = QFrame()
        slider_frame_layout = QHBoxLayout(self.slider_frame)
        slider_frame_layout.setContentsMargins(0, 0, 0, 0)
        slider_frame_layout.addWidget(self.slider)
        self.slider_frame.setFrameShape(QFrame.StyledPanel)
        self.slider_frame.setFrameShadow(QFrame.Sunken)
        self.slider_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.main_layout.addWidget(self.slider_frame, stretch=1)  # Allocate less space

        # Create the QLabel to show info text
        self.info = QLabel("No info yet!")
        self.info.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self.info.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)  # Expand horizontally

        self.middle_layout = QVBoxLayout()
        self.middle_layout.setSpacing(5)

        # Create a frame to hold the info label and buttons
        self.info_frame = QFrame()
        info_frame_layout = QHBoxLayout(self.info_frame)
        info_frame_layout.setContentsMargins(5, 5, 5, 5)
        info_frame_layout.setSpacing(10)

        # Add the info label to the left
        info_frame_layout.addWidget(self.info, stretch=1)

        # Create a horizontal layout for buttons aligned to the right
        self.buttons_layout = QHBoxLayout()
        self.buttons_layout.setSpacing(10)

        # Buttons in desired order
        self.prev_image_button = QPushButton("Previous timepoint")
        self.prev_image_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.prev_image_button.clicked.connect(self.show_previous_timepoint)
        self.buttons_layout.addWidget(self.prev_image_button)

        self.select_image_dir_button = QPushButton("Select Data Directory")
        self.select_image_dir_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.select_image_dir_button.clicked.connect(self.open_directory)
        self.buttons_layout.addWidget(self.select_image_dir_button)

        self.next_image_button = QPushButton("Next timepoint")
        self.next_image_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.next_image_button.clicked.connect(self.show_next_timepoint)
        self.buttons_layout.addWidget(self.next_image_button)

        self.toggle_video_button = QPushButton("Play")
        self.toggle_video_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.toggle_video_button.clicked.connect(self.toggle_video)
        self.buttons_layout.addWidget(self.toggle_video_button)

        # Add a spacer to push buttons to the right
        self.buttons_layout.addStretch()

        # Add the buttons layout to the info_frame layout
        info_frame_layout.addLayout(self.buttons_layout)

        # Add the info_frame to the middle layout
        self.middle_layout.addWidget(self.info_frame)

        # Add the middle layout to the main layout
        self.main_layout.addLayout(self.middle_layout, stretch=1)  # Allocate less space

        # Initialize required variables
        self.image_paths = []
        self.image_index = []
        self.timestamps = []
        self.first_index = 0
        self.last_index = 0
        self.current_index = 0
        self.first_timestamp = 0
        self.last_timestamp = 0
        self.current_timestamp = 0
        self.duration = 0
        self.movement_data = []
        self.graph_data = []
        self.directory = None
        self.pressure_deque = deque(maxlen=100)  # Add 100 values to the deque
        self.resistance_deque = deque(maxlen=100)  # Add 100 values to the deque
        self.direction = 1

        self.timer = QTimer()
        self.interval = 33 / 1000  # 33ms for ~30 frames per second
        self.timer.setInterval(33)  # 33ms for ~30 frames per second
        self.timer.timeout.connect(self.advance_timepoint)

        # Keyboard shortcuts
        self.shortcut_left = QShortcut(Qt.Key_Left, self)
        self.shortcut_left.activated.connect(self.show_previous_timepoint)
        self.shortcut_right = QShortcut(Qt.Key_Right, self)
        self.shortcut_right.activated.connect(self.show_next_timepoint)

    def toggle_video(self):
        """Toggle play/pause functionality"""
        if not self.check_data_loaded():
            return  # Only proceed if data is loaded
        if self.timer.isActive():
            self.toggle_video_button.setText("Play")  # Update button to show "Play"
            self.timer.stop()
        else:
            self.toggle_video_button.setText("Pause")  # Update button to show "Pause"
            self.timer.start()

    def advance_timepoint(self):
        """Advance to the next time point"""
        if not self.check_data_loaded():
            return

        timepoint = self.timestamps[self.current_index]
        new_timepoint = timepoint + self.interval

        # Find the next closest timestamp
        new_index = next((i for i, t in enumerate(self.timestamps) if t >= new_timepoint), None)

        if new_index is not None:
            self.current_index = new_index
            self.slider.setValue(self.current_index)
            self.update_view()

    def open_directory(self):
        self.directory = QFileDialog.getExistingDirectory(self, "Open Directory", "")
        if self.directory:
            camera_frames_dir = os.path.join(self.directory, 'camera_frames')
            movement_file_path = os.path.join(self.directory, 'movement_recording.csv')
            graph_file_path = os.path.join(self.directory, 'graph_recording.csv')
            self.info.setText(f"Loading data from {self.directory}")
            if os.path.exists(camera_frames_dir):
                self.load_images_from_directory(camera_frames_dir)
            else:
                self.image.setText("No camera_frames directory found in the selected folder.")
            if os.path.exists(movement_file_path):
                self.load_movement_data(movement_file_path)
            else:
                QMessageBox.warning(self, "No Movement Data Found", "The selected directory does not contain a valid movement_recording.csv file.")
            if os.path.exists(graph_file_path):
                self.load_graph_data(graph_file_path)
            else:
                QMessageBox.warning(self, "No Graph Data Found", "The selected directory does not contain a valid graph_recording.csv file.")

            self.info.setText(f"Loaded images, movement data, and graph data entries!")

    def check_data_loaded(self):
        """Check if image paths are loaded before allowing navigation"""
        if not self.image_paths:
            QMessageBox.warning(self, "No Data Loaded", "Please load a directory with images first.")
            return False
        return True  # Return True if data is loaded

    def show_previous_timepoint(self):
        """Show the previous timepoint"""
        if not self.check_data_loaded():
            return  # Only proceed if data is loaded

        if self.current_index > 0:
            self.current_index -= 1  # Move one timepoint back
            self.slider.setValue(self.current_index)  # Update slider to reflect the current index
            self.update_view()

    def show_next_timepoint(self):
        """Show the next timepoint"""
        if not self.check_data_loaded():
            return  # Only proceed if data is loaded

        if self.current_index < len(self.image_paths) - 1:
            self.current_index += 1  # Move one timepoint forward
            self.slider.setValue(self.current_index)  # Update slider to reflect the current index
            self.update_view()

    def slider_changed(self):
        """Update timepoint based on the slider's position"""
        if not self.check_data_loaded():
            return  # Only proceed if data is loaded

        new_index = self.slider.value()  # Get the new index from the slider

        # Update the current index
        self.current_index = new_index

        # Update the view based on the slider's new value
        self.update_view()

    def update_view(self):
        """Update the displayed image, graphs, and info based on the current timestamp"""
        if 0 <= self.current_index < len(self.image_paths):
            # Display the selected image
            self.display_image(self.image_paths[self.current_index])

            # Update info and graphs
            self.update_info()
            self.update_graphs()

        else:
            print(f"Invalid index: {self.current_index}. The image paths list has {len(self.image_paths)} items.")

    def update_info(self):
        """Update the info label with current timepoint details"""
        if not self.check_data_loaded():
            return  # Only proceed if data is loaded
        timepoint = self.timestamps[self.current_index] - self.first_timestamp

        # Find the closest movement data timepoint from dictionary to the current timepoint
        movement_index = next((i for i, data in enumerate(self.movement_data) if data['time'] >= self.timestamps[self.current_index]), None)

        if movement_index is not None:
            movement_data = self.movement_data[movement_index]
            stage_x, stage_y, stage_z = movement_data['stage']
            pipette_x, pipette_y, pipette_z = movement_data['pipette']
            self.info.setText(f"Time: {int(timepoint)} seconds, Stage: ({stage_x}, {stage_y}, {stage_z}), Pipette: ({pipette_x}, {pipette_y}, {pipette_z})")
        else:
            self.info.setText(f"Time: {timepoint} seconds, No movement data available.")

    def update_graphs(self):
        """Update the graphs with the current timepoint data and manage deques based on the closest timestamp"""
        if not self.check_data_loaded():
            return  # Only proceed if data is loaded

        # Get the current timestamp for the current frame
        current_timestamp = self.timestamps[self.current_index]

        # Clear deques before repopulating
        self.pressure_deque.clear()
        self.resistance_deque.clear()

        # Find the closest graph_data entries for the current timestamp
        graph_index = next((i for i, data in enumerate(self.graph_data) if data['time'] >= current_timestamp), None)

        # If a matching entry is found, backtrack up to 99 previous entries
        if graph_index is not None:
            start_index = max(0, graph_index - 99)  # Ensure we don't go below 0

            # Loop through the 99 previous entries (or as many as available)
            for i in range(start_index, graph_index + 1):
                graph_data = self.graph_data[i]
                self.pressure_deque.append(graph_data['pressure'])
                self.resistance_deque.append(graph_data['resistance'])

        # Now that the deques have been updated, plot the values
        self.plot_graphs()

    def plot_graphs(self):
        """Plot the values from the deques and the main graph data"""
        # Clear the plots
        for plot in self.plots:
            plot.clear()

        # Plot the new data (voltage and current are continuous lists)
        current_timestamp = self.timestamps[self.current_index]
        graph_index = next((i for i, data in enumerate(self.graph_data) if data['time'] >= current_timestamp), None)

        if graph_index is not None:
            graph_data = self.graph_data[graph_index]
            current = graph_data['current']
            voltage = graph_data['voltage']

            self.plots[0].plot(voltage, pen=pg.mkPen(color='b', width=2))  # Plot voltage
            self.plots[1].plot(current, pen=pg.mkPen(color='r', width=2))  # Plot current

        # Plot the deque values for pressure and resistance
        self.plots[2].plot(list(self.pressure_deque), pen=pg.mkPen(color='g', width=2))  # Pressure
        self.plots[3].plot(list(self.resistance_deque), pen=pg.mkPen(color='m', width=2))  # Resistance

    def load_images_from_directory(self, directory):
        """Load images from the directory"""
        print(f"Loading images from {directory}")
        if not os.path.exists(directory):
            print(f"Directory {directory} does not exist")
            return
        else:
            self.image_paths = [os.path.join(directory, f) for f in os.listdir(directory) if f.endswith('.webp')]
        if not self.image_paths:
            print(f"No images found in {directory}")
            self.image.setText("No images found.")
            return
        else:
            print(f"Found {len(self.image_paths)} images")
            print(f"First image path: {self.image_paths[0]}")
            self.first_index, self.first_timestamp = self.extract_image_data(self.image_paths[0])
            print(f"First index: {self.first_index} and timestamp: {self.first_timestamp}")
            self.last_index, self.last_timestamp = self.extract_image_data(self.image_paths[-1])
            print(f"Last index: {self.last_index} and timestamp: {self.last_timestamp}")
            self.current_index = 0
            self.display_image(self.image_paths[self.current_index])
            self.duration = self.last_timestamp - self.first_timestamp
            print(f"Duration: {self.duration} seconds")
            slider_max = len(self.image_paths) - 1
            self.slider.setMaximum(slider_max)
            print(f"Slider max: {slider_max}, Image count: {len(self.image_paths)}")
            self.slider.repaint()

            self.slider.setSingleStep(1)
            self.slider.setMinimum(0)
            self.timestamps = [self.extract_image_data(f)[1] for f in self.image_paths]
            self.image_index = [self.extract_image_data(f)[0] for f in self.image_paths]
        return

    def load_movement_data(self, file_path):
        """Load movement data from the file"""
        print(f"Loading movement data from {file_path}")
        self.movement_data.clear()
        try:
            with open(file_path, mode='r') as file:
                for line in file:
                    # Split by spaces and filter out empty strings
                    parts = [part for part in line.strip().split(' ') if part]

                    # Check if we have the expected number of parts (7 values)
                    if len(parts) < 7:
                        QMessageBox.warning(self, "Data Error", f"Skipping invalid data line: {line}.")
                        continue

                    try:
                        # Extract values using the correct format
                        time_value = float(parts[0].split(':')[1])
                        st_x = float(parts[1].split(':')[1])
                        st_y = float(parts[2].split(':')[1])
                        st_z = float(parts[3].split(':')[1])
                        pi_x = float(parts[4].split(':')[1])
                        pi_y = float(parts[5].split(':')[1])
                        pi_z = float(parts[6].split(':')[1])

                        self.movement_data.append({
                            'time': time_value,
                            'stage': (st_x, st_y, st_z),
                            'pipette': (pi_x, pi_y, pi_z)
                        })

                    except (IndexError, ValueError) as e:
                        QMessageBox.warning(self, "Data Error", f"Skipping invalid data line: {line}. Error: {e}")
        except Exception as e:
            QMessageBox.critical(self, "Error Loading Movement Data", f"An error occurred while loading movement data: {e}")

    def load_graph_data(self, file_path):
        """Load graph data from the file"""
        print(f"Loading graph data from {file_path}")
        self.graph_data.clear()  # This will hold the list of dictionaries for each row

        try:
            with open(file_path, mode='r') as file:
                for line in file:
                    # Split by spaces and filter out empty strings
                    parts = [part for part in line.strip().split(':') if part]

                    # Parse each value
                    if len(parts) < 6:
                        # Not enough parts, skip this line
                        continue

                    try:
                        time_value = float(parts[1].split(' ')[0])
                        pressure_value = float(parts[2].split(' ')[0])
                        resistance_value = float(parts[3].split(' ')[0])

                        # Extract the current and voltage values as lists
                        current_data = parts[4].split('[')[-1].split(']')[0]
                        current_value = [float(x) for x in current_data.split(',') if x]

                        voltage_data = parts[5].split('[')[-1].split(']')[0]
                        voltage_value = [float(x) for x in voltage_data.split(',') if x]

                        # Create a dictionary for this row
                        row_data = {
                            'time': time_value,
                            'pressure': pressure_value,
                            'resistance': resistance_value,
                            'current': current_value,
                            'voltage': voltage_value
                        }

                        # Append the dictionary to the list
                        self.graph_data.append(row_data)

                    except (IndexError, ValueError) as e:
                        # Skip lines with parsing errors
                        continue

        except Exception as e:
            QMessageBox.critical(self, "Error Loading Graph Data", f"An error occurred while loading graph data: {e}")

    def extract_image_data(self, image_path):
        """Extract the image data based on file path"""
        try:
            filename = os.path.basename(image_path)
            index_str = int(filename.split('_')[0])
            timestamp_str = float(filename.split('_')[1].rsplit('.', 1)[0])
        except Exception as e:
            print(f"Error extracting index and timestamp from {image_path}: {e}")
            index_str, timestamp_str = 0, 0.0  # Default values in case of error
        return index_str, timestamp_str

    def display_image(self, image_path):
        """Display the image on the QLabel"""
        if not os.path.exists(image_path):
            QMessageBox.warning(self, "Error", f"Image file {image_path} does not exist.")
            return  # Exit if image path is invalid
        self.slider.blockSignals(True)
        pixmap = QPixmap(image_path)
        if pixmap.isNull():
            QMessageBox.warning(self, "Error", "Unable to load image.")
        else:
            # Scale the pixmap to fit the label while maintaining aspect ratio
            scaled_pixmap = pixmap.scaled(
                self.image.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation
            )
            self.image.setPixmap(scaled_pixmap)
            self.image.show()
        self.slider.blockSignals(False)

    def resizeEvent(self, event):
        """Handle window resize events to scale the image appropriately"""
        if self.image_paths and 0 <= self.current_index < len(self.image_paths):
            self.display_image(self.image_paths[self.current_index])
        super().resizeEvent(event)  # Ensure the base class resizeEvent is also called

if __name__ == '__main__':
    app = QApplication(sys.argv)
    timeline = Timeline()
    timeline.show()
    sys.exit(app.exec_())


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/graph_update_analyzer_logs.py
================================================
# This script assesses how accurate the update method in EPhysGraph is in the graph.py file. to use you need to uncomment #logging.debug('graph updated') in the update method in graph.py on approximately line 417
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

directory = r'C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Analysis\Rig_Recorder'
new_file_path = directory + '\logs.csv'
new_data = pd.read_csv(new_file_path, on_bad_lines='skip')

# Convert the 'Time(HH:MM:SS)' column to datetime and add the milliseconds from 'Time(ms)'
    # Ensure columns are treated as strings
new_data['Time(HH:MM:SS)'] = new_data['Time(HH:MM:SS)'].astype(str)
new_data['Time(ms)'] = new_data['Time(ms)'].astype(str)
new_data['Timestamp'] = pd.to_datetime(new_data['Time(HH:MM:SS)'] + '.' + new_data['Time(ms)'], format='%Y-%m-%d %H:%M:%S.%f', errors='coerce')

# Find the latest event with INFO and 'Program Started'
latest_program_started_idx = new_data[(new_data['Level'] == 'INFO') & (new_data['Message'].str.contains('Program Started'))]['Timestamp'].idxmax()

# Filter the data to only include events after the latest 'Program Started'
filtered_data = new_data.loc[latest_program_started_idx + 1:]

# Filter the rows where "Message" contains "graph updated"
graph_updated_rows_filtered = filtered_data[filtered_data['Message'].str.contains("graph updated", na=False)]

# Sort the dataframe by the timestamp to ensure the points are ordered properly
graph_updated_rows_sorted_filtered = graph_updated_rows_filtered.sort_values(by='Timestamp')

# Remove duplicate "graph updated" events with the exact same timestamp
graph_updated_unique_filtered = graph_updated_rows_sorted_filtered.drop_duplicates(subset='Timestamp', keep='first')

# Extract the unique times in milliseconds
unique_times_ms_filtered = graph_updated_unique_filtered['Timestamp'].astype('int64') // 10**6

# Calculate the intervals between successive unique "graph updated" times
unique_intervals_ms_filtered = [unique_times_ms_filtered.iloc[i] - unique_times_ms_filtered.iloc[i - 1] for i in range(1, len(unique_times_ms_filtered))]

# Calculate the running average of the unique intervals
window_size = 10
unique_running_average_filtered = np.convolve(unique_intervals_ms_filtered, np.ones(window_size) / window_size, mode='valid')

# Calculate the average frame rate (average of the unique intervals)
average_framerate_ms_filtered = sum(unique_intervals_ms_filtered) / len(unique_intervals_ms_filtered) if unique_intervals_ms_filtered else None

# Find the closest index for the "closing GUI" event in the unique times list
closing_gui_timestamp = filtered_data[filtered_data['Message'].str.contains('closing GUI', na=False)]['Timestamp'].min()
closest_index = (unique_times_ms_filtered - int(closing_gui_timestamp.timestamp() * 1000)).abs().argmin()

# Plot the unique intervals between "graph updated" events with running average, average frame rate, and "closin
plt.figure(figsize=(10, 6))
plt.plot(unique_intervals_ms_filtered, marker='o', linestyle='-', label='Intervals')
plt.plot(range(window_size - 1, len(unique_intervals_ms_filtered)), unique_running_average_filtered, color='red', linestyle='-', label='Running Average')
plt.axhline(y=average_framerate_ms_filtered, color='green', linestyle='--', label=f'Average Interval: {average_framerate_ms_filtered:.2f} ms')
plt.axvline(x=closest_index, color='blue', linestyle='--', label='Closing GUI')
plt.title('Intervals between Unique "Graph Updated" Events with Running Average, Average Interval, and Closing GUI Event')
plt.xlabel('Event Number')
plt.ylabel('Interval (ms)')
plt.legend()
plt.grid(True)
plt.show()

================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/frame_rate_analyzer_logs.py
================================================

import pandas as pd
import matplotlib.pyplot as plt

def load_and_prepare_data(filepath):
    # Load the CSV file with updated argument for handling bad lines
    data = pd.read_csv(filepath, on_bad_lines='skip')
    
    # Ensure columns are treated as strings
    data['Time(HH:MM:SS)'] = data['Time(HH:MM:SS)'].astype(str)
    data['Time(ms)'] = data['Time(ms)'].astype(str)

    # Extract relevant parts of messages and convert times
    data['FPS Value'] = data['Message'].str.extract(r'FPS .*: (\d+\.\d+)').astype(float)
    data['FPS Type'] = data['Message'].str.extract(r'FPS in ([\w\s]+):')
    
    # Concatenate time and milliseconds, then convert to datetime
    data['Time'] = pd.to_datetime(data['Time(HH:MM:SS)'] + '.' + data['Time(ms)'], format='%Y-%m-%d %H:%M:%S.%f', errors='coerce')
    
    return data


def plot_fps_data_with_markers(data, title, program_start_time, recording_starts, recording_stops):
    # Ensure data is sorted by time
    data = data.sort_values('Time')

    # Setup figure
    plt.figure(figsize=(14, 7))
    colors = {'Camera': 'blue', 'Acquisition Thread': 'orange', 'LIVEFEED': 'green'}
    markers = {'Camera': 'o', 'Acquisition Thread': 'x', 'LIVEFEED': '^'}

    # Filter data from the first "FPS in LIVEFEED" and process each type separately
    livefeed_start_time = data[data['FPS Type'] == 'LIVEFEED']['Time'].min()
    data = data[data['Time'] >= livefeed_start_time]

    for fps_type, color in colors.items():
        subset = data[data['FPS Type'] == fps_type]
        if not subset.empty:
            # Calculate per-type statistics
            overall_average = subset['FPS Value'].mean()
            running_avg = subset['FPS Value'].rolling(window=20).mean()
            cumulative_avg = subset['FPS Value'].expanding().mean()
            print(f'{fps_type} FPS: {overall_average:.2f} fps')
            print(f'{fps_type} Running Avg: {running_avg.mean():.2f} fps')
            print(f'{fps_type} Cumulative Avg: {cumulative_avg.mean():.2f} fps')
            




            # Plotting
            plt.plot(subset['Time'], subset['FPS Value'], color=color, marker=markers[fps_type], linestyle='-', label=f'{fps_type} FPS')
            plt.plot(subset['Time'], running_avg, color=color, linestyle='--', label=f'{fps_type} Running Avg')
            plt.plot(subset['Time'], cumulative_avg, color=color, linestyle=':', label=f'{fps_type} Cumulative Avg')
            plt.axhline(y=overall_average, color=color, linestyle='-.', label=f'{fps_type} Avg: {overall_average:.2f} fps')

    # Add recording markers
    for start in recording_starts['Time']:
        if livefeed_start_time <= start <= data['Time'].max():
            plt.axvline(x=start, color='g', linestyle='--', label='Recording Started' if 'Recording Started' not in plt.gca().get_legend_handles_labels()[1] else "")
    for stop in recording_stops['Time']:
        if livefeed_start_time <= stop <= data['Time'].max():
            plt.axvline(x=stop, color='r', linestyle='--', label='Recording Stopped' if 'Recording Stopped' not in plt.gca().get_legend_handles_labels()[1] else "")

    # Finalize plot
    plt.title(title)
    plt.xlabel('Time')
    plt.ylabel('FPS')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    # save fiel
    # plt.savefig('fps_over_time.png')
    plt.show()

def main():
    directory = r'C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Analysis\Rig_Recorder'
    filepath = directory + '\logs.csv'

    data = load_and_prepare_data(filepath)
    program_starts = data[data['Message'].str.contains("Program Started", case=False, na=False)]
    recording_starts = data[data['Message'].str.contains("recording started", case=False, na=False)]
    recording_stops = data[data['Message'].str.contains("recording stopped", case=False, na=False)]

    # # Process each program start segment
    # if not program_starts.empty:
    #     for i in range(len(program_starts)):
    #         start_time = program_starts.iloc[i]['Time']
    #         if i < len(program_starts) - 1:
    #             end_time = program_starts.iloc[i + 1]['Time']
    #         else:
    #             end_time = data['Time'].max()
    #         segment_data = data[(data['Time'] >= start_time) & (data['Time'] <= end_time)]
    #         plot_fps_data_with_markers(segment_data, f'FPS Over Time After Program Start {i + 1}', start_time, recording_starts, recording_stops)

    # Process only the last program start segment
    if not program_starts.empty:
        # Access the last program start
        i = len(program_starts) - 1
        start_time = program_starts.iloc[i]['Time']
        end_time = data['Time'].max()  # Assuming the last segment goes until the end of the data
        segment_data = data[(data['Time'] >= start_time) & (data['Time'] <= end_time)]
        plot_fps_data_with_markers(segment_data, f'FPS Over Time After Program Start', start_time, recording_starts, recording_stops)



if __name__ == "__main__":
    main()


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/resistance.py
================================================
import csv
import matplotlib.pyplot as plt
from collections import deque
from datetime import datetime
import os

def extract_data_and_plot(file_path, output_path):
    #create output path if it doesn't exist
    if not os.path.exists(output_path):
            os.makedirs(output_path)
    print("Writing to:", output_path)
    i = 0
    previous_timestamp = None
    resistance_vals = deque(maxlen=100)

    with open(file_path, newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            joined_row = ''.join(row)
            timestamp_str = joined_row.split("pressure:")[0].replace("timestamp:", "").strip()
            joined_row = joined_row.split('resistance:')[1]
            resistance_val = joined_row.split('current', 1)[0]
            
            # Convert timestamp to float (UNIX timestamp)
            current_timestamp = float(timestamp_str)
            
            # Check if the difference between timestamps is less than 0.032 seconds
            if previous_timestamp and (current_timestamp - previous_timestamp) < 0.032:
                continue

            resistance_vals.append(float(resistance_val))
            indices = list(range(len(resistance_vals)))
            filename = f'{i}_{timestamp_str}.webp'
            
            # Plotting
            plt.figure()
            plt.plot(indices, list(resistance_vals))
            plt.xlabel('Index')
            plt.ylabel('Resistance')
            plt.title('Resistance Plot')
            plt.savefig(f'{output_path}/{filename}')
            plt.close()
            
            # Update the previous timestamp
            previous_timestamp = current_timestamp
            i += 1

    print("Done writing to:", output_path)

file_path =r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\graph_recording.csv"
output_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\resistance_frames"
extract_data_and_plot(file_path, output_path)






================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/image_saver_test.py
================================================
# will test the saving performance of differnt image formats wwith differnt packages
import numpy as np
import time
import cv2
from PIL import Image
import imageio
import os

# Generate random images of size 1280x1280
images = [np.random.randint(0, 256, (1280, 1280, 3), dtype=np.uint8) for _ in range(100)]

# Define the formats to save the images in
formats = {
    'Pillow': {
        'formats': ['jpeg', 'png', 'bmp', 'gif', 'tiff', 'webp', 'ppm'],
        'extension': {'jpeg': 'jpg', 'png': 'png', 'bmp': 'bmp', 'gif': 'gif', 'tiff': 'tiff', 'webp': 'webp', 'ppm': 'ppm'}
    },
    'OpenCV': {
        'formats': ['jpeg', 'png', 'bmp', 'tiff', 'webp'],
        'extension': {'jpeg': 'jpg', 'png': 'png', 'bmp': 'bmp', 'tiff': 'tiff', 'webp': 'webp'}
    },
    'imageio': {
        'formats': ['jpeg', 'png', 'bmp', 'gif', 'tiff', 'webp', 'ppm'],
        'extension': {'jpeg': 'jpg', 'png': 'png', 'bmp': 'bmp', 'gif': 'gif', 'tiff': 'tiff', 'webp': 'webp', 'ppm': 'ppm'}
    }
}

# Function definitions for saving images with different libraries
def save_with_pillow(images, format, save_folder):
    times = []
    specific_save_folder = os.path.join(save_folder, f"Pillow_{format}")
    os.makedirs(specific_save_folder, exist_ok=True)
    for idx, img in enumerate(images):
        pil_img = Image.fromarray(img)
        timestamp = int(time.time())
        filename = f"{specific_save_folder}\\frame-{idx}_{timestamp}.{formats['Pillow']['extension'][format]}"
        start_time = time.time()
        pil_img.save(filename, format=format)
        times.append(time.time() - start_time)
    return np.mean(times)

def save_with_opencv(images, format, save_folder):
    times = []
    specific_save_folder = os.path.join(save_folder, f"OpenCV_{format}")
    os.makedirs(specific_save_folder, exist_ok=True)
    for idx, img in enumerate(images):
        timestamp = int(time.time())
        filename = f"{specific_save_folder}\\frame-{idx}_{timestamp}.{formats['OpenCV']['extension'][format]}"
        start_time = time.time()
        cv2.imwrite(filename, img)
        times.append(time.time() - start_time)
    return np.mean(times)

def save_with_imageio(images, format, save_folder):
    times = []
    specific_save_folder = os.path.join(save_folder, f"imageio_{format}")
    os.makedirs(specific_save_folder, exist_ok=True)
    for idx, img in enumerate(images):
        timestamp = int(time.time())
        filename = f"{specific_save_folder}\\frame-{idx}_{timestamp}.{formats['imageio']['extension'][format]}"
        start_time = time.time()
        imageio.imwrite(filename, img, format=format)
        times.append(time.time() - start_time)
    return np.mean(times)


# Specify the folder to save the images
save_folder = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Analysis\Rig_Recorder\Reconstruct\image_saver_test"

# Ensure the save folder exists
os.makedirs(save_folder, exist_ok=True)
print("Saving images to different formats using different packages...")
# Compute average durations for all packages and formats
average_durations = {}
for package, info in formats.items():
    average_durations[package] = {}
    for format in info['formats']:
        if package == 'Pillow':
            avg_time = save_with_pillow(images, format, save_folder)
        elif package == 'OpenCV':
            avg_time = save_with_opencv(images, format, save_folder)
        elif package == 'imageio':
            avg_time = save_with_imageio(images, format, save_folder)
        average_durations[package][format] = avg_time

average_durations

import csv
print("Saving average durations to a CSV file...")
# Existing code to calculate average_durations...

# Specify the CSV file path
csv_file_path = save_folder + r"\average_durations.csv"

# Ensure the save folder exists for the CSV file
os.makedirs(os.path.dirname(csv_file_path), exist_ok=True)

# Write the average durations to a CSV file
with open(csv_file_path, mode='w', newline='') as file:
    writer = csv.writer(file, delimiter='\t')
    # Write the header
    writer.writerow(['Package', 'Format', 'Average Duration (s)'])
    # Write the data
    for package, formats in average_durations.items():
        for format, avg_time in formats.items():
            writer.writerow([package, format, avg_time])

================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/ephys.py
================================================
import csv
import matplotlib.pyplot as plt
from datetime import datetime

def extract_data_and_plot(file_path, output_path):
    print("Writing to:", output_path)
    i = 0
    previous_timestamp = None

    with open(file_path, newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            # Join the row into a single string and then split by '],', which is the end of each array
            joined_row = ''.join(row)
            timestamp_str = joined_row.split("pressure:")[0].replace("timestamp:", "").strip()
            joined_row = joined_row.split('time:')[1]

            # Convert timestamp to float (UNIX timestamp)
            current_timestamp = float(timestamp_str)

            # Check if the difference between timestamps is less than 0.032 seconds
            if previous_timestamp and (current_timestamp - previous_timestamp) < 0.032:
                continue

            time_vals = joined_row.split('current:')[0].replace("[", "").replace("]", "")
            time_vals_list = [float(val) for val in time_vals.strip('[]').split()]

            current_vals = joined_row.split('current:')[1]
            current_vals_list = [float(val) for val in current_vals.strip('[]').split()]
            filename = f'{i}_{timestamp_str}.webp'

            # Plotting
            plt.figure()
            plt.plot(time_vals_list, current_vals_list)
            plt.xlabel('Time')
            plt.ylabel('Current')
            plt.title('Time vs Current Plot')
            plt.savefig(f'{output_path}/{filename}')
            plt.close()
            
            # Update the previous timestamp
            previous_timestamp = current_timestamp
            i += 1

    print("Done writing to:", output_path)

# Example usage:
file_path =r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\graph_recording.csv"
output_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_08_06-18_11\current_frames"
# file_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\graph_recording.csv"
# output_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\rig_recorder_data\2024_06_19-18_45\current_frames"
extract_data_and_plot(file_path, output_path)


================================================
File: /experiments/Analysis/Rig_Recorder/Reconstruct/Timeline.py
================================================
import sys
import os
import csv
from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget, QPushButton, QFileDialog, QShortcut, QHBoxLayout, QToolButton, QFrame, QSlider, QMessageBox
from PyQt5.QtGui import QPixmap, QColor
from PyQt5.QtCore import Qt
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class ImageViewer(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Rig Replay")
        self.setGeometry(0, 0, 800, 800)
        self.setMaximumSize(800, 800)
        
        # Main layout
        self.main_layout = QVBoxLayout()

        # Top section (Image display area)
        self.image_label = QLabel("No Image Loaded")
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setMinimumSize(1280, 1280)
        self.image_label.setMaximumSize(800, 1280)
        
        # Add dividing line above the bottom widget
        self.image_frame = QFrame()
        self.image_frame.setLayout(QVBoxLayout())
        self.image_frame.layout().addWidget(self.image_label)
        self.image_frame.setFrameShape(QFrame.StyledPanel)
        self.image_frame.setFrameShadow(QFrame.Sunken)
        
        self.main_layout.addWidget(self.image_frame)
        self.set_white_box()  # Set a white box as the placeholder
        
        # Scrubbing feature (Slider)
        self.timeline_slider = QSlider(Qt.Horizontal)
        self.timeline_slider.setMaximumHeight(40)  # Match the height of the label box
        self.timeline_slider.setMinimum(0)
        self.timeline_slider.setTickPosition(QSlider.NoTicks)  # Remove tick marks
        self.timeline_slider.valueChanged.connect(self.slider_changed)
        
        # Scrubbing frame
        self.scrubbing_frame = QFrame()
        self.scrubbing_frame.setLayout(QVBoxLayout())
        self.scrubbing_frame.setMaximumHeight(40)
        self.scrubbing_frame.layout().addWidget(self.timeline_slider)
        self.scrubbing_frame.setFrameShape(QFrame.StyledPanel)
        self.scrubbing_frame.setFrameShadow(QFrame.Sunken)
        
        self.main_layout.addWidget(self.scrubbing_frame)

        # Bottom section
        self.bottom_layout = QVBoxLayout()
    
        # Combine time, stage, and pipette information in one widget
        self.info_label = QLabel("Time: 0.0s\nStage (X, Y, Z): N/A, N/A, N/A\nPipette (X, Y, Z): N/A, N/A, N/A")
        self.info_label.setAlignment(Qt.AlignLeft)
        self.info_label.setMaximumHeight(40)
        
        # Add dividing line above the info display
        self.info_frame = QFrame()
        self.info_frame.setLayout(QHBoxLayout())
        self.info_frame.setMaximumHeight(60)
        self.info_frame.layout().addWidget(self.info_label)
        self.info_frame.setFrameShape(QFrame.StyledPanel)
        self.info_frame.setFrameShadow(QFrame.Sunken)
        
        self.bottom_layout.addWidget(self.info_frame)
        
        # Add bottom layout to the main layout
        self.main_layout.addLayout(self.bottom_layout)
        
        # Sidebar layout
        self.sidebar_widget = QFrame()
        self.sidebar_widget.setLayout(QVBoxLayout())
        self.sidebar_widget.setFrameShape(QFrame.StyledPanel)
        self.sidebar_widget.setFrameShadow(QFrame.Sunken)

        # Buttons
        self.select_image_dir_button = QPushButton("Select Data Directory")
        self.select_image_dir_button.clicked.connect(self.open_directory)
        self.sidebar_widget.layout().addWidget(self.select_image_dir_button)

        self.prev_image_button = QPushButton("Previous timepoint")
        self.prev_image_button.clicked.connect(self.show_previous_image)
        self.sidebar_widget.layout().addWidget(self.prev_image_button)
        
        self.next_image_button = QPushButton("Next timepoint")
        self.next_image_button.clicked.connect(self.show_next_image)
        self.sidebar_widget.layout().addWidget(self.next_image_button)
        
        # Add spacing and stretch to align buttons to the top
        self.sidebar_widget.layout().addStretch()

        # Create a container layout to include the sidebar and main layout
        self.container_layout = QHBoxLayout()
        self.container_layout.addLayout(self.main_layout)
        self.container_layout.addWidget(self.sidebar_widget)

        # Set the container layout as the central widget
        self.main_widget = QWidget()
        self.main_widget.setLayout(self.container_layout)
        self.setCentralWidget(self.main_widget)
        
        # Initialize image list
        self.image_paths = []
        self.current_image_index = -1
        self.first_timestamp = 0

        # Initialize movement data
        self.movement_data = {}
        
        # Keyboard shortcuts
        self.shortcut_left = QShortcut(Qt.Key_Left, self)
        self.shortcut_left.activated.connect(self.show_previous_image)
        self.shortcut_right = QShortcut(Qt.Key_Right, self)
        self.shortcut_right.activated.connect(self.show_next_image)
        
    def set_white_box(self):
        """Display a white box as a placeholder in the image label."""
        pixmap = QPixmap(self.image_label.size())
        pixmap.fill(QColor("white"))
        self.image_label.setPixmap(pixmap)

    def toggle_sidebar(self):
        """Toggle the sidebar visibility."""
        if self.sidebar_widget.isVisible():
            self.sidebar_widget.hide()
        else:
            self.sidebar_widget.show()

    def open_directory(self):
        directory = QFileDialog.getExistingDirectory(self, "Open Directory", "")
        if directory:
            camera_frames_dir = os.path.join(directory, 'camera_frames')
            movement_file_path = os.path.join(directory, 'movement_recording.csv')
            if os.path.exists(camera_frames_dir):
                self.load_images_from_directory(camera_frames_dir)
            else:
                self.image_label.setText("No camera_frames directory found in the selected folder.")
            if os.path.exists(movement_file_path):
                self.load_movement_data(movement_file_path)
            else:
                QMessageBox.warning(self, "No Movement Data Found", "The selected directory does not contain a valid movement_recording.csv file.")
    
    def load_images_from_directory(self, directory):
        self.image_paths = [os.path.join(directory, f) for f in os.listdir(directory) if f.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif', '.webp'))]
        self.image_paths.sort(key=self.extract_timestamp)  # Sort images by timestamp

        if self.image_paths:
            self.first_timestamp = self.extract_timestamp(self.image_paths[0])
            print(f"First Timestamp: {self.first_timestamp} s")
            last_timestamp = self.extract_timestamp(self.image_paths[-1])
            print(f"Last Timestamp: {last_timestamp} s")
            self.duration = (last_timestamp - self.first_timestamp) # Convert to milliseconds
            print(f"Duration: {self.duration}s")
            self.timeline_slider.setMaximum(int(self.duration)) 
            # self.timeline_slider.setTickInterval(int(self.duration/10))  # Add 10 ticks
            self.first_index = self.extract_image_index(self.image_paths[0])
            print(f"First Index: {self.first_index}")
            self.last_index = self.extract_image_index(self.image_paths[-1])
            print(f"Last Index: {self.last_index}")
            self.current_image_index = 0
            self.display_image(0)
        else:
            QMessageBox.warning(self, "No Images Found", "The selected directory does not contain any valid images.")

    def find_closest_time(self, target_time):
        """Find the closest time in movement_data to the target time."""
        if not self.movement_data:
            return None
        return min(self.movement_data.keys(), key=lambda x: abs(x - target_time))

    def load_movement_data(self, file_path):
        self.movement_data.clear()
        try:
            with open(file_path, mode='r') as file:
                for line in file:
                    # Split by spaces and filter out empty strings
                    parts = [part for part in line.strip().split(' ') if part]
                    
                    # Check if we have the expected number of parts (7 values)
                    if len(parts) < 7:
                        QMessageBox.warning(self, "Data Error", f"Skipping invalid data line: {line}.")
                        continue
                    
                    try:
                        # Extract values using the correct format
                        time_value = float(parts[0].split(':')[1])
                        st_x = float(parts[1].split(':')[1])
                        st_y = float(parts[2].split(':')[1])
                        st_z = float(parts[3].split(':')[1])
                        pi_x = float(parts[4].split(':')[1])
                        pi_y = float(parts[5].split(':')[1])
                        pi_z = float(parts[6].split(':')[1])
                        
                        # Store the cleaned data
                        self.movement_data[time_value] = {
                            'stage': (st_x, st_y, st_z),
                            'pipette': (pi_x, pi_y, pi_z)
                        }
                    except (IndexError, ValueError) as e:
                        QMessageBox.warning(self, "Data Error", f"Skipping invalid data line: {line}. Error: {e}")
        except Exception as e:
            QMessageBox.critical(self, "Error Loading Movement Data", f"An error occurred while loading movement data: {e}")

    def extract_timestamp(self, filepath):
        try:
            filename = os.path.basename(filepath)
            timestamp_str = filename.split('_')[1].rsplit('.', 1)[0]
        
            return float(timestamp_str)
        except (IndexError, ValueError):
            return 0
        
    def extract_image_index(self, filepath):
        try:
            filename = os.path.basename(filepath)
            index_str = filename.split('_')[0]
        
            return int(index_str)
        except (IndexError, ValueError):
            return 0
    
    def check_images_loaded(self):
        """Check if images are loaded. If not, prompt the user to open a directory."""
        if not self.image_paths:
            QMessageBox.warning(self, "No Images Loaded", "Please select a directory containing images first.")
            return False
        return True
    
    def display_image(self, index):
        """Display the image at the specified index and update movement data."""
        if index >= 0 and index < len(self.image_paths): 
            print(f"index: {index}")
            pixmap = QPixmap(self.image_paths[index]) 
            print(f"Displaying Image: {self.image_paths[index]}")
            self.image_label.setPixmap(pixmap.scaled(self.image_label.size(), Qt.KeepAspectRatio)) 
            self.setWindowTitle(f"Rig Replay - {os.path.basename(self.image_paths[index])}") 
            time_elapsed = self.calculate_time_elapsed(index)
            self.update_info_label(time_elapsed)
            self.update_movement_plot(time_elapsed)
            
            # Set the slider position to match the current image time
            self.timeline_slider.blockSignals(True)  # Temporarily block signals to avoid recursion
            self.timeline_slider.setValue(int(time_elapsed * 1000))  # Convert to milliseconds
            self.timeline_slider.blockSignals(False)

    def update_info_label(self, time_elapsed):
        """Update the info label with time, stage, and pipette positions."""
        closest_time = self.find_closest_time(time_elapsed)
        if closest_time is not None:
            stage_pos = self.movement_data[closest_time]['stage']
            # print(stage_pos)
            pipette_pos = self.movement_data[closest_time]['pipette']
            # print(pipette_pos)
            time_elapsed = self.calculate_time_elapsed(self.current_image_index)*1000
            self.info_label.setText(f"Time: {time_elapsed:.1f}s (Data: {closest_time:.1f}s)\n"
                                    f"Stage (X, Y, Z): {stage_pos[0]:.2f}, {stage_pos[1]:.2f}, {stage_pos[2]:.2f}\n"
                                    f"Pipette (X, Y, Z): {pipette_pos[0]:.2f}, {pipette_pos[1]:.2f}, {pipette_pos[2]:.2f}")
        else:
            self.info_label.setText(f"Time: {time_elapsed:.1f}s\n"
                                    "Stage (X, Y, Z): N/A, N/A, N/A\n"
                                    "Pipette (X, Y, Z): N/A, N/A, N/A")

    def slider_changed(self, value):
        """Handle slider movement to display the closest image and update movement data."""
        if not self.check_images_loaded():
            return
        time_elapsed = value   # Convert milliseconds to seconds from the start
        self.current_image_index = self.find_closest_image_index(time_elapsed)
        self.display_image(self.current_image_index)
        
        # Update the info label even when sliding between images
        time_elapsed = self.first_timestamp + value
        self.update_info_label(time_elapsed)

    def calculate_time_elapsed(self, index):
        """Calculate time elapsed in seconds from the start of the video."""
        return (self.extract_timestamp(self.image_paths[index]) - self.first_timestamp)

    def find_closest_image_index(self, target_time):
        """Find the index of the image closest to the target time."""
        return min(range(len(self.image_paths)), 
                   key=lambda i: abs(self.calculate_time_elapsed(i) - target_time))

    def show_previous_image(self):
        """Navigate to the previous image and update the slider."""
        if not self.check_images_loaded():
            return
        if self.current_image_index > 0:
            self.current_image_index -= 1
            print(f"Previous Image Index: {self.current_image_index}")
            # self.display_image(self.current_image_index)
            # Update slider to reflect the correct time for this image
            time_elapsed = self.calculate_time_elapsed(self.current_image_index)
            # print(f"Time Elapsed: {time_elapsed}")
            print(f"Time Elapsed: {time_elapsed}")
            self.timeline_slider.setValue(int(time_elapsed))  
            self.slider_changed(int(time_elapsed))  # Call slider_changed

        
    def show_next_image(self):
        """Navigate to the next image and update the slider."""
        if not self.check_images_loaded():
            return

        if self.current_image_index < len(self.image_paths) - 1:
            print(f"Current Index: {self.current_image_index}")
            self.current_image_index += 1
            print(f"New Index: {self.current_image_index}")

            # self.display_image(self.current_image_index)
            # Update slider to reflect the correct time for this image
            time_elapsed = self.calculate_time_elapsed(self.current_image_index)
            print(f"Time Elapsed: {time_elapsed}")
            self.timeline_slider.setValue(int(time_elapsed))  # Convert to milliseconds
            self.slider_changed(int(time_elapsed))  # Call slider_changed
        else:
            print("Reached the last image.")


if __name__ == "__main__":
    app = QApplication(sys.argv)
    viewer = ImageViewer()
    viewer.show()
    sys.exit(app.exec_())


================================================
File: /experiments/Analysis/Patch_Clamp/abf_ephys_params_calculator.py
================================================
# calculating ephys params from abfs
import numpy as np
import pyabf
import matplotlib.pyplot as plt

# convert abf to class
class data:
    def __init__(self,time,response,command,sampleRate):
        self.time = time
        self.response = response
        self.command = command
        self.sampleRate = sampleRate
        self.numSweeps = 1
        
def abf2class(abf):
    for sweepNumber in abf.sweepList:
        abf.setSweep(sweepNumber)
        if sweepNumber == 0:
            myData = data(time=abf.sweepX,response=abf.sweepY,command=abf.sweepC,sampleRate=int(1/(abf.sweepX[1]-abf.sweepX[0])))
            # print the length of the time, resposne, command arrays. print the sample rate,  and the number of sweeps.
            print("Time: ",len(myData.time))
            print("Response: ",len(myData.response))
            print("Command: ",len(myData.command))
            print("Sample Rate: ",myData.sampleRate)
            print("Number of Sweeps: ",myData.numSweeps)
        else:
            myData.response = np.vstack((myData.response,abf.sweepY))
            myData.command = np.vstack((myData.command,abf.sweepC))
            myData.numSweeps = myData.numSweeps + 1
        
    return myData


def raw_data_plot(myData):
#plot the command and response curves together in a 2 by 1 plot
    plt.figure(figsize=(8, 5))
    plt.subplot(2,1,1)
    plt.plot(myData.time,myData.command.T)
    plt.title('Command')
    plt.subplot(2,1,2)
    plt.plot(myData.time,myData.response.T)
    plt.title('Response')
    plt.show()
    

def getResponseDataSweep(d,sweepNum):
    return d.current[sweepNum,:]

def getCommandSweep(d,sweepNum):
    return d.command[sweepNum,:]

def monoExp(x, m, t, b):
    return m * np.exp(-t * x) + b

def calc_pas_params(d,filename,base_fn): # filename is the image path, base_fn is the name of the abf
    # initialize the array to save all the parameters
    n_sweeps = d.numSweeps
    print ("Calculating passive properties for ",n_sweeps," sweeps")
    n_params = 5 + 1 # for fn
    all_data = np.empty((n_sweeps, n_params))
    try:
        # voltage_data = getResponseDataSweep(d,0)
        voltage_data = d.current[0,:]
        print("ready.")
    except:
        print("Error: Could not get response data for sweep 0")
        return
    # for each sweep in the abf, find the passive properties and save to the array 
    for sweep in [1]: 
        voltage_data = getResponseDataSweep(d,sweep)
        dt = 1/d.sampleRate
        command_current = getCommandSweep(d,sweep)
        del_com = np.diff(command_current)
        starts = np.where(del_com<0)
        ends = np.where(del_com>0)
        # these should be for passive properties (ie 1st step down)
        const = 0
        passive_start = starts[0][0] + const
        passive_end = ends[0][0] - const

        mean1 = np.mean(voltage_data[0 : passive_start-1])  #calculate Rm/input_resistance
        mean2 = np.mean(voltage_data[int(passive_start + (0.1 / dt)) : passive_end])

        holding = np.mean(command_current[0: passive_start-10])
        pas_stim = np.mean(command_current[passive_start + 10 : passive_start + 110]) - holding

        input_resistance = (abs(mean1-mean2) / abs(pas_stim) ) * 1000 # Steady state delta V/delta I
        
        resting = mean1 - (input_resistance * holding) / 1000

        #plot response and command curves
        plt.figure(figsize=(8, 5))
        plt.plot(d.time, voltage_data)
        plt.plot(d.time, command_current)

        import scipy.optimize

        X1 = d.time[passive_start : int((passive_start + (0.1 / dt)))]           #calculate membrane tau
        Y1 = voltage_data[passive_start : int((passive_start + (0.1 / dt)))]

        # p0 = (100, 17, 1000)
        p0 = (6.123e12, 54.097, -48.3)
        try:
            params, cv = scipy.optimize.curve_fit(monoExp, X1[::50], Y1[::50], p0, maxfev = 100000000)
            m, t, b = params
            print("samplerate: ",sampleRate)
            sampleRate = int(1 / dt / 1000)+1
            membrane_tau =  ((1 / t) / sampleRate) * 1e6 / abs(pas_stim)
            membrane_capacitance = membrane_tau / input_resistance *1000
            print("tau: ",membrane_tau)
            print("cap: ",membrane_capacitance)
            print("step down: ",pas_stim)
        except:
            m = 0
            t = 0
            b = 0
            membrane_tau = 0
            membrane_capacitance = 0
        # find error in fit
        fit_err = np.average(abs((monoExp(d.time[passive_start:passive_end],m,t,b)-voltage_data[passive_start:passive_end])))

        if 1:
            # find limits for the y-axis
            max_lim = np.max(voltage_data[passive_start:passive_end]) + 5
            min_lim = np.min(voltage_data[passive_start:passive_end]) - 5
            
            # plot for checking fitting
            plt.plot(d.time,voltage_data)
            plt.plot(X1,Y1)
            plt.plot(d.time,monoExp(d.time, m, t, b))
            plt.scatter([d.time[passive_start],d.time[passive_end]],[voltage_data[passive_start],voltage_data[passive_end]],c='red')
            plt.ylim([min_lim,max_lim])
            plt.xlim([.4,1.1])
            plt.savefig(filename+".png")
            plt.show()
            plt.clf()

        print("Tau: ",membrane_tau)
        print("Capacitance: ",membrane_capacitance)

        # delete this
        base_fn = 111

        all_data[sweep,:] = [int(base_fn),membrane_tau, input_resistance, membrane_capacitance, resting, fit_err]
    return all_data 



abf_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Analysis\Patch_Clamp\24418016.abf"
abf  = pyabf.ABF(abf_path)
myData = abf2class(abf)
raw_data_plot(myData)
all_data = calc_pas_params(myData,abf_path,abf.abfID)
print(all_data)


================================================
File: /experiments/Analysis/Patch_Clamp/PatchAnalyzer.py
================================================
import os
import sys
import csv
import numpy as np
import pyqtgraph as pg
import logging
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget, QPushButton,
    QFileDialog, QShortcut, QHBoxLayout, QFrame, QSlider, QMessageBox,
    QSizePolicy, QComboBox, QProgressBar
)
from PyQt5.QtGui import QColor, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

# Configure logging
logging.basicConfig(
    filename='patch_analyzer.log',
    filemode='a',  # Append mode
    format='%(asctime)s - %(levelname)s - %(message)s',  # Log message format
    level=logging.INFO  # Logging level
)

# Conversion factor for CurrentProtocol command to current
C_CLAMP_AMP_PER_VOLT = 400 * 1e-12  # 400 pA / V

class DataLoaderThread(QThread):
    """Thread to load CSV data without blocking the UI."""
    progress = pyqtSignal(int)
    finished = pyqtSignal(dict)  # Emit a dictionary containing all loaded data

    def __init__(self, protocol, protocol_dir, run_groups=None):
        super().__init__()
        self.protocol = protocol
        self.protocol_dir = protocol_dir
        self.run_groups = run_groups  # Only for CurrentProtocol

    def run(self):
        loaded_data = {}
        try:
            if self.protocol == "CurrentProtocol" and self.run_groups:
                for run_number, csv_files in self.run_groups.items():
                    loaded_data[run_number] = {}
                    total_files = len(csv_files)
                    for idx, csv_file in enumerate(csv_files):
                        csv_path = os.path.join(self.protocol_dir, csv_file)
                        try:
                            with open(csv_path, 'r') as f:
                                reader = csv.reader(f, delimiter=' ')
                                time, command, response = [], [], []
                                for row in reader:
                                    if len(row) < 3:
                                        continue
                                    time.append(float(row[0]))
                                    command.append(float(row[1]) * C_CLAMP_AMP_PER_VOLT)
                                    response.append(float(row[2]))
                                loaded_data[run_number][csv_file] = {
                                    'time': np.array(time),
                                    'command': np.array(command),
                                    'response': np.array(response)
                                }
                        except Exception as e:
                            logging.error(f"Error loading {csv_file}: {e}")
                            loaded_data[run_number][csv_file] = None
                        progress_percent = int(((idx + 1) / total_files) * 100)
                        self.progress.emit(progress_percent)
            else:
                # For VoltageProtocol and HoldingProtocol
                csv_files = [f for f in os.listdir(self.protocol_dir) if f.endswith('.csv')]
                loaded_data['files'] = {}
                total_files = len(csv_files)
                for idx, csv_file in enumerate(csv_files):
                    csv_path = os.path.join(self.protocol_dir, csv_file)
                    try:
                        with open(csv_path, 'r') as f:
                            reader = csv.reader(f, delimiter=' ')
                            time, command, response = [], [], []
                            for row in reader:
                                if len(row) < 3:
                                    continue
                                time.append(float(row[0]))
                                command.append(float(row[1]))
                                response.append(float(row[2]))
                            loaded_data['files'][csv_file] = {
                                'time': np.array(time),
                                'command': np.array(command),
                                'response': np.array(response)
                            }
                    except Exception as e:
                        logging.error(f"Error loading {csv_file}: {e}")
                        loaded_data['files'][csv_file] = None
                    progress_percent = int(((idx + 1) / total_files) * 100)
                    self.progress.emit(progress_percent)
        except Exception as e:
            logging.error(f"Unexpected error during data loading: {e}")
        self.finished.emit(loaded_data)

class PatchAnalyzer(QMainWindow):

    def __init__(self):
        super().__init__()
        self.setWindowTitle('PatchAnalyzer')
        self.setGeometry(100, 100, 1200, 800)
        self.setWindowIcon(QIcon())  # Set an icon if available

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)

        self.main_layout = QVBoxLayout(self.central_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(10)

        # Configure pyqtgraph
        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')

        # Add graph frame with 2x1 grid of graphs
        self.graph_frame = QFrame()
        self.graph_frame.setFrameShape(QFrame.StyledPanel)
        self.graph_frame.setFrameShadow(QFrame.Sunken)
        self.graph_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.graph_frame.setMinimumSize(800, 400)

        # Create a layout to hold the 2x1 graphs
        self.graph_layout = QVBoxLayout(self.graph_frame)
        self.graph_layout.setContentsMargins(5, 5, 5, 5)
        self.graph_layout.setSpacing(5)

        # Create the GraphicsLayoutWidget for plotting
        self.graphics_layout = pg.GraphicsLayoutWidget()
        self.graphics_layout.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.graph_layout.addWidget(self.graphics_layout)

        # Create 2x1 grid of plots
        self.plots = [
            self.graphics_layout.addPlot(row=0, col=0, title="Command Data"),
            self.graphics_layout.addPlot(row=1, col=0, title="Response Data")
        ]

        # Set labels
        self.plots[0].setLabel('bottom', 'Time', units='s')
        self.plots[1].setLabel('bottom', 'Time', units='s')

        # Initialize plot data items for efficient updates
        self.command_plot = self.plots[0].plot([], [], pen=pg.mkPen(color='b', width=2))
        self.response_plot = self.plots[1].plot([], [], pen=pg.mkPen(color='r', width=2))

        # Set up vertical slider
        self.vertical_slider = QSlider(Qt.Vertical)
        self.vertical_slider.setTickPosition(QSlider.NoTicks)
        self.vertical_slider.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        self.vertical_slider.valueChanged.connect(self.on_slider_value_changed)
        self.vertical_slider.setMinimum(0)
        self.vertical_slider.setMaximum(0)  # Will be updated after data loading

        # Create a horizontal layout to hold the graph frame and the vertical slider
        self.horizontal_layout = QHBoxLayout()
        self.horizontal_layout.addWidget(self.graph_frame)
        self.horizontal_layout.addWidget(self.vertical_slider)

        # Add the horizontal layout to the main layout
        self.main_layout.addLayout(self.horizontal_layout)

        # Create the info frame
        self.info_frame = QFrame()
        info_frame_layout = QHBoxLayout(self.info_frame)
        info_frame_layout.setContentsMargins(5, 5, 5, 5)
        info_frame_layout.setSpacing(10)

        # Add the info label to the left
        self.info = QLabel("Information: ")
        self.info.setWordWrap(True)
        info_frame_layout.addWidget(self.info, stretch=1)

        # Add the info frame to the main layout before the buttons layout
        self.main_layout.addWidget(self.info_frame)

        # Create a single row of buttons
        self.buttons_layout = QHBoxLayout()
        self.buttons_layout.setSpacing(10)

        # Navigation buttons
        self.left_button = QPushButton("←")
        self.left_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.left_button.clicked.connect(self.show_previous_protocol)
        self.buttons_layout.addWidget(self.left_button)

        self.right_button = QPushButton("→")
        self.right_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.right_button.clicked.connect(self.show_next_protocol)
        self.buttons_layout.addWidget(self.right_button)

        # Add a small spacer between navigation and control buttons
        self.buttons_layout.addSpacing(20)

        # Control buttons
        self.prev_data_button = QPushButton("Previous timepoint")
        self.prev_data_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.prev_data_button.clicked.connect(self.show_previous_timepoint)
        self.buttons_layout.addWidget(self.prev_data_button)

        self.select_data_dir_button = QPushButton("Select Data Directory")
        self.select_data_dir_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.select_data_dir_button.clicked.connect(self.open_directory)
        self.buttons_layout.addWidget(self.select_data_dir_button)

        self.next_data_button = QPushButton("Next timepoint")
        self.next_data_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.next_data_button.clicked.connect(self.show_next_timepoint)
        self.buttons_layout.addWidget(self.next_data_button)

        self.toggle_video_button = QPushButton("Play")
        self.toggle_video_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.toggle_video_button.clicked.connect(self.toggle_video)
        self.buttons_layout.addWidget(self.toggle_video_button)

        # Add a drop-down menu for run number
        self.run_dropdown = QComboBox()
        self.run_dropdown.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.run_dropdown.currentIndexChanged.connect(self.on_run_selected)
        self.run_dropdown.setEnabled(False)  # Disabled until data is loaded
        self.buttons_layout.addWidget(self.run_dropdown)

        # Add the buttons layout to the main layout
        self.main_layout.addLayout(self.buttons_layout)

        # Progress Bar for Data Loading
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)  # Hidden by default
        self.main_layout.addWidget(self.progress_bar)

        # Keyboard shortcuts
        self.shortcut_left = QShortcut(Qt.Key_Left, self)
        self.shortcut_left.activated.connect(self.show_previous_protocol)
        self.shortcut_right = QShortcut(Qt.Key_Right, self)
        self.shortcut_right.activated.connect(self.show_next_protocol)

        # Initialize protocol variables
        self.protocols = []  # List of tuples: (protocol_name, protocol_dir)
        self.current_protocol_index = 0
        self.current_protocol_name = ""
        self.current_protocol_dir = ""
        self.current_run_number = ""
        self.current_csv_files = []  # List of CSV file names for non-CurrentProtocol
        self.current_run_files = []  # List of CSV file names for CurrentProtocol

        # Data storage
        self.loaded_data = {}  # Nested dictionary to store all loaded data

    def open_directory(self):
        """Open a directory and load all data."""
        directory = QFileDialog.getExistingDirectory(self, "Open Directory", "")
        if directory:
            logging.info(f"Selected directory: {directory}")
            self.protocols = []
            self.current_protocol_index = 0

            # Check for VoltageProtocol
            volt_dir = os.path.join(directory, 'VoltageProtocol')
            if os.path.exists(volt_dir):
                self.protocols.append(('VoltageProtocol', volt_dir))
                logging.info(f"Found VoltageProtocol at: {volt_dir}")

            # Check for HoldingProtocol
            hold_dir = os.path.join(directory, 'HoldingProtocol')
            if os.path.exists(hold_dir):
                self.protocols.append(('HoldingProtocol', hold_dir))
                logging.info(f"Found HoldingProtocol at: {hold_dir}")

            # Check for CurrentProtocol
            curr_dir = os.path.join(directory, 'CurrentProtocol')
            if os.path.exists(curr_dir):
                self.protocols.append(('CurrentProtocol', curr_dir))
                logging.info(f"Found CurrentProtocol at: {curr_dir}")

            if self.protocols:
                logging.info(f"Available protocols: {self.protocols}")
                self.load_protocol(self.protocols[self.current_protocol_index])
            else:
                self.info.setText("No valid protocols found in the selected directory.")
                logging.error("No valid protocols found in the selected directory.")

    def load_protocol(self, protocol):
        """Load all CSV data for the selected protocol."""
        protocol_name, protocol_dir = protocol
        self.current_protocol_name = protocol_name
        self.current_protocol_dir = protocol_dir
        self.loaded_data = {}  # Reset loaded data

        self.info.setText(f"Loading {protocol_name}...")
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)

        csv_files = [f for f in os.listdir(protocol_dir) if f.endswith('.csv')]
        total_files = len(csv_files)

        if protocol_name == "CurrentProtocol":
            self.vertical_slider.setEnabled(True)  # Enable the slider for CurrentProtocol
            self.run_dropdown.setEnabled(True)
            # Group CSV files by run number
            run_groups = {}
            for csv_file in csv_files:
                parts = csv_file.split('_')
                if len(parts) >= 3:
                    run_number = parts[1]
                    if run_number not in run_groups:
                        run_groups[run_number] = []
                    run_groups[run_number].append(csv_file)
            self.loaded_data['runs'] = {}
            for idx, (run_number, files) in enumerate(sorted(run_groups.items())):
                self.loaded_data['runs'][run_number] = {}
                for file_idx, csv_file in enumerate(sorted(files)):
                    csv_path = os.path.join(protocol_dir, csv_file)
                    try:
                        with open(csv_path, 'r') as f:
                            reader = csv.reader(f, delimiter=' ')
                            time, command, response = [], [], []
                            for row in reader:
                                if len(row) < 3:
                                    continue
                                time.append(float(row[0]))
                                command.append(float(row[1]) * C_CLAMP_AMP_PER_VOLT)
                                response.append(float(row[2]))
                            self.loaded_data['runs'][run_number][csv_file] = {
                                'time': np.array(time),
                                'command': np.array(command),
                                'response': np.array(response)
                            }
                    except Exception as e:
                        logging.error(f"Error loading {csv_file}: {e}")
                        self.loaded_data['runs'][run_number][csv_file] = None
                    progress_percent = int(((idx * len(files) + file_idx + 1) / total_files) * 100)
                    self.progress_bar.setValue(progress_percent)
            # Populate run dropdown
            self.run_dropdown.blockSignals(True)
            self.run_dropdown.clear()
            for run_number in sorted(self.loaded_data['runs'].keys()):
                self.run_dropdown.addItem(f"Run {run_number}")
            self.run_dropdown.setCurrentIndex(0)
            self.run_dropdown.blockSignals(False)
            self.run_dropdown.setEnabled(True)
            # Set current run
            self.current_run_number = sorted(self.loaded_data['runs'].keys())[0]
            self.current_run_files = sorted(self.loaded_data['runs'][self.current_run_number].keys())
            # Configure slider
            self.vertical_slider.setMinimum(0)
            self.vertical_slider.setMaximum(len(self.current_run_files) - 1)
            self.vertical_slider.setValue(0)
            # Plot the first file
            self.plot_current_file(0)
        else:
            # For VoltageProtocol and HoldingProtocol, disable the slider
            self.vertical_slider.setEnabled(False)  # Disable the slider
            self.run_dropdown.setEnabled(True)  # Enable the dropdown menu
            self.loaded_data['files'] = {}
            for idx, csv_file in enumerate(sorted(csv_files)):
                csv_path = os.path.join(protocol_dir, csv_file)
                try:
                    with open(csv_path, 'r') as f:
                        reader = csv.reader(f, delimiter=' ')
                        time, command, response = [], [], []
                        for row in reader:
                            if len(row) < 3:
                                continue
                            time.append(float(row[0]))
                            command.append(float(row[1]))
                            response.append(float(row[2]))
                        self.loaded_data['files'][csv_file] = {
                            'time': np.array(time),
                            'command': np.array(command),
                            'response': np.array(response)
                        }
                except Exception as e:
                    logging.error(f"Error loading {csv_file}: {e}")
                    self.loaded_data['files'][csv_file] = None
                progress_percent = int(((idx + 1) / total_files) * 100)
                self.progress_bar.setValue(progress_percent)
            # Populate run dropdown
            self.run_dropdown.blockSignals(True)
            self.run_dropdown.clear()
            for idx, csv_file in enumerate(sorted(self.loaded_data['files'].keys())):
                self.run_dropdown.addItem(f"Run {idx + 1}")
            self.run_dropdown.setCurrentIndex(0)
            self.run_dropdown.blockSignals(False)
            self.run_dropdown.setEnabled(True)
            # Set current run files
            self.current_run_files = sorted(self.loaded_data['files'].keys())
            # Plot the first file
            self.plot_csv_file(0)

        self.progress_bar.setVisible(False)
        self.info.setText(f"Loaded {protocol_name} protocol.")


    def plot_csv_file(self, index):
        """Plot data for non-CurrentProtocol protocols."""
        if not self.current_protocol_name or self.current_protocol_name == "CurrentProtocol":
            return

        if index < 0 or index >= len(self.current_run_files):
            logging.error(f"File index {index} is out of range.")
            return

        csv_file = self.current_run_files[index]
        data = self.loaded_data['files'].get(csv_file)

        if data is None:
            self.info.setText(f"No data loaded from {csv_file}.")
            logging.warning(f"No data loaded from {csv_file}.")
            return

        time = data['time']
        command = data['command']
        response = data['response']

        # Set appropriate labels based on protocol type
        if self.current_protocol_name == "VoltageProtocol":
            self.plots[0].setLabel('left', 'Command Voltage', units='V')
            self.plots[1].setLabel('left', 'Current Response', units='A')
        elif self.current_protocol_name == "HoldingProtocol":
            self.plots[0].setLabel('left', 'Command Voltage', units='V')
            self.plots[1].setLabel('left', 'Current Response', units='A')

        # Update plot data
        self.command_plot.setData(time, command)
        self.response_plot.setData(time, response)

        # Auto-scale the plots to fit the data
        self.plots[0].enableAutoRange()
        self.plots[1].enableAutoRange()

        self.info.setText(f"Loaded data from {csv_file}")
        logging.info(f"Data from {csv_file} plotted successfully.")

    def plot_current_file(self, index):
        """Plot data for CurrentProtocol."""
        if self.current_protocol_name != "CurrentProtocol":
            return

        if not self.current_run_files:
            logging.error("No run files available to plot.")
            return

        if index < 0 or index >= len(self.current_run_files):
            logging.error(f"File index {index} is out of range.")
            return

        csv_file = self.current_run_files[index]
        data = self.loaded_data['runs'][self.current_run_number].get(csv_file)

        if data is None:
            self.info.setText(f"No data loaded from {csv_file}.")
            logging.warning(f"No data loaded from {csv_file}.")
            return

        time = data['time']
        command = data['command']
        response = data['response']

        # Set labels for CurrentProtocol
        self.plots[0].setLabel('left', 'Command Current', units='A')
        self.plots[1].setLabel('left', 'Voltage Response', units='V')

        # Update plot data
        self.command_plot.setData(time, command)
        self.response_plot.setData(time, response)

        # Auto-scale the plots to fit the data
        self.plots[0].enableAutoRange()
        self.plots[1].enableAutoRange()

        self.info.setText(f"Loaded data from {csv_file}")
        logging.info(f"Data from {csv_file} plotted successfully.")

    def on_slider_value_changed(self, value):
        """Handle the slider value change event to load a specific file."""
        logging.info(f"Slider value changed: {value}")
        if self.current_protocol_name == "CurrentProtocol":
            self.plot_current_file(value)
        else:
            self.plot_csv_file(value)

    def show_previous_protocol(self):
        """Navigate to the previous protocol."""
        if not self.protocols:
            self.info.setText("No protocols loaded. Please select a data directory.")
            logging.error("No protocols loaded. Cannot navigate to previous protocol.")
            return
        self.current_protocol_index -= 1
        if self.current_protocol_index < 0:
            self.current_protocol_index = len(self.protocols) - 1
        logging.info(f"Switching to previous protocol: {self.protocols[self.current_protocol_index][0]}")
        self.load_protocol(self.protocols[self.current_protocol_index])

    def show_next_protocol(self):
        """Navigate to the next protocol."""
        if not self.protocols:
            self.info.setText("No protocols loaded. Please select a data directory.")
            logging.error("No protocols loaded. Cannot navigate to next protocol.")
            return
        self.current_protocol_index += 1
        if self.current_protocol_index >= len(self.protocols):
            self.current_protocol_index = 0
        logging.info(f"Switching to next protocol: {self.protocols[self.current_protocol_index][0]}")
        self.load_protocol(self.protocols[self.current_protocol_index])

    def show_previous_timepoint(self):
        """Navigate to the previous timepoint (not implemented)."""
        self.info.setText("Previous timepoint functionality not implemented yet.")
        logging.info("Previous timepoint button clicked.")

    def show_next_timepoint(self):
        """Navigate to the next timepoint (not implemented)."""
        self.info.setText("Next timepoint functionality not implemented yet.")
        logging.info("Next timepoint button clicked.")

    def toggle_video(self):
        """Toggle play/pause video functionality (not implemented)."""
        self.info.setText("Play/Pause video functionality not implemented yet.")
        logging.info("Toggle video button clicked.")

    def on_run_selected(self, run_index):
        """Handle run selection from the dropdown."""
        logging.info(f"Run selected: {run_index}")
        if self.current_protocol_name == "CurrentProtocol":
            # Handle CurrentProtocol run selection
            run_number = sorted(self.loaded_data['runs'].keys())[run_index]
            self.current_run_number = run_number
            self.current_run_files = sorted(self.loaded_data['runs'][run_number].keys())
            # Configure slider for CurrentProtocol
            self.vertical_slider.setMinimum(0)
            self.vertical_slider.setMaximum(len(self.current_run_files) - 1)
            self.vertical_slider.setValue(0)
            # Plot the first file of the selected run
            self.plot_current_file(0)
        else:
            # For VoltageProtocol and HoldingProtocol, load data based on run index
            self.current_run_files = sorted(self.loaded_data['files'].keys())
            if run_index < 0 or run_index >= len(self.current_run_files):
                logging.error(f"Run index {run_index} is out of range.")
                return
            # Plot the selected run (file) from the dropdown
            self.plot_csv_file(run_index)


def main():
    app = QApplication(sys.argv)
    window = PatchAnalyzer()
    window.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()


================================================
File: /experiments/Analysis/Patch_Clamp/ephys_calc_class.py
================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize

class EPhysCalc:
    def __init__(self, file_path):
        self.file_path = file_path
        self.data = None
        self.positive_peak_index = None
        self.negative_peak_index = None
        self.peak_current_index = None
        self.peak_current_time = None
        self.zero_gradient_time = None
        self.mean_highlighted_1 = None
        self.peak_value_response_current = None
        self.post_peak_current = None
        self.exp_fit_params = None

    def read_and_convert_data(self):
        # Load the CSV file into a DataFrame
        try:
            self.data = pd.read_csv(self.file_path, delim_whitespace=True, header=None)
            self.data.columns = ['Time', 'Command Voltage', 'Response Current']
            #shift the time axis to start at 0
            start = self.data['Time'].iloc[0].copy()
            # print(f"Start time: {start}")
            self.data['Time'] = self.data['Time'] - start
            #print first time index
            # print(f"First time index: {self.data['Time'].iloc[0]}")
            self.data['Time (ms)'] = self.data['Time'] * 1000  # converting seconds to milliseconds
            # print(f"First time index in ms: {self.data['Time (ms)'].iloc[0]}")
            self.data['Command Voltage (mV)'] = self.data['Command Voltage'] * 1000  # converting volts to millivolts
            self.data['Response Current (pA)'] = self.data['Response Current'] * 1e12  # converting amps to picoamps
        except Exception as e:
            print(f"Error reading the file: {e}")
            print("Please check the file format and delimiter.")

    def calculate_peaks_and_averages(self):
        # Calculate the gradient of Command Voltage using np.gradient
        X_mV = self.data['Command Voltage (mV)'].to_numpy()
        T_ms = self.data['Time (ms)'].to_numpy()
        X_dT = np.gradient(X_mV, T_ms)
        # Update the DataFrame with the new gradient values
        self.data['X_dT'] = X_dT
        # Find the positive and negative peaks of the gradient
        self.positive_peak_index = np.argmax(X_dT)
        self.negative_peak_index = np.argmin(X_dT)
        # Find the peak of the response current
        self.peak_current_index = np.argmax(self.data['Response Current (pA)'])
        self.peak_current_time = self.data.loc[self.peak_current_index, 'Time (ms)']
        # print(f"peak current time: {self.peak_current_time}")
        # Highlight the portions of the response current curve
        highlighted_response_current_1 = self.data.loc[:self.positive_peak_index, 'Response Current (pA)']
        highlighted_response_current_2 = self.data.loc[self.peak_current_index:self.negative_peak_index, 'Response Current (pA)']
        highlighted_time_2 = self.data.loc[self.peak_current_index:self.negative_peak_index, 'Time (ms)']
        # Calculate means
        self.mean_highlighted_1 = highlighted_response_current_1.mean()
        print("Mean pre peak", self.mean_highlighted_1)

        # Get the peak value on the response current plot
        self.peak_value_response_current = self.data.loc[self.peak_current_index, 'Response Current (pA)']
        # Calculate the gradient of the highlighted portion between the positive peak of the response current and the negative peak of the derivative plot
        highlighted_gradient = np.gradient(highlighted_response_current_2, highlighted_time_2)
        # Find the index where the gradient becomes close to zero
        close_to_zero_index = np.where(np.isclose(highlighted_gradient, 0, atol=1e-2))[0]
        if close_to_zero_index.size > 0:
            zero_gradient_index = close_to_zero_index[0]
            self.zero_gradient_time = highlighted_time_2.iloc[zero_gradient_index]
        else:
            self.zero_gradient_time = None
        # Calculate the mean of the data between the zero gradient time and the min time
        print(f"Zero gradient time: {self.zero_gradient_time}")
        if self.zero_gradient_time:
            post_peak_current_data = self.data[(self.data['Time (ms)'] >= self.zero_gradient_time) & (self.data['Time (ms)'] <= self.data.loc[self.negative_peak_index, 'Time (ms)'])]
            self.post_peak_current = post_peak_current_data['Response Current (pA)'].mean()
            print(f"Post peak current mean: {self.post_peak_current}")
        else:
            self.post_peak_current = None

    def monoExp(self, x, m, t, b):
        return m * np.exp(-t * x) + b

    def optimizer(self, filtered_data):
        p0 = (self.peak_value_response_current, 0.001 , self.post_peak_current)
        print(f"Initial guess: {p0}")
        try:
            cure_params, _ = scipy.optimize.curve_fit(self.monoExp, filtered_data["Time (ms)"], filtered_data['Response Current (pA)'], maxfev=1000000, p0=p0)
            m, t, b = cure_params
            return m, t, b
        except Exception as e:
            print("Error:", e)
            return None, None, None

    def fit_exponential(self):
        # Extract the data for fitting
        fit_data = self.data[(self.data['Time (ms)'] >= self.peak_current_time) & (self.data['Time (ms)'] <= self.zero_gradient_time)]
        # shift the data to start at 0 again
        start = fit_data['Time (ms)'].iloc[0]
        fit_data['Time (ms)'] = fit_data['Time (ms)'] - start
        # Fit the exponential function to the data
        m, t, b = self.optimizer(fit_data)
        self.exp_fit_params = (m, t, b)
        return self.exp_fit_params

    def plot_graphs(self):
        # Plotting the graphs with the highlighted portions on the response current plot
        plt.figure(figsize=(10, 12))
        # Top graph: Command Voltage vs Time
        plt.subplot(3, 1, 1)
        plt.plot(self.data['Time (ms)'], self.data['Command Voltage (mV)'], color='blue')
        plt.axvline(x=self.peak_current_time, color='green', linestyle='--', label='Peak Current Time')
        plt.axvline(x=self.data.loc[self.negative_peak_index, 'Time (ms)'], color='purple', linestyle='--', label='Min Time')
        if self.zero_gradient_time:
            plt.axvline(x=self.zero_gradient_time, color='cyan', linestyle='--', label='Zero Gradient Time')
        plt.xlabel('Time (ms)')
        plt.ylabel('Command Voltage (mV)')
        plt.title('Command Voltage vs Time')
        plt.legend()
        # Middle graph: Current vs Time with corrected highlighted portions and zero gradient line
        plt.subplot(3, 1, 2)
        plt.plot(self.data['Time (ms)'], self.data['Response Current (pA)'], color='red')
        highlighted_time_1 = self.data.loc[:self.positive_peak_index, 'Time (ms)']
        highlighted_response_current_1 = self.data.loc[:self.positive_peak_index, 'Response Current (pA)']
        highlighted_time_2 = self.data.loc[self.peak_current_index:self.negative_peak_index, 'Time (ms)']
        highlighted_response_current_2 = self.data.loc[self.peak_current_index:self.negative_peak_index, 'Response Current (pA)']
        plt.plot(highlighted_time_1, highlighted_response_current_1, color='blue', label='Highlighted before Positive Derivative Peak')
        plt.plot(highlighted_time_2, highlighted_response_current_2, color='yellow', label='Highlighted between Peaks')
        plt.axvline(x=self.peak_current_time, color='green', linestyle='--', label='Peak Current Time')
        plt.axvline(x=self.data.loc[self.negative_peak_index, 'Time (ms)'], color='purple', linestyle='--', label='Min Time')
        if self.zero_gradient_time:
            plt.axvline(x=self.zero_gradient_time, color='cyan', linestyle='--', label='Zero Gradient Time')
        # Plot the exponential fit
        if self.exp_fit_params is not None:
            x_fit = np.linspace(self.peak_current_time, self.zero_gradient_time, 100)
            y_fit = self.monoExp(x_fit, *self.exp_fit_params)
            plt.plot(x_fit, y_fit, 'k--', label='Exponential Fit')
        plt.xlabel('Time (ms)')
        plt.ylabel('Response Current (pA)')
        plt.title('Response Current vs Time')
        plt.legend()
        # Bottom graph: Derivative of Command Voltage vs Time
        plt.subplot(3, 1, 3)
        plt.plot(self.data['Time (ms)'], self.data['X_dT'], color='orange')
        plt.axvline(x=self.peak_current_time, color='green', linestyle='--', label='Peak Current Time')
        plt.axvline(x=self.data.loc[self.negative_peak_index, 'Time (ms)'], color='purple', linestyle='--', label='Min Time')
        if self.zero_gradient_time:
            plt.axvline(x=self.zero_gradient_time, color='cyan', linestyle='--', label='Zero Gradient Time')
        plt.xlabel('Time (ms)')
        plt.ylabel('d(Command Voltage)/dT (mV/ms)')
        plt.title('Derivative of Command Voltage vs Time')
        plt.legend()
        # Adjust layout
        plt.tight_layout()
        # Show the plots
        plt.show()

    def fit_plotter(self):
        if self.exp_fit_params is None:
            print("Exponential fit parameters not found. Please run fit_exponential() first.")
            return

        # Extract the data for fitting
        fit_data = self.data[(self.data['Time (ms)'] >= self.peak_current_time) & (self.data['Time (ms)'] <= self.zero_gradient_time)]
        # shift the data to start at 0 again
        start = fit_data['Time (ms)'].iloc[0]
        fit_data['Time (ms)'] = fit_data['Time (ms)'] - start

        # Plot the extracted data
        plt.figure(figsize=(10, 6))
        plt.plot(fit_data['Time (ms)'], fit_data['Response Current (pA)'], 'o', label='Extracted Data')

        # Plot the exponential fit
        x_fit = fit_data['Time (ms)']
        y_fit = self.monoExp(x_fit, *self.exp_fit_params)
        plt.plot(x_fit, y_fit, 'r-', label='Exponential Fit')

        plt.xlabel('Time (ms)')
        plt.ylabel('Response Current (pA)')
        plt.title('Exponential Fit of Extracted Data')
        plt.legend()
        plt.show()

    def calc_param(self):
        tau = (1/self.exp_fit_params[1])
        I_peak = self.peak_value_response_current
        I_prev = self.mean_highlighted_1
        I_ss = self.post_peak_current
        I_d = I_peak - I_prev
        I_dss = I_ss - I_prev
        
        dmV = self.data.loc[self.positive_peak_index:self.negative_peak_index, 'Command Voltage (mV)'].mean()
        print(f"tau (ms): {tau}, dmV: {dmV}, I_peak (pA): {I_peak}, I_prev (pA): {I_prev}, I_ss (pA): {I_ss}")
        print(f"I_d (pA): {I_d}, I_dss (pA): {I_dss}")
        #calculate access resistance:
        R_a = ((dmV*1e-3) / (I_d*1e-12))*1e-6 # 10 mV / 800 pA = 12.5 MOhms --> supposed to be 10 MOhms
        #calculate membrane resistance:
        R_m = (((dmV*1e-3)- R_a*1e6*I_dss*1e-12)/(I_dss*1e-12))*1e-6 #530 Mohms --> supposed to be 500 MOhms   
        #calculate membrane capacitance:
        C_m = ((tau*1e-3)/(1/(1/(R_a*1e6) + 1/(R_m*1e6))))*1e12 # 250 pF --> supposed to be 33 pF
        print(f"Access Resistance (MOhms): {R_a}, Membrane Resistance (MOhms): {R_m}, Membrane Capacitance (pF): {C_m}")


# Example usage:
# file_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\patch_clamp_data\2024_07_29-15_28\VoltageProtocol_1722281294.358729_1_k.csv"
# file_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\patch_clamp_data\2024_07_25-17_02\VoltageProtocol_1721941384.317241_1_k.csv"
# file_path = r"C:\Users\sa-forest\Documents\GitHub\holypipette-pbl\experiments\Data\patch_clamp_data\2024_07_31-13_47\VoltageProtocol_1722448205.583876_2_k.csv"
file_path = r"C:\Users\sa-forest\OneDrive - Georgia Institute of Technology\Documents\Grad-school\Gatech\Fall2024\ForestLab\AD\9-30_pres_data\VoltageProtocol\VoltageProtocol_1_k.csv"

ephys_calc = EPhysCalc(file_path)
ephys_calc.read_and_convert_data()
ephys_calc.calculate_peaks_and_averages()
ephys_calc.plot_graphs()
ephys_calc.fit_exponential()
ephys_calc.fit_plotter()
ephys_calc.calc_param()
# Print the calculated values
print("Mean of the first highlighted portion (before positive derivative peak):", ephys_calc.mean_highlighted_1)
print("Peak value of the response current:", ephys_calc.peak_value_response_current)
print("Post peak current mean (between zero gradient time and min time):", ephys_calc.post_peak_current)
print("Exponential fit parameters (m, t, b):", ephys_calc.exp_fit_params)



================================================
File: /experiments/Analysis/Patch_Clamp/ephys_params_calculator.py
================================================
import pandas as pd
import numpy as np
import scipy.optimize

# Step 1: Read in the data
def read_data(file_path):
    data = pd.read_csv(file_path, sep='\t', header=None, names=['Color', 'X', 'Y'])
    # Cleaning the data by splitting and removing unnecessary spaces
    data[['Color', 'X', 'Y']] = data['Color'].str.split(expand=True)
    data.dropna(inplace=True)
    data.sort_values(by='X', inplace=True)
    data['X'] = pd.to_numeric(data['X'], errors='coerce')
    # Shift all the X values by the value of the first X value
    data['X'] = data['X'] - data['X'].iloc[0]
    data['Y'] = pd.to_numeric(data['Y'], errors='coerce')
    # Convert X to ms and Y to pA
    data['X_ms'] = data['X'] * 1000  # converting seconds to milliseconds
    data['Y_pA'] = data['Y'] * 1e12 # converting picoamps / amps

    return data

def filter_data(data):
    # Decay filter part
    peak_index = data['Y_pA'].idxmax()
    peak_time = data.loc[peak_index, 'X_ms']

    min_index = data['Y_pA'].idxmin()
    min_time = data.loc[min_index, 'X_ms']

    # Extract the data between peaks
    sub_data = data[(data['X_ms'] >= peak_time) & (data['X_ms'] <= min_time)].copy()
    # Calculate the first numerical derivative
    sub_data['Y_derivative'] = sub_data['Y_pA'].diff() / sub_data['X_ms'].diff()
    # Remove the section with sudden changes
    change_threshold = sub_data['Y_derivative'].quantile(0.01)
    drop_indices = sub_data[sub_data['Y_derivative'] < change_threshold].index
    if not drop_indices.empty:
        drop_index = drop_indices[0]
        filtered_sub_data = sub_data.loc[:drop_index - 1]

    # Pre-peak filter part
    peak_value = data.loc[peak_index, 'Y_pA']
    pre_peak_data = data[data['X_ms'] < peak_time].copy()
    std = pre_peak_data['Y_pA'].std()
    pre_peak_data = pre_peak_data[pre_peak_data['Y_pA'] < peak_value - 3 * std]
    mean_filtered_pre_peak = pre_peak_data['Y_pA'].mean()

    # Post-peak filter part
    post_peak_data = filtered_sub_data.copy()
    post_peak_data['Y_derivative'] = post_peak_data['Y_pA'].diff() / post_peak_data['X_ms'].diff()
    std = post_peak_data['Y_pA'].std()
    post_peak_data = post_peak_data[post_peak_data['Y_pA'] < peak_value - 3 * std]
    mean_filtered_post_peak = post_peak_data['Y_pA'].mean()

    return filtered_sub_data, pre_peak_data, post_peak_data, [peak_time, peak_index, min_time, min_index], mean_filtered_pre_peak, mean_filtered_post_peak

def monoExp(x, m, t, b):
    return m * np.exp(-t * x) + b

def optimizer(filtered_data):
    start = filtered_data['X_ms'].iloc[0]
    # Shift the data to start at 0
    filtered_data['X_ms'] = filtered_data['X_ms'] - start
    p0 = (664, 0.24, 15)
    try:
        params, _ = scipy.optimize.curve_fit(monoExp, filtered_data['X_ms'], filtered_data['Y_pA'], maxfev=1000000, p0=p0)
        m, t, b = params
        return m, t, b
    except Exception as e:
        print("Error:", e)
        return None, None, None

def calc_param(tau, dV, I_peak, I_prev, I_ss):
    tau_s = tau / 1000  # Convert ms to seconds
    dV_V = dV * 1e-3  # Convert mV to V
    I_d = I_peak - I_prev  # in pA
    I_dss = I_ss - I_prev  # in pA
    I_d_A = I_d * 1e-12
    I_dss_A = I_dss * 1e-12

    # Calculate Access Resistance (R_a) in ohms
    R_a_Ohms = dV_V / I_d_A  # Ohms
    R_a_MOhms = R_a_Ohms * 1e-6  # Convert to MOhms

    # Calculate Membrane Resistance (R_m) in ohms
    R_m_Ohms = (dV_V - (R_a_Ohms * I_dss_A)) / I_dss_A  # Ohms
    R_m_MOhms = R_m_Ohms * 1e-6  # Convert to MOhms

    # Calculate Membrane Capacitance (C_m) in farads
    C_m_F = tau_s / (1/(1 / R_a_Ohms) + (1 / R_m_Ohms))  # Farads
    C_m_pF = C_m_F * 1e12  # Convert to pF

    return R_a_MOhms, R_m_MOhms, C_m_pF

# Assuming file_path and initial parameters are provided
file_path = r"C:\Users\sa-forest\Downloads\VoltageProtocol_0_1719874436.622976.csv"

# Read the data
data = read_data(file_path)

# Filter the data
filtered_data, pre_filtered_data, post_filtered_data, plot_params, I_prev, I_post = filter_data(data)
peak_time, peak_index, min_time, min_index = plot_params

# Optimize parameters
m, t, b = optimizer(filtered_data)
if m is not None and t is not None and b is not None:
    tau = 1 / t

    # Get peak current using peak_index
    I_peak = data.loc[peak_index, 'Y_pA']

    # Calculate parameters
    R_a_MOhms, R_m_MOhms, C_m_pF = calc_param(tau, 5, I_peak, I_prev, I_post)

    # Print the results
    # print(f"Access Resistance (R_a): {R_a_MOhms:.2f} MOhms")
    # print(f"Membrane Resistance (R_m): {R_m_MOhms:.2f} MOhms")
    # print(f"Membrane Capacitance (C_m): {C_m_pF:.2f} pF")
else:
    print("Failed to optimize parameters.")

================================================
File: /experiments/Analysis/Patch_Clamp/duplicateremover.py
================================================
import os
import pandas as pd

# Define the folder containing the CSV files
folder_path = r"C:\Users\sa-forest\OneDrive - Georgia Institute of Technology\Documents\Grad-school\Gatech\Fall2024\ForestLab\AD\9-30_pres_data\CurrentProtocol"

# Iterate through all files in the folder
for file_name in os.listdir(folder_path):
    # Check if the file starts with "CurrentProtocol" and has a .csv extension
    if file_name.startswith("CurrentProtocol") and file_name.endswith(".csv"):
        file_path = os.path.join(folder_path, file_name)

        # Load the CSV file
        data = pd.read_csv(file_path, delimiter=r"\s+")

        # Rename columns for clarity
        data.columns = ['Time', 'CommandVoltage', 'Current']

        # Remove duplicate rows
        data_cleaned = data.drop_duplicates()
        # make sure to sort the data by time
        data_cleaned = data_cleaned.sort_values(by='Time')

        # Adjust the first timepoint to be 0.0 (optional, can be commented out if not needed)
        # data_cleaned['Time'] = data_cleaned['Time'] - data_cleaned['Time'].iloc[0]

        # Filter data to keep only rows where Time is <= 2.2 seconds (optional, can be commented out if not needed)
        # data_cleaned = data_cleaned[data_cleaned['Time'] <= 2.2]

        
        

        # Save the cleaned data in the same format it was read
        data_cleaned.to_csv(file_path, sep=' ', index=False, header=False)

        # Output the cleaned file path
        print(f"Cleaned file saved to: {file_path}")

================================================
File: /experiments/Analysis/Patch_Clamp/CprotAnalyzer.py
================================================
#CprotAnalyzer.py
import pandas as pd
import numpy as np
import scipy.optimize
import matplotlib.pyplot as plt

class CurrentProtocolAnalyzer:
    def __init__(self, file_path):
        self.file_path = file_path
        self.data = None
        self.holding_current = None
        self.latestAccessResistance = None
        self.latestMembraneResistance = None
        self.latestMembraneCapacitance = None
        self.totalResistance = None
   

    def read_and_convert_data(self):
        """
        Load the CSV file into a DataFrame and convert the necessary units.
        """
        try:
            self.data = pd.read_csv(self.file_path, sep='\s+', header=None)
            self.data.columns = ['Time', 'Command Current', 'Response Voltage']
            # Shift the time axis to start at 0
            start = self.data['Time'].iloc[0]
            self.data['Time'] = self.data['Time'] - start
            # Convert units
            self.data['Time (ms)'] = self.data['Time'] * 1000  # converting seconds to milliseconds
            self.data['Command Current (pA)'] = self.data['Command Current'] * 400 # converting volts to pico amps with conversion factor of 400 (1V = 400 pA)
            self.data['Response Voltage (mV)'] = self.data['Response Voltage'] * 1000  # converting volts to millivolts with conversion factor of 1000
        except Exception as e:
            print(f"Error reading the file: {e}")
            print("Please check the file format and delimiter.") 

    def filter_data(self):
        """
        Filter the data to extract key parameters from the response current.
        """
        if self.data is None:
            raise ValueError("Data has not been loaded. Please run read_and_convert_data() first.")

        X_pA = self.data['Command Current (pA)'].to_numpy()
        T_ms = self.data['Time (ms)'].to_numpy()
        Y_mV = self.data['Response Voltage (mV)'].to_numpy()
        X_dT = np.gradient(X_pA, T_ms)
        self.data["X_dT"] = X_dT

        cutoff_time = 700 # ms
        cutoff_index = np.where(T_ms > cutoff_time)[0][0]
        print(f"Cut off index: {cutoff_index}")
        print(f"Cut off time: {T_ms[cutoff_index]}")


                # Split the data into two parts
        X_dT_before_cutoff = X_dT[:cutoff_index]
        X_dT_after_cutoff = X_dT[cutoff_index:]


        memtest_negative_peak_index = np.argmin(X_dT_before_cutoff)
        memtest_positive_peak_index = np.argmax(X_dT_before_cutoff)
        memtest_negative_peak_current_dT = X_dT[memtest_negative_peak_index]
        memtest_positive_peak_current_dT = X_dT[memtest_positive_peak_index]

        memtest_negative_peak_current = X_pA[memtest_negative_peak_index +1]
        memtest_positive_peak_current = X_pA[memtest_positive_peak_index + 1]
        # print(f"Memtest negative peak current: {memtest_negative_peak_current} pA")
        # print(f"Memtest positive peak current: {memtest_positive_peak_current} pA")
        # print(f"Memtest negative peak current derivative: {memtest_negative_peak_current_dT} pA")
        # print(f"Memtest positive peak current derivative: {memtest_positive_peak_current_dT} pA")
        stim_positive_peak_index = np.argmax(X_dT_after_cutoff)
        stim_negative_peak_index = np.argmin(X_dT_after_cutoff)
        stim_positive_peak_time = T_ms[stim_positive_peak_index + cutoff_index]
        stim_negative_peak_time = T_ms[stim_negative_peak_index + cutoff_index]
        stim_positive_peak_current_dT = X_dT_after_cutoff[stim_positive_peak_index + cutoff_index]
        stim_negative_peak_current_dT = X_dT_after_cutoff[stim_negative_peak_index  + cutoff_index]
        stim_positive_peak_current = X_pA[stim_positive_peak_index+ cutoff_index + 1]
        stim_negative_peak_current = X_pA[stim_negative_peak_index + cutoff_index + 1]
        # print(f"Stim negative peak current: {stim_negative_peak_current} pA")
        # print(f"Stim positive peak current: {stim_positive_peak_current} pA")
        # print(f"Stim negative peak time: {stim_negative_peak_time} ms")
        # print(f"Stim positive peak time: {stim_positive_peak_time} ms")
        # print(f"Stim negative peak current derivative: {stim_negative_peak_current_dT} pA")
        # print(f"Stim positive peak current derivative: {stim_positive_peak_current_dT} pA")

        # get data between membrane test peaks
        memtest_data = self.data.loc[:cutoff_index, :]
        # get data between stimulus peaks
        stim_data = self.data.loc[cutoff_index:, :]
        return 

    def firing_frequency_analysis(self):
        """
        assess action poential frequency
        """
        if self.data is None:
            raise ValueError("Data has not been loaded. Please run read_and_convert_data() first.")
        return None
    

    def monoExp(self, x, m, t, b):
            return m * np.exp(-t * x) + b
    def  analyze_current_protocol(self):
        """
        Analyze the current protocol data to extract key parameters.
        """
        self.read_and_convert_data()


        return None
    
    def plot_data(self):
        """
        Plot the command data and response data.
        """
        if self.data is None:
            raise ValueError("Data has not been loaded. Please run read_and_convert_data() first.")

        time = self.data['Time (ms)']
        command = self.data['Command Current (pA)']
        command_dT = self.data['X_dT']
        response = self.data['Response Voltage (mV)']

        plt.figure(figsize=(10, 6))

        # Plot Command Voltage
        plt.subplot(2, 1, 1)
        plt.plot(time, command, label='Command Current (pA)', color='b')
        plt.xlabel('Time (ms)')
        plt.ylabel('Command Current (pA)')
        plt.title('Command Current vs Time')
        plt.grid(True)
        plt.legend()

        # Plot Response Current
        plt.subplot(2, 1, 2)
        plt.plot(time, response, label='Response Voltage (mV)', color='r')
        plt.xlabel('Time (ms)')
        plt.ylabel('Response Voltage (mV)')
        plt.title('Response Voltage vs Time')
        plt.grid(True)
        plt.legend()

        plt.tight_layout()
        plt.show()   

example_file_path = r"C:\Users\sa-forest\OneDrive - Georgia Institute of Technology\Documents\Grad-school\Gatech\Fall2024\ForestLab\AD\9-30_pres_data\CurrentProtocol\CurrentProtocol_3_#dde4e8_60.0.csv"
if __name__ == "__main__":
    analyzer = CurrentProtocolAnalyzer(example_file_path)
    # results = analyzer.analyze_voltage_protocol()
    # print(results)
    analyzer.read_and_convert_data()
    analyzer.filter_data()
    analyzer.plot_data()


================================================
File: /experiments/Analysis/Patch_Clamp/VprotAnalyzer.py
================================================
# vprotAnalyzer.py
import pandas as pd
import numpy as np
import scipy.optimize
import matplotlib.pyplot as plt

class VoltageProtocolAnalyzer:
    def __init__(self, file_path):
        self.file_path = file_path
        self.data = None
        self.holding_current = None
        self.latestAccessResistance = None
        self.latestMembraneResistance = None
        self.latestMembraneCapacitance = None
        self.totalResistance = None

    def read_and_convert_data(self):
        """
        Load the CSV file into a DataFrame and convert the necessary units.
        """
        try:
            self.data = pd.read_csv(self.file_path, delim_whitespace=True, header=None)
            self.data.columns = ['Time', 'Command Voltage', 'Response Current']
            # Shift the time axis to start at 0
            start = self.data['Time'].iloc[0]
            self.data['Time'] = self.data['Time'] - start
            # Convert units
            self.data['Time (ms)'] = self.data['Time'] * 1000  # converting seconds to milliseconds
            self.data['Command Voltage (mV)'] = self.data['Command Voltage'] * 1000  # converting volts to millivolts
            self.data['Response Current (pA)'] = self.data['Response Current'] * 1e12  # converting amps to picoamps
        except Exception as e:
            print(f"Error reading the file: {e}")
            print("Please check the file format and delimiter.")

    def filter_data(self):
        """
        Filter the data to extract key parameters from the response current.
        """
        if self.data is None:
            raise ValueError("Data has not been loaded. Please run read_and_convert_data() first.")

        X_mV = self.data['Command Voltage (mV)'].to_numpy()
        T_ms = self.data['Time (ms)'].to_numpy()
        Y_pA = self.data['Response Current (pA)'].to_numpy()
        X_dT = np.gradient(X_mV, T_ms)
        self.data["X_dT"] = X_dT

        # Find the index of the maximum and minimum values
        positive_peak_index = np.argmax(X_dT)
        negative_peak_index = np.argmin(X_dT)
        peak_current_index = np.argmax(Y_pA)
        peak_time = self.data.loc[peak_current_index, 'Time (ms)']
        negative_peak_time = self.data.loc[negative_peak_index, 'Time (ms)']

        # Extract the data between peaks
        pre_peak_current = self.data.loc[:positive_peak_index, "Response Current (pA)"]
        sub_data = self.data.loc[peak_current_index:negative_peak_index, "Response Current (pA)"]
        sub_time = self.data.loc[peak_current_index:negative_peak_index, "Time (ms)"]
        sub_command = self.data.loc[peak_current_index:negative_peak_index, "Command Voltage (mV)"]

        # Calculate the mean current prior to the voltage pulse (I_prev)
        mean_pre_peak = pre_peak_current.mean()

        # Calculate the mean current post voltage pulse (I_ss)
        gradient = np.gradient(sub_data, sub_time)
        close_to_zero_index = np.where(np.isclose(gradient, 0, atol=1e-2))[0]
        zero_gradient_time = None
        if close_to_zero_index.size > 0:
            zero_gradient_index = close_to_zero_index[0]
            zero_gradient_time = sub_time.iloc[zero_gradient_index]

        if zero_gradient_time:
            post_peak_current_data = self.data[(self.data['Time (ms)'] >= zero_gradient_time) & (self.data['Time (ms)'] <= negative_peak_time)]
            mean_post_peak = post_peak_current_data['Response Current (pA)'].mean()
        else:
            mean_post_peak = None

        return sub_data, sub_time, sub_command, [peak_time, peak_current_index, negative_peak_time, negative_peak_index], mean_pre_peak, mean_post_peak

    def monoExp(self, x, m, t, b):
        return m * np.exp(-t * x) + b

    def optimizer(self, fit_data, I_peak_pA, I_peak_time, I_ss):
        start = fit_data['Time (ms)'].iloc[0]
        fit_data['Time (ms)'] = fit_data['Time (ms)'] - start
        p0 = (I_peak_pA, I_peak_time, I_ss)
        try:
            params, _ = scipy.optimize.curve_fit(self.monoExp, fit_data['Time (ms)'], fit_data['Response Current (pA)'], maxfev=1000000, p0=p0)
            m, t, b = params
            return m, t, b
        except Exception as e:
            print(f"Error in the optimizer: {e}")
            return None, None, None

    def calc_param(self, tau, mean_voltage, I_peak, I_prev, I_ss):
        I_d = I_peak - I_prev  # in pA
        I_dss = I_ss - I_prev  # in pA

        R_a_Mohms = ((mean_voltage * 1e-3) / (I_d * 1e-12)) * 1e-6
        R_m_Mohms = (((mean_voltage * 1e-3) - R_a_Mohms * 1e6 * I_dss * 1e-12) / (I_dss * 1e-12)) * 1e-6
        C_m_pF = (tau * 1e-3) / (1 / (1 / (R_a_Mohms * 1e6) + 1 / (R_m_Mohms * 1e6))) * 1e12

        return R_a_Mohms, R_m_Mohms, C_m_pF

    def analyze_voltage_protocol(self):
        self.read_and_convert_data()
        filtered_data, filtered_time, filtered_command, plot_params, I_prev_pA, I_post_pA = self.filter_data()
        I_peak_pA = self.data.loc[plot_params[1] + 1, 'Response Current (pA)']
        I_peak_time = self.data.loc[plot_params[1] + 1, 'Time (ms)']
        mean_voltage = filtered_command.mean()

        m, t, b = self.optimizer(pd.DataFrame({'Time (ms)': filtered_time, 'Command Voltage (mV)': filtered_command, 'Response Current (pA)': filtered_data}), I_peak_pA, I_peak_time, I_post_pA)
        if m is not None and t is not None and b is not None:
            tau = 1 / t
            R_a_MOhms, R_m_MOhms, C_m_pF = self.calc_param(tau, mean_voltage, I_peak_pA, I_prev_pA, I_post_pA)
            self.latestAccessResistance = R_a_MOhms
            print(f"Access Resistance: {R_a_MOhms} MOhms")
            self.latestMembraneResistance = R_m_MOhms
            print(f"Membrane Resistance: {R_m_MOhms} MOhms")
            self.latestMembraneCapacitance = C_m_pF
            print(f"Membrane Capacitance: {C_m_pF} pF")
            self.totalResistance = R_a_MOhms + R_m_MOhms
            print(f"Total Resistance: {self.totalResistance} MOhms")
            return R_a_MOhms, R_m_MOhms, C_m_pF, self.totalResistance
        else:
            return None, None, None, None

    def plot_data(self):
        """
        Plot the command data and response data.
        """
        if self.data is None:
            raise ValueError("Data has not been loaded. Please run read_and_convert_data() first.")

        time = self.data['Time (ms)']
        command = self.data['Command Voltage (mV)']
        response = self.data['Response Current (pA)']

        plt.figure(figsize=(10, 6))

        # Plot Command Voltage
        plt.subplot(2, 1, 1)
        plt.plot(time, command, label='Command Voltage (mV)', color='b')
        plt.xlabel('Time (ms)')
        plt.ylabel('Command Voltage (mV)')
        plt.title('Command Voltage vs Time')
        plt.grid(True)
        plt.legend()

        # Plot Response Current
        plt.subplot(2, 1, 2)
        plt.plot(time, response, label='Response Current (pA)', color='r')
        plt.xlabel('Time (ms)')
        plt.ylabel('Response Current (pA)')
        plt.title('Response Current vs Time')
        plt.grid(True)
        plt.legend()

        plt.tight_layout()
        plt.show()

# Usage
example_file_path = r"C:\Users\sa-forest\OneDrive - Georgia Institute of Technology\Documents\Grad-school\Gatech\Fall2024\ForestLab\AD\9-30_pres_data\VoltageProtocol\VoltageProtocol_1_k.csv"
if __name__ == "__main__":
    analyzer = VoltageProtocolAnalyzer(example_file_path)
    results = analyzer.analyze_voltage_protocol()
    print(results)
    analyzer.plot_data()


================================================
File: /experiments/Analysis/Timeline.py
================================================
import os
import csv
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QFileDialog, QMessageBox, QShortcut
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QKeySequence
from PIL import Image
import time
from collections import deque
import numpy as np

class DataVisualizer(QMainWindow):
    def __init__(self):
        super().__init__()
        self.graphs = {}
        self.images = {}
        self.current_timestamp = None
        self.setup_ui()
        self.setup_shortcuts()

    def setup_ui(self):
        self.setWindowTitle("Data Visualizer")
        self.setGeometry(100, 100, 1200, 800)

        main_widget = QWidget()
        main_layout = QHBoxLayout()
        
        # Sidebar
        sidebar = QWidget()
        sidebar_layout = QVBoxLayout()
        
        self.load_button = QPushButton("Load Data")
        self.load_button.clicked.connect(self.load_data)
        sidebar_layout.addWidget(self.load_button)
        
        self.prev_button = QPushButton("Previous")
        self.prev_button.clicked.connect(self.show_previous)
        sidebar_layout.addWidget(self.prev_button)
        
        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.show_next)
        sidebar_layout.addWidget(self.next_button)
        
        self.timestamp_label = QLabel("")
        sidebar_layout.addWidget(self.timestamp_label)
        
        self.filename_label = QLabel("")
        sidebar_layout.addWidget(self.filename_label)
        
        sidebar_layout.addStretch()
        sidebar.setLayout(sidebar_layout)
        sidebar.setFixedWidth(200)
        
        main_layout.addWidget(sidebar)
        
        # Matplotlib figure
        self.figure, self.ax = plt.subplots(2, 2, figsize=(10, 8))
        self.canvas = FigureCanvas(self.figure)
        main_layout.addWidget(self.canvas)
        
        main_widget.setLayout(main_layout)
        self.setCentralWidget(main_widget)

    def setup_shortcuts(self):
        # Create shortcuts for next and previous
        self.shortcut_next = QShortcut(QKeySequence(Qt.Key_Right), self)
        self.shortcut_next.activated.connect(self.show_next)

        self.shortcut_prev = QShortcut(QKeySequence(Qt.Key_Left), self)
        self.shortcut_prev.activated.connect(self.show_previous)

    def load_data(self):
        graph_dir = QFileDialog.getExistingDirectory(self, "Select Graph Directory")
        image_dir = QFileDialog.getExistingDirectory(self, "Select Image Directory")
        self.load_graphs(graph_dir)
        self.load_images(image_dir)
        if self.graphs and self.images:
            graph_timestamps = list(self.graphs.keys())
            image_timestamps = list(self.images.keys())
            
            valid_timestamps = graph_timestamps + image_timestamps
            
            if valid_timestamps:
                self.current_timestamp = min(valid_timestamps)
            else:
                QMessageBox.critical(self, "Error", "No valid timestamps found in the data")
                self.current_timestamp = None
            self.update_display()
        else:
            QMessageBox.critical(self, "Error", "No data loaded")

    def load_graphs(self, directory):
        pressure_deque = deque(maxlen=100)
        resistance_deque = deque(maxlen=100)
        for filename in os.listdir(directory):
            if filename == "graph_recording.csv":
                filepath = os.path.join(directory, filename)
                with open(filepath, 'r') as file:
                    reader = csv.reader(file)
                    for row in reader:
                        joined_row = ''.join(row)
                        timestamp_str = joined_row.split("pressure:")[0].replace("timestamp:", "").strip()
                        timestamp = float(timestamp_str)
                        
                        if timestamp not in self.graphs:
                            self.graphs[timestamp] = {}
                        
                        # Extract pressure
                        pressure_val = float(joined_row.split('pressure:')[1].split('resistance', 1)[0].strip())
                        pressure_deque.append(pressure_val)
                        self.graphs[timestamp]['pressure_deque'] = pressure_deque.copy()
                        
                        # Extract resistance
                        resistance_vals = joined_row.split('resistance:')[1].split('current:')[0].replace("[","").replace("]","")
                        resistance_val = float(resistance_vals.strip().split()[0])  # Take the first value
                        resistance_deque.append(resistance_val)
                        self.graphs[timestamp]['resistance_deque'] = resistance_deque.copy()
                        
                        # Extract time and current
                        current_vals = joined_row.split('current:')[1].split('voltage:')[0]
                        current_vals_list = [float(val.strip(']')) for val in current_vals.strip('[').split()]
                        self.graphs[timestamp]['current'] = current_vals_list
                        self.graphs[timestamp]['time'] = np.linspace(0, len(current_vals_list) - 1, len(current_vals_list))

                        # Extract voltage
                        voltage_vals = joined_row.split('voltage:')[1]
                        voltage_vals_list = [float(val.strip(']')) for val in voltage_vals.strip('[').split()]
                        self.graphs[timestamp]['voltage'] = voltage_vals_list

    def load_images(self, directory):
        for filename in os.listdir(directory):
            if filename.endswith(('.png', '.jpg', '.jpeg', '.webp')):
                frame_number, timestamp_with_ext = filename.split('_')
                timestamp = float(timestamp_with_ext.rsplit('.', 1)[0])
                self.images[timestamp] = os.path.join(directory, filename)

    def find_closest_timestamp(self, target, data):
        return min(data.keys(), key=lambda x: abs(x - target))

    def update_display(self):
        for ax in self.ax.flat:
            ax.clear()

        # Display graphs
        graph_timestamp = self.find_closest_timestamp(self.current_timestamp, self.graphs)
        graph_data = self.graphs[graph_timestamp]
        
        # Pressure plot
        indices = list(range(len(graph_data['pressure_deque'])))
        self.ax[0, 0].plot(indices, list(graph_data['pressure_deque']))
        self.ax[0, 0].set_xlabel('Index')
        self.ax[0, 0].set_ylabel('Pressure')
        self.ax[0, 0].set_title('Pressure Plot')
        
        # Resistance plot
        resistance_indices = list(range(len(graph_data['resistance_deque'])))
        self.ax[0, 1].plot(resistance_indices, list(graph_data['resistance_deque']))
        self.ax[0, 1].set_title('Resistance')
        self.ax[0, 1].set_ylabel('Resistance')
        
        # Current plot
        self.ax[1, 0].plot(graph_data['time'], graph_data['current'])
        self.ax[1, 0].set_title('Current vs Time')
        self.ax[1, 0].set_xlabel('Time')
        self.ax[1, 0].set_ylabel('Current')
        
        # Display image
        image_timestamp = self.find_closest_timestamp(self.current_timestamp, self.images)
        img = Image.open(self.images[image_timestamp])
        self.ax[1, 1].imshow(img)
        self.ax[1, 1].set_title(f"Image at {image_timestamp}")
        self.ax[1, 1].axis('off')
        
        self.figure.tight_layout()
        self.canvas.draw()
        
        # Update labels with timestamp and filename
        self.timestamp_label.setText(f"Current Timestamp: {time.ctime(self.current_timestamp)}\n(UNIX: {self.current_timestamp})")
        self.filename_label.setText(f"File: {os.path.basename(self.images[image_timestamp])}")

    def show_previous(self):
        if self.current_timestamp:
            all_timestamps = sorted(set(self.graphs.keys()) | set(self.images.keys()))
            current_index = all_timestamps.index(self.current_timestamp)
            if current_index > 0:
                self.current_timestamp = all_timestamps[current_index - 1]
                self.update_display()

    def show_next(self):
        if self.current_timestamp:
            all_timestamps = sorted(set(self.graphs.keys()) | set(self.images.keys()))
            current_index = all_timestamps.index(self.current_timestamp)
            if current_index < len(all_timestamps) - 1:
                self.current_timestamp = all_timestamps[current_index + 1]
                self.update_display()

if __name__ == "__main__":
    app = QApplication([])
    visualizer = DataVisualizer()
    visualizer.show()
    app.exec_()

================================================
File: /setup/setup_Moscow_usbDAQ.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
import serial
from holypipette.devices.amplifier.multiclamp import MultiClampChannel
from holypipette.devices.amplifier.amplifier import FakeAmplifier
from holypipette.devices.amplifier.DAQ import FakeDAQ, DAQ
from holypipette.devices.camera.pcocamera import PcoCamera
# from holypipette.devices.camera.qimagingcam import QImagingCam
from holypipette.devices.pressurecontroller import IBBPressureController, FakePressureController, TestPressureController, MoscowPressureController
from holypipette.devices.camera.camera import FakeCamera
from holypipette.devices.camera import FakeCalCamera, FakePipetteManipulator
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip


controllerSerial = serial.Serial('COM6')
controller = ScientificaSerialNoEncoder(controllerSerial)

pipetteSerial = serial.Serial('COM3')
pipetteManip = ScientificaSerialNoEncoder(pipetteSerial)
stage = ManipulatorUnit(controller, [1, 2])

# controller = FakeManipulator(min=[-240000, 50000, 280000],
#                              max=[-230000, 60000, 290000])
# pipetteManip = FakeManipulator(min=[0, 0, 0],
#                                       max=[4000, 20000, 20000])
# stage = ManipulatorUnit(controller, [1, 2])

cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()

# pipetteManip.x = [200, 300, 400] # start with pipette in frame
# controller.x = [-235000, 55000, 285000]
camera = PcoCamera()
# camera = moscowQCamera()
# camera = QImagingCam()
# camera = FakeCalCamera(stageManip=controller, pipetteManip=pipetteManip, image_z=100, cellSorterManip=cellSorterManip)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0

unit = ManipulatorUnit(pipetteManip, [1, 2, 3])

daq = DAQ('Dev1', 'ai0', 'Dev1', 'ao0', 'Dev1', 'ai3')
# daq = DAQ('cDAQ1Mod1', 'ai0', 'cDaq1Mod4', 'ao0')

# daq = FakeDAQ()
# amplifier = FakeAmplifier()
# pressure = FakePressureController()
amplifier = MultiClampChannel(channel=1)

pressureControllerSerial = serial.Serial(port='COM5', baudrate=9600, timeout=0)
pressureReaderSerial = serial.Serial(port='COM9', baudrate=9600, timeout=0)
# pressureReaderSerial = serial.Serial(port='COM8', baudrate=9600, timeout=0)
# pressure = IBBPressureController(channel=1, arduinoSerial=pressureControllerSerial)
# pressure = TestPressureController(channel=1, controllerSerial=pressureControllerSerial, readerSerial=pressureReaderSerial)
pressure = MoscowPressureController(channel=1, controllerSerial=pressureControllerSerial, readerSerial=pressureReaderSerial)

================================================
File: /setup/setup_Moscow_DAQtest.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig specifically for the DAQ
'''

from holypipette.devices.amplifier.multiclamp import MultiClampChannel
from holypipette.devices.amplifier.DAQ import  DAQ
from holypipette.devices.pressurecontroller import FakePressureController
from holypipette.devices.camera import FakeCalCamera
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip



'''
Manipulator,Camera, and stage setup
'''
controller = FakeManipulator(min=[-240000, 50000, 280000],
                             max=[-230000, 60000, 290000])
pipetteManip = FakeManipulator(min=[0, 0, 0],
                                      max=[4000, 20000, 20000])
stage = ManipulatorUnit(controller, [1, 2])

cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()
camera = FakeCalCamera(stageManip=controller, pipetteManip=pipetteManip, image_z=100, cellSorterManip=cellSorterManip)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0
unit = ManipulatorUnit(pipetteManip, [1, 2, 3])

'''
DAQ  and Pressure setup
'''

daq = DAQ('cDAQ1Mod1', 'ai0', 'cDaq1Mod4', 'ao0', 'cDaq1Mod1', 'ai3')
amplifier = MultiClampChannel(channel=1)
pressure = FakePressureController()


================================================
File: /setup/setup_Moscow_Pressuretest.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
import serial
from holypipette.devices.amplifier.multiclamp import MultiClampChannel
from holypipette.devices.amplifier.amplifier import FakeAmplifier
from holypipette.devices.amplifier.DAQ import FakeDAQ, DAQ
from holypipette.devices.camera.pcocamera import PcoCamera
# from holypipette.devices.camera.qimagingcam import QImagingCam
from holypipette.devices.pressurecontroller import IBBPressureController, FakePressureController, TestPressureController, MoscowPressureController
from holypipette.devices.camera.camera import FakeCamera
from holypipette.devices.camera import FakeCalCamera, FakePipetteManipulator
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip


controller = FakeManipulator(min=[-240000, 50000, 280000],
                             max=[-230000, 60000, 290000])
pipetteManip = FakeManipulator(min=[0, 0, 0],
                                      max=[4000, 20000, 20000])
stage = ManipulatorUnit(controller, [1, 2])

cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()


camera = FakeCalCamera(stageManip=controller, pipetteManip=pipetteManip, image_z=100, cellSorterManip=cellSorterManip)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0

unit = ManipulatorUnit(pipetteManip, [1, 2, 3])


daq = FakeDAQ()
amplifier = FakeAmplifier()


pressureControllerSerial = serial.Serial(port='COM5', baudrate=9600, timeout=0)
pressureReaderSerial = serial.Serial(port='COM9', baudrate=9600, timeout=0)
pressure = MoscowPressureController(channel=1, controllerSerial=pressureControllerSerial, readerSerial=pressureReaderSerial)

================================================
File: /setup/setup_Moscow_arduinoDAQ.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
import serial
from holypipette.devices.amplifier.multiclamp import MultiClampChannel
from holypipette.devices.amplifier.amplifier import FakeAmplifier
from holypipette.devices.amplifier.DAQ import FakeDAQ, DAQ, ArduinoDAQ
from holypipette.devices.camera.pcocamera import PcoCamera
from holypipette.devices.pressurecontroller import  FakePressureController,  MoscowPressureController
from holypipette.devices.camera.camera import FakeCamera
from holypipette.devices.camera import FakeCalCamera, FakePipetteManipulator
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip


controllerSerial = serial.Serial('COM6')
controller = ScientificaSerialNoEncoder(controllerSerial)

pipetteSerial = serial.Serial('COM3')
pipetteManip = ScientificaSerialNoEncoder(pipetteSerial)
stage = ManipulatorUnit(controller, [1, 2])

# controller = FakeManipulator(min=[-240000, 50000, 280000],
#                              max=[-230000, 60000, 290000])
# pipetteManip = FakeManipulator(min=[0, 0, 0],
#                                       max=[4000, 20000, 20000])
stage = ManipulatorUnit(controller, [1, 2])

cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()


camera = PcoCamera()

# camera = FakeCalCamera(stageManip=controller, pipetteManip=pipetteManip, image_z=100, cellSorterManip=cellSorterManip)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0

unit = ManipulatorUnit(pipetteManip, [1, 2, 3])


ArdDAQserial = serial.Serial(port='COM11', baudrate=500000, timeout=1)
daq = ArduinoDAQ(DAQSerial=ArdDAQserial)
# daq = FakeDAQ()
# amplifier = FakeAmplifier()
# pressure = FakePressureController()
amplifier = MultiClampChannel(channel=1)

pressureControllerSerial = serial.Serial(port='COM5', baudrate=9600, timeout=0)
pressureReaderSerial = serial.Serial(port='COM9', baudrate=9600, timeout=0)
pressure = MoscowPressureController(channel=1, controllerSerial=pressureControllerSerial, readerSerial=pressureReaderSerial)

================================================
File: /setup/setup.py
================================================
from setuptools import setup, find_packages

setup(
    name='holypipette',
    version='0.1',
    description='Semi-automated patch clamp recordings',
    url='https://github.com/romainbrette/holypipette/',
    author='Romain Brette, Marcel Stimberg, Hoang Nguyen',
    author_email='romain.brette@inserm.fr',
    classifiers=[
        'Development Status :: 3 - Alpha',
        'Programming Language :: Python :: 2',
        'Programming Language :: Python :: 3',
    ],
    packages=find_packages(),
    install_requires=['numpy', 'PyQt5', 'qtawesome', 'pillow', 'pyserial',
                      'param', 'pyyaml']
)

================================================
File: /setup/setup_fake_rig.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
from holypipette.devices.amplifier.amplifier import FakeAmplifier
from holypipette.devices.amplifier.DAQ import FakeDAQ
from holypipette.devices.camera.pcocamera import PcoCamera
from holypipette.devices.pressurecontroller.BasePressureController import FakePressureController
from holypipette.devices.camera.camera import FakeCamera
from holypipette.devices.camera import FakeCalCamera, FakePipetteManipulator
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip

controller = FakeManipulator(min=[-240000, 50000, 280000],
                             max=[-230000, 60000, 290000])
pipetteManip = FakeManipulator(min=[0, 0, 0],
                                      max=[4000, 20000, 20000])
stage = ManipulatorUnit(controller, [1, 2])

cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()

pipetteManip.x = [200, 300, 400] # start with pipette in frame
controller.x = [-235000, 55000, 285000]
camera = FakeCalCamera(stageManip=controller, pipetteManip=pipetteManip, image_z=100, cellSorterManip=cellSorterManip)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0

unit = ManipulatorUnit(pipetteManip, [1, 2, 3])

daq = FakeDAQ()
amplifier = FakeAmplifier()
pressure = FakePressureController()

================================================
File: /setup/setup_IBB_rig.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
from holypipette.devices.amplifier.multiclamp import MultiClampChannel
from holypipette.devices.amplifier.amplifier import FakeAmplifier
from holypipette.devices.amplifier.DAQ import DAQ
from holypipette.devices.camera.pcocamera import PcoCamera
from holypipette.devices.manipulator import SensapexManip, ScientificaSerialNoEncoder
from holypipette.devices.pressurecontroller.IBBPressureController import IBBPressureController
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import CellSorterController, CellSorterManip, FakeCellSorterManip
import serial
from holypipette.devices.lamp import Lumencore

stageSerial = serial.Serial(port='COM7', baudrate=9600, timeout=1)
# zAxisEncoderComms = serial.Serial(port='COM19', baudrate=115200, timeout=1)
# stageController = ScientificaSerialEncoder(stageSerial, zAxisEncoderComms)
stageController = ScientificaSerialNoEncoder(stageSerial)

sensapexController = SensapexManip()
stage = ManipulatorUnit(stageController, [1, 2])

camera = PcoCamera()
microscope = Microscope(stageController, 3)
microscope.up_direction = 1.0

unit = ManipulatorUnit(sensapexController, [1, 2, 3])

# daq = DAQ('Dev6', 'ai1', 'Dev6', 'ao0') #This is "new" DAQ
daq = DAQ('cDAQ1Mod3', 'ai0', 'cDaq1Mod1', 'ao1') #This is "old" DAQ
amplifier = MultiClampChannel(channel=1)

pressureSerial = serial.Serial(port='COM5', baudrate=9600, timeout=0)
pressure = IBBPressureController(channel=1, arduinoSerial=pressureSerial)

controllerSerial = serial.Serial('COM12', 115200, timeout=2, parity=serial.PARITY_NONE, stopbits=1, 
                                    bytesize=8, write_timeout=1, inter_byte_timeout=2)
cellSorterController = CellSorterController(controllerSerial)

# manipulatorSerial = serial.Serial('COM10', 57600, timeout=2, parity=serial.PARITY_NONE, stopbits=2, 
#                                             bytesize=8, write_timeout=1, inter_byte_timeout=2)
# cellSorterManip = CellSorterManip(manipulatorSerial)

lampCom = serial.Serial('COM6', 9600, timeout=1, stopbits=serial.STOPBITS_ONE, parity=serial.PARITY_NONE, bytesize=serial.EIGHTBITS)
lumencore = Lumencore(lampCom)
cellSorterManip = FakeCellSorterManip()


================================================
File: /setup/setup_Moscow_rig.py
================================================
'''
"Fake setup" for GUI development on a computer without access to a rig
'''
import serial
from holypipette.devices.amplifier.multiclamp import MultiClampChannel
from holypipette.devices.amplifier.DAQ import  DAQ
from holypipette.devices.camera.pcocamera import PcoCamera
from holypipette.devices.pressurecontroller import MoscowPressureController
from holypipette.devices.manipulator import *
from holypipette.devices.cellsorter import FakeCellSorterController, FakeCellSorterManip


# set up Camera
camera = PcoCamera()

# set up Pressure Controller
pressureControllerSerial = serial.Serial(port='COM5', baudrate=9600, timeout=0)
pressureReaderSerial = serial.Serial(port='COM9', baudrate=9600, timeout=0)
pressure = MoscowPressureController(channel=1, controllerSerial=pressureControllerSerial, readerSerial=pressureReaderSerial)


# set up Ephys
amplifier = MultiClampChannel(channel=1)
daq = DAQ('cDAQ1Mod1', 'ai0', 'cDaq1Mod4', 'ao0', 'cDaq1Mod1', 'ai3')

# set up movement controllers

controllerSerial = serial.Serial('COM6')
controller = ScientificaSerialNoEncoder(controllerSerial)
microscope = Microscope(controller, 3)
microscope.up_direction = 1.0

pipetteSerial = serial.Serial('COM3')
pipetteManip = ScientificaSerialNoEncoder(pipetteSerial)
stage = ManipulatorUnit(controller, [1, 2])
unit = ManipulatorUnit(pipetteManip, [1, 2, 3])

# set up cell sorter
cellSorterController = FakeCellSorterController()
cellSorterManip = FakeCellSorterManip()







================================================
File: /TODO.txt
================================================
* Paramecium localization using bounded variation
* Test of motor commands
* Check microscope stack; maybe use slow moves instead of steps
* Units and stage: steps or slow moves when refocusing (move and track), fast moves for forward commands only
* Check last move of calibration.

-----

*** Multiple calibrations (objective)

* Actually start patch is problematic: capa comp etc, not at the right moment
* pulses for R measurement should be small

* Write template matching error during calibration
* it looks like photos are not stored during calibration
* Pressure wobble (see latest papers)
* Recalibrate only X axis (for angle change)
* Safe move: mvt in plane should also be safe, it's not

* Calibration in reference system
* Microscope stack: with slow move
* Crop around tip
* Locate pipette by movement
* Estimate motor ranges automatically
* Refactor calibration: Calibrator; calibrated_unit does not depend on camera
    => manipulator_unit could then absorb calibrated_unit
* Refactor calibration: Manipulation folder?
    => rewrite
* Should parameters be a dictionary instead?
* Should we move the pipette outside the autopatch algo?
* Refactor automatic patch: cut the run in pieces?

* Replace wait until still by wait until target reached (with deadline)
* In calibration: check whether best match is with the Z border (+- 8) => error

* Adjust speeds for horizontal moves
* Motor ranges using Home and Setting Home direction
* Maximization of calibration size
    (alternatively: abort when CalibrationError)
    check stage target position
* Possible optimization: instead of sleep before snap, do the template matching until stable results

** Automatically move and focus pipette when appearing on screen
    ideas: if tip on screen, look at how total intensity changes with focus
    In fact: move pipette up along X axis until there is no black on one border, or intensity
    disappears quickly. Then move up along Z axis until template matching works.

* DLL Path in multiclamp
* Resistance in status bar
* Safe move: add withdraw with correct direction


================================================
File: /holypipette/gui/livefeed.py
================================================
from __future__ import print_function
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt

import traceback
import numpy as np

import logging
import time

from holypipette.utils.FileLogger import FileLogger
from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.devices.camera.camera import Camera


__all__ = ['LiveFeedQt']


class LiveFeedQt(QtWidgets.QLabel):
    def __init__(self, camera: Camera, recording_state_manager: RecordingStateManager, image_edit=None, display_edit=None, mouse_handler=None, parent=None):

        super(LiveFeedQt, self).__init__(parent=parent)
        # The image_edit function (does nothing by default) gets the raw
        # unscaled image (i.e. a numpy array), while the display_edit
        # function gets a QPixmap and is meant to draw GUI elements in
        # "display space" (by default, a red cross in the middle of the
        # screen).
        if image_edit is None:
            image_edit = lambda frame: frame
        self.image_edit = image_edit

        if display_edit is None:
            display_edit = lambda img: img
        self.display_edit = display_edit

        self.mouse_handler = mouse_handler
        self.camera = camera
        self.width, self.height = self.camera.width, self.camera.height

        self.setMinimumSize(640, 480)
        self.setAlignment(Qt.AlignCenter)

        self.recording_state_manager = recording_state_manager
        self.recorder = FileLogger(recording_state_manager, folder_path="experiments/Data/rig_recorder_data/", isVideo=True, filetype="csv", recorder_filename="camera_frames")

        # Remember the last frame that we displayed, to not unnecessarily
        # process/show the same frame for slow input sources
        self._last_frameno = None
        self._last_edited_frame = None
        
        self.last_frame_time = None
        self.fps = 0

        self.update_image()

        timer = QtCore.QTimer(self)
        timer.timeout.connect(self.update_image)
        timer.start(28) # 30 fps -> 31.5fps
        # timer.start(16) # 60 fps --> but actually 64 fps
        # timer.start(33) # 30 fps --> but avctually 21.5 fps

    def mousePressEvent(self, event):
        # Ignore clicks that are not on the image
        xs = event.x() - self.size().width() * 0.5
        ys = event.y() - self.size().height() * 0.5
        pixmap = self.pixmap()
        if abs(xs) > pixmap.width() * 0.5 or abs(ys) > pixmap.height() * 0.5:
            self.setFocus()
            return

        if self.mouse_handler is not None:
            self.mouse_handler(event)

    def log_frame_rate(self):
    # Calculate and log the frame rate at which images are processed
        current_time = time.time()
        if self.last_frame_time is not None:
            time_diff = current_time - self.last_frame_time
            self.fps = 1.0 / time_diff
            logging.info(f"FPS in LIVEFEED: {self.fps:.2f}")
        self.last_frame_time = current_time

    @QtCore.pyqtSlot()
    def update_image(self):
        try:
            # get last frame from camera
            frameno, frame_time, frame = self.camera.last_frame_data()

            if frame is None:
                return  # Frame acquisition thread has stopped
            
            if self._last_frameno is None or self._last_frameno != frameno:
                frame = self.image_edit(frame)
            
                self._last_edited_frame = frame
                self._last_frameno = frameno
            else:
                # No need to preprocess a frame again if it has not changed
                frame = self._last_edited_frame

            # * Where you place tihs function is important, relative to repeated frames and such. Either you check in this file 
            # * or in the FileLogger file
            self.recorder.write_camera_frames(frame_time.timestamp(), frame, frameno)
            # self.log_frame_rate()
            # print(f"FRAME SHAPE: {frame.shape}")

            if len(frame.shape) == 2:
                # Grayscale image via MicroManager
                if frame.dtype == np.dtype('uint32'):
                    bytesPerLine = self.width*4
                    format = QtGui.QImage.Format_RGB32
                else:
                    bytesPerLine = self.width
                    format = QtGui.QImage.Format_Indexed8
            else:
                # Color image via OpenCV
                bytesPerLine = 3 * self.width
                format = QtGui.QImage.Format_RGB888
            
            # ? So why frame.data and not frame? frame.data points to a memory location. I think both work, but check https://doc.qt.io/qt-6/qimage.html#QImage-5
            q_image = QtGui.QImage(frame.data, self.width, self.height,
                                   bytesPerLine, format)
            # q_image = QtGui.QImage(frame, self.width, self.height,
            #                        bytesPerLine, format)
            
            
            if format == QtGui.QImage.Format_RGB888:
                # OpenCV returns images as 24bit BGR (and not RGB), but there is no
                # direct support for this format in QImage
                q_image = q_image.rgbSwapped()

            pixmap = QtGui.QPixmap.fromImage(q_image)
            size = self.size()
            width, height = size.width(), size.height()
            scaled_pixmap = pixmap.scaled(width, height,
                                          Qt.KeepAspectRatio,
                                          Qt.SmoothTransformation)
            if self.display_edit is not None:
                self.display_edit(scaled_pixmap)
            self.setPixmap(scaled_pixmap)

        except Exception:
            print(traceback.format_exc())


================================================
File: /holypipette/gui/manipulator.py
================================================
# coding=utf-8
from types import MethodType
import time

from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont
import numpy as np


from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.controller import TaskController
from holypipette.gui import CameraGui
from holypipette.interface import command, blocking_command
from holypipette.devices.manipulator.calibratedunit import CalibrationError
import datetime
import cv2


class ManipulatorGui(CameraGui):

    pipette_command_signal = QtCore.pyqtSignal(MethodType, object)
    pipette_reset_signal = QtCore.pyqtSignal(TaskController)

    def __init__(self, camera, pipette_interface, with_tracking=False, recording_state_manager: RecordingStateManager = None):
        super(ManipulatorGui, self).__init__(camera, with_tracking=with_tracking,recording_state_manager=recording_state_manager)
        self.setWindowTitle("Pipette GUI")
        self.interface = pipette_interface
        self.control_thread = QtCore.QThread()
        self.control_thread.setObjectName('PipetteControlThread')
        self.interface.moveToThread(self.control_thread)
        self.control_thread.start()
        self.interface_signals[self.interface] = (self.pipette_command_signal,
                                                  self.pipette_reset_signal)
        self.display_edit_funcs.append(self.draw_scale_bar)
        self.display_edit_funcs.append(self.display_manipulator)
        self.display_edit_funcs.append(self.show_tip)
        self.add_config_gui(self.interface.calibration_config)

        self.show_tip_on = False
        self.tip_x, self.tip_y = None, None
        self.tip_t0 = None

        # Stage position for display
        self._last_stage_measurement = None
        self._stage_position = (None, None, None)

        #number of images we've saved so far.  Allows images to have different names
        self.image_save_number = 0
        self.recording_state_manager = recording_state_manager
        if recording_state_manager is None:
            raise ValueError("RecordingStateManager must be provided")


    def display_manipulator(self, pixmap):
        '''
        Displays the number of the selected manipulator.
        '''
        painter = QtGui.QPainter(pixmap)
        pen = QtGui.QPen(QtGui.QColor(200, 0, 0, 125))
        painter.setPen(pen)
        painter.setFont(QFont("Arial", int(pixmap.height()/20)))
        c_x, c_y = pixmap.width() *19.0 / 20, pixmap.height() * 19.0 / 20

    def draw_scale_bar(self, pixmap, text=True, autoscale=True,
                       position=True):
        if autoscale and not text:
            raise ValueError('Automatic scaling of the bar without showing text '
                             'will not be very helpful...')
        stage = self.interface.calibrated_stage
        camera_pixel_per_um = getattr(self.camera, 'pixel_per_um', None)
        if stage.calibrated or camera_pixel_per_um:
            pen_width = 4
            if camera_pixel_per_um is not None:
                bar_length = camera_pixel_per_um
            else:
                bar_length = stage.pixel_per_um()[0]
            scale = 1.0 * self.camera.width / pixmap.size().width()
            scaled_length = bar_length/scale
            if autoscale:
                lengths = np.array([1, 2, 5, 10, 20, 50, 100])
                if scaled_length*lengths[-1] < pen_width:
                    # even the longest bar is not long enough -- don't show
                    # any scale bar
                    return
                elif scaled_length*lengths[0] > 20*pen_width:
                    # the shortest bar is not short enough (>20x the width)
                    length_in_um = lengths[0]
                else:
                    # Use the length that gives a bar of about 10x its width
                    length_in_um = lengths[np.argmin(np.abs(scaled_length*lengths - 10*pen_width))]
            else:
                length_in_um = 10

            painter = QtGui.QPainter(pixmap)
            pen = QtGui.QPen(QtGui.QColor(0, 0, 0, 255))
            pen.setWidth(pen_width)
            painter.setPen(pen)
            c_x, c_y = pixmap.width() / 20, pixmap.height() * 19.0 / 20
            c_x = int(c_x)
            c_y = int(c_y)
            painter.drawLine(int(c_x), c_y,
                             int(c_x + round(length_in_um*scaled_length)), c_y)
            if text:
                painter.drawText(c_x, c_y - 10, '{}µm'.format(length_in_um))
            painter.end()

    def register_commands(self, manipulator_keys = True):
        super(ManipulatorGui, self).register_commands()

        if manipulator_keys:
            # Commands to move the stage
            # Note that we do not use the automatic documentation mechanism here,
            # as we one entry for every possible keypress
            modifiers = [Qt.NoModifier, Qt.AltModifier, Qt.ShiftModifier]
            distances = [10., 2.5, 50.]
            self.help_window.register_custom_action('Stage',  'Arrows',
                                                    'Move stage')
            self.help_window.register_custom_action('Stage',
                                                    '/'.join(QtGui.QKeySequence(mod).toString()
                                                                 if mod is not Qt.NoModifier else 'No modifier'
                                                             for mod in modifiers),
                                                    'Move stage by ' + '/'.join(str(x) for x in distances) + ' µm')
            self.help_window.register_custom_action('Manipulators', 'A/S/W/D',
                                                    'Move pipette by in x/y direction')
            self.help_window.register_custom_action('Manipulators', 'Q/E',
                                                    'Move pipette by in z direction')
            self.help_window.register_custom_action('Manipulators',
                                                    '/'.join(QtGui.QKeySequence(mod).toString()
                                                                 if mod is not Qt.NoModifier else 'No modifier'
                                                             for mod in modifiers),
                                                    'Move pipette by ' + '/'.join(str(x) for x in distances) + ' µm')

            for modifier, distance in zip(modifiers, distances):
                self.register_key_action(Qt.Key_Up, modifier,
                                         self.interface.move_stage_vertical,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_Down, modifier,
                                         self.interface.move_stage_vertical,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_Left, modifier,
                                         self.interface.move_stage_horizontal,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_Right, modifier,
                                         self.interface.move_stage_horizontal,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_W, modifier,
                                         self.interface.move_pipette_y,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_S, modifier,
                                         self.interface.move_pipette_y,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_A, modifier,
                                         self.interface.move_pipette_x,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_D, modifier,
                                         self.interface.move_pipette_x,
                                         argument=-distance, default_doc=False)
                self.register_key_action(Qt.Key_Q, modifier,
                                         self.interface.move_pipette_z,
                                         argument=distance, default_doc=False)
                self.register_key_action(Qt.Key_E, modifier,
                                         self.interface.move_pipette_z,
                                         argument=-distance, default_doc=False)

        # #save image command
        # self.register_key_action(Qt.Key_I, Qt.NoModifier,
        #                          self.save_image)

        # Show the tip
        self.register_key_action(Qt.Key_T, Qt.NoModifier,
                                 self.show_tip_switch)

        # Calibration commands
        self.register_key_action(Qt.Key_C, Qt.ControlModifier,
                                 self.interface.calibrate_stage)
        self.register_key_action(Qt.Key_C, Qt.NoModifier,
                                 self.interface.calibrate_manipulator)
        self.register_key_action(Qt.Key_F, Qt.ControlModifier,
                                 self.interface.focus_pipette)

        # Move pipette by clicking
        self.register_mouse_action(Qt.LeftButton, Qt.ShiftModifier,
                                   self.interface.move_pipette)

        # Move stage by clicking
        self.register_mouse_action(Qt.RightButton, Qt.NoModifier,
                                   self.interface.move_stage)

        # Microscope control
        self.register_key_action(Qt.Key_PageUp, None,
                                 self.interface.move_microscope,
                                 argument=10, default_doc=False)
        self.register_key_action(Qt.Key_PageDown, None,
                                 self.interface.move_microscope,
                                 argument=-10, default_doc=False)
        key_string = (QtGui.QKeySequence(Qt.Key_PageUp).toString() + '/' +
                      QtGui.QKeySequence(Qt.Key_PageDown).toString())
        self.help_window.register_custom_action('Microscope', key_string,
                                                'Move microscope up/down by 10µm')
        self.register_key_action(Qt.Key_F, None,
                                 self.interface.set_floor)
        self.register_key_action(Qt.Key_G, None,
                                 self.interface.go_to_floor)

        # Show configuration pane
        self.register_key_action(Qt.Key_P, None,
                                 self.configuration_keypress)

        # Toggle overlays
        self.register_key_action(Qt.Key_O, None,
                                 self.toggle_overlay)

    @command(category='Manipulators',
             description='Show the tip of selected manipulator')
    def show_tip_switch(self):
        try:
            self.tip_x, self.tip_y, _ = self.interface.calibrated_unit.reference_position()
            self.tip_t0 = time.time()
            self.show_tip_on = True
        except CalibrationError:  # not yet calibrated
            return

    def show_tip(self, pixmap):
        # Show the tip of the electrode
        if self.show_tip_on:
            interface = self.interface
            scale = 1.0 * self.camera.width / pixmap.size().width()
            pixel_per_um = getattr(self.camera, 'pixel_per_um', None)
            if pixel_per_um is None:
                pixel_per_um = interface.calibrated_unit.stage.pixel_per_um()[0]
            painter = QtGui.QPainter(pixmap)
            pen = QtGui.QPen(QtGui.QColor(0, 0, 200, 125))
            pen.setWidth(3)
            painter.setPen(pen)

            x, y = self.tip_x, self.tip_y
            painter.translate(x / scale, y / scale)

            if x is not None:
                painter.drawRect(-10, -10, 10, 10)
            painter.end()

            # Display for just one second
            if time.time()>self.tip_t0+1.:
                self.show_tip_on = False
    
    @command(category='Camera',
             description='Save the current image to the outputs folder')
    def save_image(self):
        #get the current image
        currImg = self.camera.get_16bit_image()

        #save the image
        cv2.imwrite(f'outputs/{self.image_save_number}.png', currImg)
        print(f'Saved image as outputs/{self.image_save_number}.png')
        self.image_save_number += 1


    def display_timer(self, pixmap):
        interface = self.interface
        painter = QtGui.QPainter(pixmap)
        pen = QtGui.QPen(QtGui.QColor(200, 0, 0, 125))
        pen.setWidth(1)
        painter.setPen(pen)
        c_x, c_y = pixmap.width() / 20, pixmap.height() / 20
        t = int(time.time() - interface.timer_t0)
        hours = t//3600
        minutes = (t-hours*3600)//60
        seconds = t-hours*3600-minutes*60
        painter.drawText(c_x, c_y, '{}'.format(datetime.time(hours,minutes,seconds)))
        painter.end()


================================================
File: /holypipette/gui/__init__.py
================================================
from __future__ import absolute_import
from .livefeed import *
from .camera import *
from .manipulator import ManipulatorGui
from .patch import *
from .graph import CurrentProtocolGraph, EPhysGraph, VoltageProtocolGraph, HoldingProtocolGraph

================================================
File: /holypipette/gui/movingList.py
================================================
# What is this doing here?
import collections

moveList = []
position_history = collections.deque(maxlen = 50)
tracking = False
paramecium_stop = False
contact = True
black_area = []
paramecium_z = None
template = []

================================================
File: /holypipette/gui/patch.py
================================================
from __future__ import absolute_import

from types import MethodType

from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import Qt
import PyQt5.QtGui as QtGui
import numpy as np
import logging

from PyQt5.QtWidgets import QDesktopWidget

from holypipette.controller import TaskController
from holypipette.gui.manipulator import ManipulatorGui
from holypipette.interface.patch import AutoPatchInterface
from holypipette.interface.pipettes import PipetteInterface
from holypipette.utils.RecordingStateManager import RecordingStateManager
from holypipette.interface.base import command

from holypipette.utils.FileLogger import FileLogger
from datetime import datetime
import json
import os

class PatchGui(ManipulatorGui):

    patch_command_signal = QtCore.pyqtSignal(MethodType, object)
    patch_reset_signal = QtCore.pyqtSignal(TaskController)

    def __init__(self, camera, pipette_interface: PipetteInterface, patch_interface: AutoPatchInterface, recording_state_manager: RecordingStateManager, with_tracking=False):
        super(PatchGui, self).__init__(camera, pipette_interface,with_tracking=with_tracking,recording_state_manager=recording_state_manager)

        self.setWindowTitle("Patch GUI")
        # Note that pipette interface already runs in a thread, we need to use
        # the same for the patch interface

        self.patch_interface = patch_interface
        self.pipette_interface = pipette_interface
        self.recording_state_manager = recording_state_manager

        self.patch_interface.moveToThread(pipette_interface.thread())
        self.interface_signals[self.patch_interface] = (self.patch_command_signal,
                                                        self.patch_reset_signal)
    
        try:
            # Add patching button tab
            # button_tab = PatchButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals, self.recording_state_manager)
            self.add_config_gui(self.patch_interface.config)
            logging.debug("Added config GUI.")
            # self.add_tab(button_tab, 'Auto Patching', index=0)
            logging.debug("Added 'Auto Patching' tab.")
        except Exception as e:
            logging.error("Exception during PatchGui initialization: %s", e, exc_info=True)
            raise
        # #add cell sorter button tab
        # cellsorter_tab = CellSorterButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals)
        # self.add_tab(cellsorter_tab, 'Cell Sorter', index = 0)

        # add manual patching button tab
        # manual_patching_tab = ManualPatchButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals, self.recording_state_manager)
        # self.add_tab(manual_patching_tab, 'Manual Patching', index = 0)
        # add semi-auto patching button tab
        semi_auto_patching_tab = SemiAutoPatchButtons(self.patch_interface, pipette_interface, self.start_task, self.interface_signals, self.recording_state_manager)
        self.add_tab(semi_auto_patching_tab, 'Semi-Auto Patching', index = 0)

        # Update the pressure and information in the status bar every 16ms
        self.pressure_timer = QtCore.QTimer()
        self.pressure_timer.timeout.connect(self.display_pressure)
        self.pressure_timer.start(16)
        self.patch_interface.set_pressure_near()

    def display_pressure(self):

        current_pressure = self.patch_interface.pressure.getLastVal()
        self.set_status_message('pressure', 'Pressure: {:.0f} mbar'.format(current_pressure))

    def register_commands(self):
        super(PatchGui, self).register_commands()
        # self.register_mouse_action(Qt.LeftButton, Qt.ShiftModifier,
        #                            self.patch_interface.patch_with_move)
        self.register_mouse_action(Qt.LeftButton, Qt.NoModifier,
                                   self.patch_interface.add_cell)
        self.register_key_action(Qt.Key_B, None,
                                 self.patch_interface.break_in)
        self.register_key_action(Qt.Key_F2, None,
                                 self.patch_interface.store_cleaning_position)
        self.register_key_action(Qt.Key_F3, None,
                                 self.patch_interface.store_rinsing_position)
        self.register_key_action(Qt.Key_F4, None,
                                 self.patch_interface.clean_pipette)


class TrackingPatchGui(PatchGui):
    def __init__(self, camera, pipette_interface, patch_interface,
                 with_tracking=False):
        super(TrackingPatchGui, self).__init__(camera, pipette_interface,
                                               patch_interface,
                                               with_tracking=True)
        self.setWindowTitle("Patch GUI with tracking")

    def register_commands(self):
        super(TrackingPatchGui, self).register_commands()
        self.register_key_action(Qt.Key_F5, None,
                                 self.patch_interface.sequential_patching)
        self.register_key_action(Qt.Key_F8, None,
                                 self.patch_interface.contact_detection)

class CollapsibleGroupBox(QtWidgets.QGroupBox):
    def __init__(self, title="", parent=None):
        super(CollapsibleGroupBox, self).__init__(parent)
        self.setTitle("")  # Set the group box title to be blank to allow custom styling

        # Apply styles for rounded corners, grey borders, and consistent font
        self.setStyleSheet("""
            QGroupBox {
                border: 1px solid lightgray;  /* Light grey border */
                border-radius: 8px;           /* Rounded corners with 8px radius */
                margin-top: 10px;             /* Adjust top margin for visual separation */
                font-family: Arial, Helvetica, sans-serif;  /* Consistent font family */
                font-size: 14px;              /* Consistent font size for the group box */
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 3px;
                font-weight: bold;            /* Bold for the group box title */
            }
            QWidget {
                background-color: #f9f9f9;    /* Light grey background for the content area */
                border-radius: 8px;
                font-family: Arial, Helvetica, sans-serif;  /* Consistent font family */
                font-size: 14px;              /* Consistent font size for content area */
            }
            QPushButton {
                background-color: #ffffff;     /* White background for buttons */
                border: 1px solid lightgray;   /* Light grey border for buttons */
                border-radius: 6px;            /* Slightly rounded corners for buttons */
                padding: 6px;                  /* Padding for a better button look */
                font-family: Arial, Helvetica, sans-serif;  /* Consistent font family */
                font-size: 14px;               /* Adjusted font size for buttons *